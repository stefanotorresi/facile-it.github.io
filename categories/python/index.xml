<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Facile.it Engineering</title>
    <link>/categories/python/</link>
    <description>Recent content in Python on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 28 Sep 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>WAMP, Web Application Messaging Protocol.. e PHP!</title>
      <link>/blog/ita/wamp-web-application-messaging-protocol-e-php/</link>
      <pubDate>Mon, 28 Sep 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/wamp-web-application-messaging-protocol-e-php/</guid>
      <description>

&lt;p&gt;Dalle notifiche di Facebook ad un tweet stream, da Google Docs ai giochi multiplayer in HTML5, la necessità di uno &lt;strong&gt;scambio dati&lt;/strong&gt; in &lt;strong&gt;due direzioni&lt;/strong&gt;, &lt;strong&gt;efficiente&lt;/strong&gt; e a &lt;strong&gt;bassa latenza&lt;/strong&gt;, ha determinato l’ascesa negli ultimi anni di &lt;strong&gt;soluzioni basate su &lt;a href=&#34;https://www.websocket.org/&#34; target=&#34;_blank&#34;&gt;WebSocket&lt;/a&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Internet delle cose e web 2.0 trovano oramai sempre &lt;strong&gt;meno spazio&lt;/strong&gt; all’interno del protocollo &lt;strong&gt;HTTP/1&lt;/strong&gt;. Le tecniche di &lt;strong&gt;polling e long polling&lt;/strong&gt;, in voga fino a pochi anni fa, non permettevano di trasmettere in &lt;a href=&#34;https://it.wikipedia.org/wiki/Duplex&#34; target=&#34;_blank&#34;&gt;full duplex&lt;/a&gt; (tra server e client) contemporaneamente, erano costrette ad un alto overhead HTTP e richiedevano &lt;strong&gt;diversi sforzi&lt;/strong&gt; per simulare notifiche push server side.&lt;/p&gt;

&lt;h4 id=&#34;il-protocollo-wamp:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;Il protocollo WAMP&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://wamp.ws/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;WAMP&lt;/strong&gt;&lt;/a&gt; (Web Application Messaging Protocol e non Windows, Apache, etc.!) offre un moderno &lt;strong&gt;pattern di messaggistica&lt;/strong&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Remote_procedure_call&#34; target=&#34;_blank&#34;&gt;RPC&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&#34; target=&#34;_blank&#34;&gt;Pub/Sub&lt;/a&gt; in maniera unificata. Registrato presso lo &lt;a href=&#34;https://en.wikipedia.org/wiki/Internet_Assigned_Numbers_Authority&#34; target=&#34;_blank&#34;&gt;IANA&lt;/a&gt; come sottoprotocollo WebSocket, definisce uno &lt;strong&gt;standard aperto&lt;/strong&gt; per lo scambio di &lt;strong&gt;messaggi in tempo reale&lt;/strong&gt; tra applicazioni e componenti, e permette la creazione di architetture &lt;strong&gt;debolmente accoppiate&lt;/strong&gt; basate su &lt;strong&gt;microservizi&lt;/strong&gt;. Utilizza canali full-duplex ordinati ed è quindi adatto ad implementazioni basate su WebSocket, ma supporta allo stesso modo socket Unix, socket raw o long polling HTTP.&lt;/p&gt;

&lt;p&gt;Il protocollo risulta piuttosto &lt;strong&gt;completo ed adeguato&lt;/strong&gt; a diversi scenari di utilizzo se comparato ad altri sistemi di messaggistica ed RPC.&lt;/p&gt;

&lt;p&gt;&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Technology&lt;/th&gt;
&lt;th&gt;PubSub&lt;/th&gt;
&lt;th&gt;RPC&lt;/th&gt;
&lt;th&gt;Routed RPC&lt;/th&gt;
&lt;th&gt;Web native&lt;/th&gt;
&lt;th&gt;Cross Language&lt;/th&gt;
&lt;th&gt;Open Standard&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WAMP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AJAX&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMQP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;REST&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SOAP&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Socket.io&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SockJS&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;XMPP&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ZeroMQ&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;em&gt;fonte: Wikipedia&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Può essere utilizzato con profitto per sviluppare una piattaforma di gioco &lt;strong&gt;online multiplayer&lt;/strong&gt;, strumenti di &lt;strong&gt;business intelligence&lt;/strong&gt; real time e &lt;strong&gt;piattaforme collaborative&lt;/strong&gt; per numerosi utenti.&lt;/p&gt;

&lt;p&gt;Una piattaforma web di help desk ad esempio, può beneficiare di notifiche, chat, strumenti di scrittura multi-utente ed analisi dell’andamento in tempo reale  &lt;strong&gt;sullo stesso protocollo WAMP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Per funzionare WAMP necessità di uno o più server di &lt;strong&gt;routing centralizzati&lt;/strong&gt;, allo stesso modo di &lt;strong&gt;RabbitMQ per AMQP&lt;/strong&gt;.
Per quanto esistano diverse implementazioni di router, in diversi linguaggi, lo standard &lt;em&gt;de facto&lt;/em&gt; è rappresentato da &lt;a href=&#34;http://crossbar.io/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Crossbar&lt;/strong&gt;&lt;/a&gt;, sviluppato da &lt;a href=&#34;http://tavendo.com/&#34; target=&#34;_blank&#34;&gt;Tavendo&lt;/a&gt;, alla quale si deve anche la &lt;strong&gt;definizione del protocollo&lt;/strong&gt; stesso.&lt;/p&gt;

&lt;h4 id=&#34;crossbar:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;Crossbar&lt;/h4&gt;

&lt;p&gt;Crossbar, scritto in python (&lt;a href=&#34;https://github.com/crossbario/crossbar&#34; target=&#34;_blank&#34;&gt;open source&lt;/a&gt;, licenza AGPL v3), supporta completamente le funzionalità descritte dal protocollo oltre a vantare &lt;strong&gt;configurazioni avanzate&lt;/strong&gt; come ad esempio le subscriptions &lt;a href=&#34;http://crossbar.io/docs/Pattern-Based-Subscriptions/&#34; target=&#34;_blank&#34;&gt;basate su pattern&lt;/a&gt;, le &lt;a href=&#34;http://crossbar.io/docs/Progressive-Call-Results/&#34; target=&#34;_blank&#34;&gt;progressive result&lt;/a&gt; su RPC e profili di autenticazione ed &lt;a href=&#34;http://crossbar.io/docs/Authorization/&#34; target=&#34;_blank&#34;&gt;autorizzazione&lt;/a&gt; dinamici.&lt;/p&gt;

&lt;p&gt;Nessuna delle altre implementazioni è poi al momento in grado di vantare le stesse &lt;strong&gt;prestazioni&lt;/strong&gt; e la &lt;strong&gt;stabilità&lt;/strong&gt; di Crossbar: una istanza del router è in grado di servire 1000 messaggi/secondo su Pub/Sub, a 1000 client, con una &lt;strong&gt;latenza di 25ms&lt;/strong&gt; su una &lt;strong&gt;RaspberryPi&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;&lt;table&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;th&gt;Router&lt;/th&gt;
&lt;th&gt;Broker&lt;/th&gt;
&lt;th&gt;Dealer&lt;/th&gt;
&lt;th&gt;Advanced Profile&lt;/th&gt;
&lt;th&gt;Language&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Crossbar&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;Pyhton&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Thruway&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wamp.rt&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;NodeJS&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jawampa&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WampSharp&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Erwa&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;✔&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Erlang&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;em&gt;fonte: WAMP.ws&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;e-php:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;..e PHP?&lt;/h4&gt;

&lt;p&gt;Diverse applicazioni web di backend usate presso Facile.it permettono ad un gran numero di operatori di lavorare sulle stesse pratiche in maniera collaborativa in &lt;strong&gt;tempo reale&lt;/strong&gt;.
Il protocollo WAMP è una tecnologia sulla quale è possibile sviluppare in maniera efficiente &lt;strong&gt;dashboard collaborative&lt;/strong&gt; e realtime.. ma sarà anche in grado di funzionare adeguatamente assieme alle soluzioni PHP (spesso in Symfony 2) sviluppate in casa e &lt;strong&gt;non precedentemente disegnate per l&amp;rsquo;uso con WebSocket&lt;/strong&gt;?&lt;/p&gt;

&lt;p&gt;Esistono diverse librerie (come &lt;a href=&#34;https://github.com/voryx/Thruway&#34; target=&#34;_blank&#34;&gt;Thruway&lt;/a&gt;) che permettono di operare come &lt;strong&gt;client PHP&lt;/strong&gt; in ambiente WAMP, ma per &lt;strong&gt;semplificare&lt;/strong&gt; l&amp;rsquo;integrazione del protocollo con altri servizi, Crossbar supporta il &lt;a href=&#34;http://crossbar.io/docs/HTTP-Bridge-Services/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;bridge HTTP&lt;/strong&gt;&lt;/a&gt; delle funzionalità Pub/Sub e RPC.&lt;/p&gt;

&lt;p&gt;In pratica, parlando ad esempio di Pub/Sub, è possibile &lt;strong&gt;pubblicare via HTTP&lt;/strong&gt; (o HTTPS) su Crossbar messaggi che saranno inoltrati su topic ai &lt;strong&gt;client connessi via WebSocket&lt;/strong&gt; in maniera trasparente. Altresì è possibile &lt;strong&gt;iscriversi ai topic&lt;/strong&gt; fornendo un &lt;strong&gt;endpoint HTTP&lt;/strong&gt; da chiamare per ricevere i messaggi pubblicati da client WebSocket.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;esempio sottostante configura un router Crossbar in grado di accettare connessioni websocket, pubblicazioni via HTTP e che si occupa di forwardare alcuni messaggi ad un endpoint HTTPS:&lt;/p&gt;

&lt;p&gt;&lt;style type=&#34;text/css&#34;&gt;
  .gist-file
  .gist-data {max-height: 500px;}
&lt;/style&gt;
&lt;script src=&#34;https://gist.github.com/peelandsee/51417b3c7c1dc400e85f.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Il gist precedente può essere lanciato al volo con &lt;a href=&#34;https://docs.docker.com/&#34; target=&#34;_blank&#34;&gt;docker&lt;/a&gt;:
&lt;code&gt;docker run -p 80:80 -p 8080:8080 -v $PWD/crossbar-config.json:/.crossbar/config.json vinelab/crossbar&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Ovviamente l&amp;rsquo;esempio non tiene conto di profili di configurazione più avanzati, come &lt;strong&gt;cifratura TLS&lt;/strong&gt;, autenticazione, ruoli separati di pubblicazione e/o iscrizione, disponibili nella documentazione di Crossbar.&lt;/p&gt;

&lt;p&gt;Features come la firma delle richieste HTTP, richiedono più di qualche minuto di sviluppo, ma sono indispensabili in un &lt;strong&gt;ambiente di produzione&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Per semplificare l&amp;rsquo;adozione del bridge HTTP in &lt;strong&gt;ambito PHP&lt;/strong&gt;, in Facile.it abbiamo sviluppato e rilasciato un &lt;strong&gt;bundle&lt;/strong&gt; che permette la configurazione automatica di &lt;strong&gt;servizi di Publisher WAMP nel service container&lt;/strong&gt; di Symfony 2.&lt;/p&gt;

&lt;p&gt;Il bundle, disponibile su &lt;a href=&#34;https://packagist.org/packages/facile-it/crossbar-http-publisher-bundle&#34; target=&#34;_blank&#34;&gt;Packagist (composer)&lt;/a&gt; può essere installato con
&lt;code&gt;$ composer require facile-it/crossbar-http-publisher-bundle dev-master&lt;/code&gt;
e richiede una &lt;strong&gt;configurazione rapida&lt;/strong&gt; ed intuitiva:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;facile_crossbar_http_publisher:
  connections:
    foo_publisher_1:
        protocol: http
        host: 127.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;uso è molto semplice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// recupero del servizio
$fooPublisher = $container
                -&amp;gt;get(&#39;facile.crossbar.publisher.foo_publisher_1&#39;);

$topic = &#39;com.myapp.hello&#39;;

// pubblicazione
$firstPublisher-&amp;gt;publish($topic, [&#39;foo&#39;,1]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con le poche righe sopra riportate, attraverso il metodo &lt;code&gt;publish()&lt;/code&gt; viene effettuata una &lt;strong&gt;chiamata HTTP POST&lt;/strong&gt; verso il router WAMP, ed il messaggio &lt;code&gt;[&#39;foo&#39;,1]&lt;/code&gt; raggiunge in tempo (quasi) reale tutti i client (ad esempio &lt;strong&gt;tutti i browser degli utenti&lt;/strong&gt;) iscritti al topic &lt;code&gt;com.myapp.hello&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Anche in questo caso, la &lt;a href=&#34;http://crossbar.io/docs/Processes/&#34; target=&#34;_blank&#34;&gt;configurazione&lt;/a&gt; può supportare diversi host, porte, uso TLS, signed request, e attraverso GitHub è possibile trovare &lt;a href=&#34;https://github.com/crossbario/crossbarexamples&#34; target=&#34;_blank&#34;&gt;diversi esempi&lt;/a&gt; di &lt;strong&gt;possibili configurazioni&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;ma-i-miei-utenti-lo-supporteranno:403f2d6c5e9e2691ac7a267aa4a7309e&#34;&gt;..ma i miei utenti lo supporteranno?&lt;/h4&gt;

&lt;p&gt;Lato browser, passare a WAMP è davvero &lt;strong&gt;semplice&lt;/strong&gt;:
la libreria &lt;a href=&#34;http://autobahn.ws/js/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Autobahn|JS&lt;/strong&gt;&lt;/a&gt; garantisce piena &lt;strong&gt;compatibilità&lt;/strong&gt; anche per &lt;a href=&#34;https://nodejs.org/en/&#34; target=&#34;_blank&#34;&gt;node.js&lt;/a&gt;, supporta l&amp;rsquo;autenticazione, ed è in grado di gestire in maniera &lt;strong&gt;asincronia&lt;/strong&gt; sia RPC che Pub/Sub.&lt;/p&gt;

&lt;p&gt;Qualora il browser di un vostro utente non supportasse WebSocket (e &lt;a href=&#34;http://caniuse.com/#feat=websockets&#34; target=&#34;_blank&#34;&gt;dovrebbe&lt;/a&gt; oramai!), Autobahn|JS è in grado di fornire un &lt;strong&gt;fallback automatico&lt;/strong&gt; a long polling.&lt;/p&gt;

&lt;p&gt;Iscriversi ad un topic o pubblicare un messaggio richiede poche linee:&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/peelandsee/c853bc3fd3971e78527c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Nell&amp;rsquo;esempio sopra riportato, il client JS &lt;strong&gt;si iscrive&lt;/strong&gt; al topic &lt;code&gt;com.myapp.hello&lt;/code&gt; e passa i messaggi ricevuti ad una semplice funzione &lt;code&gt;console.log()&lt;/code&gt;; inoltre &lt;strong&gt;pubblica un messaggio&lt;/strong&gt; sul topic &lt;code&gt;com.myapp.topic1&lt;/code&gt;. Quest&amp;rsquo;ultimo, sarà anche &lt;strong&gt;forwardato da Crossbar sul nostro endpoint HTTPS&lt;/strong&gt; &lt;code&gt;https://hostname/subscriptions&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Grazie alle &lt;strong&gt;funzionalità HTTP bridge&lt;/strong&gt; di Crossabar l&amp;rsquo;utilizzo di WAMP in ambito PHP, senza connessioni persistenti o consumer sempre accesi, è &lt;strong&gt;semplice ed immediato&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Per un ulteriore &lt;strong&gt;approfondimento su WAMP&lt;/strong&gt;, saranno inoltre utili le slide che seguono:&lt;/p&gt;

&lt;p&gt;&lt;iframe src=&#34;//www.slideshare.net/slideshow/embed_code/key/MEmo82CFgt1xND&#34; width=&#34;700&#34; height=&#34;550&#34; frameborder=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; scrolling=&#34;no&#34; style=&#34;border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;&#34; allowfullscreen&gt; &lt;/iframe&gt; &lt;div style=&#34;margin-bottom:5px&#34;&gt;&lt;/p&gt;

&lt;p&gt;Riferimenti:&lt;/p&gt;

&lt;p&gt;WAMP - &lt;a href=&#34;http://wamp.ws/&#34; target=&#34;_blank&#34;&gt;Protocol&lt;/a&gt;&lt;br/&gt;
Crossbar - &lt;a href=&#34;http://crossbar.io/docs/TOC/&#34; target=&#34;_blank&#34;&gt;Documentazione&lt;/a&gt;&lt;br/&gt;
Crossbar - &lt;a href=&#34;http://crossbar.io/docs/HTTP-Bridge-Services/&#34; target=&#34;_blank&#34;&gt;HTTP Bridge&lt;/a&gt;&lt;br/&gt;
Autobahn|JS - &lt;a href=&#34;http://autobahn.ws/js/&#34; target=&#34;_blank&#34;&gt;Documentazione&lt;/a&gt;&lt;br/&gt;
Facile.it CrossbarHTTPPublisherBundle - &lt;a href=&#34;https://github.com/facile-it/crossbar-http-publisher-bundle&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Intelligenza artificiale: algoritmo A*</title>
      <link>/blog/ita/intelligenza-artificiale-algoritmo-a-star/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/intelligenza-artificiale-algoritmo-a-star/</guid>
      <description>

&lt;h1 id=&#34;introduzione:2400028604853ea154d2cde8c70195ac&#34;&gt;Introduzione&lt;/h1&gt;

&lt;p&gt;A* è un &lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_di_ricerca&#34;&gt;algoritmo di ricerca&lt;/a&gt; e ottimizzazione basato su grafi. Viene frequentemente impiegato nell&amp;rsquo;&lt;a href=&#34;https://it.wikipedia.org/wiki/Intelligenza_artificiale&#34;&gt;intelligenza artificiale&lt;/a&gt; perché in grado di gestire grafi ampi e
indeterminati.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;algoritmo A* può essere utilizzato per risolvere problemi come: &lt;a href=&#34;https://it.wikipedia.org/wiki/Gioco_del_quindici&#34;&gt;gioco del 15&lt;/a&gt;, percorso minimo, &lt;a href=&#34;https://it.wikipedia.org/wiki/Sudoku&#34;&gt;Sudoku&lt;/a&gt;, &lt;a href=&#34;https://it.wikipedia.org/wiki/Cubo_di_Rubik&#34;&gt;cubo di Rubik&lt;/a&gt;, ecc.&lt;/p&gt;

&lt;p&gt;In generale, A* può risolvere efficacemente i problemi che soddisfano i requisiti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La soluzione è determinata da cambamenti sequenziali di stato rappresentabili con grafi;&lt;/li&gt;
&lt;li&gt;Il nodo iniziale e il nodo finale devono essere noti. Talvolta è sufficiente conoscere solo le regole che compongono la soluzione (vedi Sudoku);&lt;/li&gt;
&lt;li&gt;Deve essere noto un &lt;strong&gt;algoritmo euristico&lt;/strong&gt; che &lt;strong&gt;stima&lt;/strong&gt; il costo del percorso tra un nodo qualsiasi e la soluzione.&lt;/li&gt;
&lt;li&gt;Deve essere sempre noto il costo che separa due nodi adiacenti. (Nella maggioranza dei problemi tale valore è sempre unitario).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;l-euristica:2400028604853ea154d2cde8c70195ac&#34;&gt;L&amp;rsquo;euristica&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;&lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_euristico&#34;&gt;algoritmo euristico&lt;/a&gt; ha il compito di stimare la distanza tra qualsiasi nodo e la soluzione.
L&amp;rsquo;euristica influenza fortemente i risultati conseguiti da A*. Esso, in particolare, ne determina il tempo complessivo di esecuzione.
Un algoritmo euristico molto efficace consente ad A* di trovare velocemente la soluzione.
Nel caso pessimo, una funzione euristica costante, A* diviene un algoritmo di ricerca molto simile a &lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_di_Dijkstra&#34;&gt;Dijkstra&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;euristica determina anche la qualità della soluzione finale.
Con un&amp;rsquo;&lt;a href=&#34;http://www.okpedia.it/euristica_ammissibile&#34;&gt;euristica ammissibile&lt;/a&gt; A* è in grado di identificare la soluzione ottima (e.g. percorso con il minor costo possibile).
Un&amp;rsquo;euristica è ammissibile quando l&amp;rsquo;errore di stima non è mai in eccesso. Un esempio è la distanza in linea d&amp;rsquo;aria tra due punti su una mappa.
In termini matematici una funzione euristica h è ammissibile se:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/ammissibilita.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- \forall x \in V : h(s, x) \leq g(s, x) --&gt;
&lt;/div&gt;
Dove V è l&amp;rsquo;insieme dei nodi, s è il nodo soluzione e la funzione g calcola la distanza esatta tra due nodi.&lt;/p&gt;

&lt;p&gt;La funzione euristica si dice monotòna o consistente se:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/monotonia.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- \forall (x, y) \in E : h(s, x) \leq g(x, y) + h(s, y) --&gt;
&lt;/div&gt;
Dove E è l&amp;rsquo;insieme degli archi, s è il nodo soluzione e la funzione g calcola la distanza esatta tra due nodi.&lt;/p&gt;

&lt;p&gt;Una funzione euristica monotona semplifica ulteriormente la struttura di A* in quanto la lista dei nodi già visitati diviene superflua. In questi casi, la sola coda a priorità è sufficiente.
Una funzione euristica monotona è sempre ammissibile.&lt;/p&gt;

&lt;h1 id=&#34;struttura-dell-algoritmo:2400028604853ea154d2cde8c70195ac&#34;&gt;Struttura dell&amp;rsquo;algoritmo&lt;/h1&gt;

&lt;p&gt;A* rientra nella categoria degli algoritmi di &lt;strong&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Best-first_search&#34;&gt;ricerca best-first&lt;/a&gt;&lt;/strong&gt;. Esso infatti esamina, passo dopo passo, i nodi che hanno il punteggio migliore.
Esso tuttavia non è &lt;em&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_greedy&#34;&gt;greedy&lt;/a&gt;&lt;/em&gt; in quanto il punteggio non è determinato esclusivamente dall&amp;rsquo;euristica.&lt;/p&gt;

&lt;p&gt;A* usa le seguenti strutture dati per mantenere traccia dello stato d&amp;rsquo;esecuzione:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Una lista di nodi già visitati;&lt;/li&gt;
&lt;li&gt;Una &lt;a href=&#34;https://it.wikipedia.org/wiki/Coda_di_priorit%C3%A0&#34;&gt;coda a priorità&lt;/a&gt; contentente i nodi da visitare.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nel corso dell&amp;rsquo;esecuzione, ad ogni nodo vengono associati più valori: &lt;em&gt;gScore, hScore, fScore.&lt;/em&gt;
In termini matematici, dato il nodo corrente n, il nodo di partenza p e il nodo soluzione s, si deifiniscono i valori:
&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/g-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/h-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/f-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;funzione g&lt;/strong&gt; calcola il &lt;strong&gt;costo effettivo&lt;/strong&gt; del percorso che separa i nodi p (partenza) e n (attuale).
La &lt;strong&gt;funzione h&lt;/strong&gt; calcola una &lt;strong&gt;stima&lt;/strong&gt; del costo del percorso tra i nodi s (soluzione) e n (attuale).
La funzione h corrisponde alla definizione dell&amp;rsquo;algoritmo euristico enunciato in precedenza. Essa è infatti chiamata spesso &lt;em&gt;funzione euristica&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La struttura dell&amp;rsquo;algoritmo A* è molto semplice. Esso, ad alto livello, può essere schematizzato in 8 passi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Inserimento nella coda del nodo di partenza con priorità pari al fScore;&lt;/li&gt;
&lt;li&gt;Se la coda è vuota, l&amp;rsquo;algoritmo termina: &lt;em&gt;soluzione non trovata&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Estrazione del miglior nodo da visitare (priorità con valore più basso);&lt;/li&gt;
&lt;li&gt;Se il nodo estratto ha hScore nullo, l&amp;rsquo;algoritmo termina: &lt;em&gt;soluzione trovata&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Costruzione dei nodi figli;&lt;/li&gt;
&lt;li&gt;Eliminazione dei nodi figli già visitati e subottimi;&lt;/li&gt;
&lt;li&gt;Inserimento dei nodi rimanenti nella coda con priorità pari al fScore;&lt;/li&gt;
&lt;li&gt;Tornare al punto 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In pseudo-codice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin function aStar(startNode)
    queue := buildPriorityQueue()
    visited := buildList()
    queue.add(startNode)
    begin while queue.isNotEmpty()
        node := queue.pop()
        begin if hScore(node) equals 0
            return node.getPath()
        end if
        children := node.getChildren()
        toInsert := buildList()
        begin for child in children
            begin if child is visited and visited.fScore &amp;gt; child.fScore
                toInsert.add(child)
            end if
        end for
        queue.add(&amp;lt;every elem in toInsert&amp;gt;)
    end while
    return &#39;No solution found&#39;
end function
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;esempio-d-implementazione:2400028604853ea154d2cde8c70195ac&#34;&gt;Esempio d&amp;rsquo;implementazione&lt;/h1&gt;

&lt;p&gt;Si analizza un&amp;rsquo;implementazione dell&amp;rsquo;algoritmo A* che consente di risolvere il problema del &lt;a href=&#34;https://it.wikipedia.org/wiki/Gioco_del_quindici&#34;&gt;gioco del 15&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Il software è disponibile su GitHub all&amp;rsquo;indirizzo &lt;a href=&#34;https://github.com/taueres/a-star-15-puzzle-solver&#34;&gt;https://github.com/taueres/a-star-15-puzzle-solver&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;La funzione euristica utilizzata è la &lt;a href=&#34;http://it.wikipedia.org/wiki/Geometria_del_taxi&#34;&gt;Distanza di Manhattan&lt;/a&gt;, definita nel modo seguente:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/distanza-di-manhattan.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- man(p, p&#39;) = \sum_{i=1}^{15} |x_i - x&#39;_i| + |y_i - y&#39;_i| --&gt;
&lt;/div&gt;
Essa calcola, per ogni casella, la quantità minima di spostamenti necessari per arrivare dalla posizione p alla posizione p&amp;rsquo;.
È dimostrabile che la Distanza di Manhattan è &lt;em&gt;ammissibile&lt;/em&gt; e &lt;em&gt;monotona&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;implementazione ha diverse componenti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Main.py&lt;/strong&gt;:  Stabilisce la posizione di partenza, avvia l&amp;rsquo;algoritmo e mostra la soluzione;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.py&lt;/strong&gt;:  Struttura dati rappresentante ciascun nodo del grafo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NodeBuilder.py&lt;/strong&gt;:   Costruisce i nodi figli a partire dal nodo in ingresso;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NodePool.py&lt;/strong&gt;:  Coda a priorità con i nodi da visitare. Esso memorizza anche i nodi già visitati con il solo scopo di non inserirli nuovamente nella coda;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ManhattanDistance.py&lt;/strong&gt;: Implementazione dell&amp;rsquo;euristica. Esso determina anche la posizione risolutiva del problema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AStar.py&lt;/strong&gt;: Implementazione dell&amp;rsquo;algoritmo A*.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;L&amp;rsquo;algoritmo mostra in output la lista dei movimenti che la casella vuota deve compiere per risolvere il problema.&lt;/p&gt;

&lt;h1 id=&#34;conclusioni:2400028604853ea154d2cde8c70195ac&#34;&gt;Conclusioni&lt;/h1&gt;

&lt;p&gt;A* è un algoritmo semplice ma dalle grandi potenzialità. Esso getta le basi per ulteriori metodologie di ricerca più complesse come &lt;a href=&#34;https://en.wikipedia.org/wiki/Iterative_deepening_A*&#34;&gt;IDA*&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/D*&#34;&gt;D*&lt;/a&gt;.
La sua principale limitazione è nell&amp;rsquo;assenza di &lt;em&gt;vincoli sulla profondità di ricerca&lt;/em&gt;.
Ciò non consente l&amp;rsquo;analisi di problemi troppo complessi come i giochi di dama e scacchi.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>