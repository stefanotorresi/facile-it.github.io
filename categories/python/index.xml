<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Facile.it Engineering</title>
    <link>/categories/python/</link>
    <description>Recent content in Python on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 12 May 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Intelligenza artificiale: algoritmo A*</title>
      <link>/blog/ita/intelligenza-artificiale-algoritmo-a-star/</link>
      <pubDate>Tue, 12 May 2015 00:00:00 +0000</pubDate>
      
      <guid>/blog/ita/intelligenza-artificiale-algoritmo-a-star/</guid>
      <description>

&lt;h1 id=&#34;introduzione:2400028604853ea154d2cde8c70195ac&#34;&gt;Introduzione&lt;/h1&gt;

&lt;p&gt;A* è un &lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_di_ricerca&#34;&gt;algoritmo di ricerca&lt;/a&gt; e ottimizzazione basato su grafi. Viene frequentemente impiegato nell&amp;rsquo;&lt;a href=&#34;https://it.wikipedia.org/wiki/Intelligenza_artificiale&#34;&gt;intelligenza artificiale&lt;/a&gt; perché in grado di gestire grafi ampi e
indeterminati.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;algoritmo A* può essere utilizzato per risolvere problemi come: &lt;a href=&#34;https://it.wikipedia.org/wiki/Gioco_del_quindici&#34;&gt;gioco del 15&lt;/a&gt;, percorso minimo, &lt;a href=&#34;https://it.wikipedia.org/wiki/Sudoku&#34;&gt;Sudoku&lt;/a&gt;, &lt;a href=&#34;https://it.wikipedia.org/wiki/Cubo_di_Rubik&#34;&gt;cubo di Rubik&lt;/a&gt;, ecc.&lt;/p&gt;

&lt;p&gt;In generale, A* può risolvere efficacemente i problemi che soddisfano i requisiti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La soluzione è determinata da cambamenti sequenziali di stato rappresentabili con grafi;&lt;/li&gt;
&lt;li&gt;Il nodo iniziale e il nodo finale devono essere noti. Talvolta è sufficiente conoscere solo le regole che compongono la soluzione (vedi Sudoku);&lt;/li&gt;
&lt;li&gt;Deve essere noto un &lt;strong&gt;algoritmo euristico&lt;/strong&gt; che &lt;strong&gt;stima&lt;/strong&gt; il costo del percorso tra un nodo qualsiasi e la soluzione.&lt;/li&gt;
&lt;li&gt;Deve essere sempre noto il costo che separa due nodi adiacenti. (Nella maggioranza dei problemi tale valore è sempre unitario).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;l-euristica:2400028604853ea154d2cde8c70195ac&#34;&gt;L&amp;rsquo;euristica&lt;/h1&gt;

&lt;p&gt;L&amp;rsquo;&lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_euristico&#34;&gt;algoritmo euristico&lt;/a&gt; ha il compito di stimare la distanza tra qualsiasi nodo e la soluzione.
L&amp;rsquo;euristica influenza fortemente i risultati conseguiti da A*. Esso, in particolare, ne determina il tempo complessivo di esecuzione.
Un algoritmo euristico molto efficace consente ad A* di trovare velocemente la soluzione.
Nel caso pessimo, una funzione euristica costante, A* diviene un algoritmo di ricerca molto simile a &lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_di_Dijkstra&#34;&gt;Dijkstra&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;euristica determina anche la qualità della soluzione finale.
Con un&amp;rsquo;&lt;a href=&#34;http://www.okpedia.it/euristica_ammissibile&#34;&gt;euristica ammissibile&lt;/a&gt; A* è in grado di identificare la soluzione ottima (e.g. percorso con il minor costo possibile).
Un&amp;rsquo;euristica è ammissibile quando l&amp;rsquo;errore di stima non è mai in eccesso. Un esempio è la distanza in linea d&amp;rsquo;aria tra due punti su una mappa.
In termini matematici una funzione euristica h è ammissibile se:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/ammissibilita.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- \forall x \in V : h(s, x) \leq g(s, x) --&gt;
&lt;/div&gt;
Dove V è l&amp;rsquo;insieme dei nodi, s è il nodo soluzione e la funzione g calcola la distanza esatta tra due nodi.&lt;/p&gt;

&lt;p&gt;La funzione euristica si dice monotòna o consistente se:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/monotonia.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- \forall (x, y) \in E : h(s, x) \leq g(x, y) + h(s, y) --&gt;
&lt;/div&gt;
Dove E è l&amp;rsquo;insieme degli archi, s è il nodo soluzione e la funzione g calcola la distanza esatta tra due nodi.&lt;/p&gt;

&lt;p&gt;Una funzione euristica monotona semplifica ulteriormente la struttura di A* in quanto la lista dei nodi già visitati diviene superflua. In questi casi, la sola coda a priorità è sufficiente.
Una funzione euristica monotona è sempre ammissibile.&lt;/p&gt;

&lt;h1 id=&#34;struttura-dell-algoritmo:2400028604853ea154d2cde8c70195ac&#34;&gt;Struttura dell&amp;rsquo;algoritmo&lt;/h1&gt;

&lt;p&gt;A* rientra nella categoria degli algoritmi di &lt;strong&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Best-first_search&#34;&gt;ricerca best-first&lt;/a&gt;&lt;/strong&gt;. Esso infatti esamina, passo dopo passo, i nodi che hanno il punteggio migliore.
Esso tuttavia non è &lt;em&gt;&lt;a href=&#34;https://it.wikipedia.org/wiki/Algoritmo_greedy&#34;&gt;greedy&lt;/a&gt;&lt;/em&gt; in quanto il punteggio non è determinato esclusivamente dall&amp;rsquo;euristica.&lt;/p&gt;

&lt;p&gt;A* usa le seguenti strutture dati per mantenere traccia dello stato d&amp;rsquo;esecuzione:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Una lista di nodi già visitati;&lt;/li&gt;
&lt;li&gt;Una &lt;a href=&#34;https://it.wikipedia.org/wiki/Coda_di_priorit%C3%A0&#34;&gt;coda a priorità&lt;/a&gt; contentente i nodi da visitare.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nel corso dell&amp;rsquo;esecuzione, ad ogni nodo vengono associati più valori: &lt;em&gt;gScore, hScore, fScore.&lt;/em&gt;
In termini matematici, dato il nodo corrente n, il nodo di partenza p e il nodo soluzione s, si deifiniscono i valori:
&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/g-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align: center;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/h-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/f-score.gif&#34; alt=&#34;&#34; /&gt;
&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;La &lt;strong&gt;funzione g&lt;/strong&gt; calcola il &lt;strong&gt;costo effettivo&lt;/strong&gt; del percorso che separa i nodi p (partenza) e n (attuale).
La &lt;strong&gt;funzione h&lt;/strong&gt; calcola una &lt;strong&gt;stima&lt;/strong&gt; del costo del percorso tra i nodi s (soluzione) e n (attuale).
La funzione h corrisponde alla definizione dell&amp;rsquo;algoritmo euristico enunciato in precedenza. Essa è infatti chiamata spesso &lt;em&gt;funzione euristica&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;La struttura dell&amp;rsquo;algoritmo A* è molto semplice. Esso, ad alto livello, può essere schematizzato in 8 passi:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Inserimento nella coda del nodo di partenza con priorità pari al fScore;&lt;/li&gt;
&lt;li&gt;Se la coda è vuota, l&amp;rsquo;algoritmo termina: &lt;em&gt;soluzione non trovata&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Estrazione del miglior nodo da visitare (priorità con valore più basso);&lt;/li&gt;
&lt;li&gt;Se il nodo estratto ha hScore nullo, l&amp;rsquo;algoritmo termina: &lt;em&gt;soluzione trovata&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;Costruzione dei nodi figli;&lt;/li&gt;
&lt;li&gt;Eliminazione dei nodi figli già visitati e subottimi;&lt;/li&gt;
&lt;li&gt;Inserimento dei nodi rimanenti nella coda con priorità pari al fScore;&lt;/li&gt;
&lt;li&gt;Tornare al punto 2.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;In pseudo-codice:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;begin function aStar(startNode)
    queue := buildPriorityQueue()
    visited := buildList()
    queue.add(startNode)
    begin while queue.isNotEmpty()
        node := queue.pop()
        begin if hScore(node) equals 0
            return node.getPath()
        end if
        children := node.getChildren()
        toInsert := buildList()
        begin for child in children
            begin if child is visited and visited.fScore &amp;gt; child.fScore
                toInsert.add(child)
            end if
        end for
        queue.add(&amp;lt;every elem in toInsert&amp;gt;)
    end while
    return &#39;No solution found&#39;
end function
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;esempio-d-implementazione:2400028604853ea154d2cde8c70195ac&#34;&gt;Esempio d&amp;rsquo;implementazione&lt;/h1&gt;

&lt;p&gt;Si analizza un&amp;rsquo;implementazione dell&amp;rsquo;algoritmo A* che consente di risolvere il problema del &lt;a href=&#34;https://it.wikipedia.org/wiki/Gioco_del_quindici&#34;&gt;gioco del 15&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Il software è disponibile su GitHub all&amp;rsquo;indirizzo &lt;a href=&#34;https://github.com/taueres/a-star-15-puzzle-solver&#34;&gt;https://github.com/taueres/a-star-15-puzzle-solver&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;La funzione euristica utilizzata è la &lt;a href=&#34;http://it.wikipedia.org/wiki/Geometria_del_taxi&#34;&gt;Distanza di Manhattan&lt;/a&gt;, definita nel modo seguente:
&lt;div style=&#34;text-align: center; margin: 0 0 2em 0;&#34;&gt;
    &lt;img src=&#34;/images/intelligenza-artificiale-algoritmo-a-star/distanza-di-manhattan.gif&#34; alt=&#34;&#34; /&gt;
    &lt;!-- man(p, p&#39;) = \sum_{i=1}^{15} |x_i - x&#39;_i| + |y_i - y&#39;_i| --&gt;
&lt;/div&gt;
Essa calcola, per ogni casella, la quantità minima di spostamenti necessari per arrivare dalla posizione p alla posizione p&amp;rsquo;.
È dimostrabile che la Distanza di Manhattan è &lt;em&gt;ammissibile&lt;/em&gt; e &lt;em&gt;monotona&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;L&amp;rsquo;implementazione ha diverse componenti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Main.py&lt;/strong&gt;:  Stabilisce la posizione di partenza, avvia l&amp;rsquo;algoritmo e mostra la soluzione;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Node.py&lt;/strong&gt;:  Struttura dati rappresentante ciascun nodo del grafo;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NodeBuilder.py&lt;/strong&gt;:   Costruisce i nodi figli a partire dal nodo in ingresso;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NodePool.py&lt;/strong&gt;:  Coda a priorità con i nodi da visitare. Esso memorizza anche i nodi già visitati con il solo scopo di non inserirli nuovamente nella coda;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ManhattanDistance.py&lt;/strong&gt;: Implementazione dell&amp;rsquo;euristica. Esso determina anche la posizione risolutiva del problema;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AStar.py&lt;/strong&gt;: Implementazione dell&amp;rsquo;algoritmo A*.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;L&amp;rsquo;algoritmo mostra in output la lista dei movimenti che la casella vuota deve compiere per risolvere il problema.&lt;/p&gt;

&lt;h1 id=&#34;conclusioni:2400028604853ea154d2cde8c70195ac&#34;&gt;Conclusioni&lt;/h1&gt;

&lt;p&gt;A* è un algoritmo semplice ma dalle grandi potenzialità. Esso getta le basi per ulteriori metodologie di ricerca più complesse come &lt;a href=&#34;https://en.wikipedia.org/wiki/Iterative_deepening_A*&#34;&gt;IDA*&lt;/a&gt; e &lt;a href=&#34;https://en.wikipedia.org/wiki/D*&#34;&gt;D*&lt;/a&gt;.
La sua principale limitazione è nell&amp;rsquo;assenza di &lt;em&gt;vincoli sulla profondità di ricerca&lt;/em&gt;.
Ciò non consente l&amp;rsquo;analisi di problemi troppo complessi come i giochi di dama e scacchi.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>