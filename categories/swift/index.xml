<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on Facile.it Engineering</title>
    <link>http://engineering.facile.it/categories/swift/</link>
    <description>Recent content in Swift on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Mar 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://engineering.facile.it/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Decoupling view controllers with Signals</title>
      <link>http://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</link>
      <pubDate>Tue, 15 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/eng/decoupling-view-controllers-with.signals/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/code-reuse-a-primer/&#34;&gt;Last time&lt;/a&gt; we looked at the &lt;strong&gt;Signal&lt;/strong&gt; class, that is, a simple, reusable way of encapsulating the &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;. There are many use cases for a signal, and I&amp;rsquo;m going to show one possible application, spawned from a real-world problem. View controllers&amp;rsquo; composition and decoupling is &lt;strong&gt;hard&lt;/strong&gt;: we often need an input from a view controller, that has to send its input back to its creator, while handling the back navigation somehow. We often find ourselves in a situation in which several different responsibilities are all expressed in a single view controller, with the effect of creating a gigantic class, full of entangled imperative statements, hard-to-understand sequencing and general complexity. We&amp;rsquo;ll use the &lt;code&gt;Signal&lt;/code&gt; class to assign the various responsibilities to different classes, and write cleaner, more declarative code. The core of this architectural pattern lies in inverting the way in which objects communicate, view controller or other: instead of asking objects to do things, we&amp;rsquo;re going to &lt;strong&gt;observe&lt;/strong&gt; what objects are doing, and &lt;strong&gt;react&lt;/strong&gt; accordingly. &lt;em&gt;Observe&lt;/em&gt; and &lt;em&gt;React&lt;/em&gt; are the cornerstones of the programming paradigm known as &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming(FRP)&lt;/a&gt;; the present article is not going to talk about FRP as a whole, nor to present shared FRP techniques; the point is to discuss an architectural pattern for decoupling view controllers from responsibilities not strictly related to user interaction, by leveraging some basic FRP tools.&lt;/p&gt;

&lt;p&gt;The example project for this article is available in &lt;a href=&#34;https://github.com/broomburgo/SignalViewControllers/&#34;&gt;GitHub&lt;/a&gt;: I&amp;rsquo;m going to paste some code examples, but it&amp;rsquo;s recommended to check and test the entire project while reading the article. What follows is the full implementation of &lt;code&gt;Signal&lt;/code&gt;, and its public interface for sending new values, called &lt;code&gt;Emitter&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;import Foundation

public enum Persistence {
  case Stop
  case Continue
}

public final class Signal&amp;lt;Subtype&amp;gt; {
  typealias Observation = Subtype -&amp;gt; Persistence

  private var observations: [Observation] = []

  public init() {}

  public func onReception (observeFunction: Subtype -&amp;gt; Persistence) -&amp;gt; Signal {
    observations.append(observeFunction)
    return self
  }

  public func map&amp;lt;OtherSubtype&amp;gt;(transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt; {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    onReception {
      mappedSignal.send(transform($0))
      return .Continue
    }
    return mappedSignal
  }

  public func flatMap&amp;lt;OtherSubtype&amp;gt;(transform: Subtype -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt; {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    onReception {
      transform($0).onReception {
        mappedSignal.send($0)
        return .Continue
      }
      return .Continue
    }
    return mappedSignal
  }

  public func filter(predicate: Subtype -&amp;gt; Bool) -&amp;gt; Signal {
    let filteredSignal = Signal&amp;lt;Subtype&amp;gt;()
    onReception {
      if predicate($0) {
        filteredSignal.send($0)
      }
      return .Continue
    }
    return filteredSignal
  }

  public func unionWith (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal {
    let unifiedSignal = Signal&amp;lt;Subtype&amp;gt;()
    let observeFunction = { (value: Subtype) -&amp;gt; Persistence in
      unifiedSignal.send(value)
      return .Continue
    }
    onReception(observeFunction)
    otherSignal.onReception(observeFunction)
    return unifiedSignal
  }
}

public func + &amp;lt;Subtype&amp;gt; (left: Signal&amp;lt;Subtype&amp;gt;, right: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal&amp;lt;Subtype&amp;gt; {
  return left.unionWith(right)
}

extension Signal {
  private func send (value: Subtype) {
    var newObservations: [Observation] = []
    while observations.count &amp;gt; 0 {
      let observe = observations.removeFirst()
      let persistence = observe(value)
      switch persistence {
      case .Continue:
        newObservations.append(observe)
      case .Stop: break
      }
    }
    observations = newObservations
  }
}

public final class Emitter&amp;lt;Subtype&amp;gt; {
  public let signal = Signal&amp;lt;Subtype&amp;gt;()

  public func emit(value: Subtype) {
    signal.send(value)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;the-megacontroller:98c10da2faa40144e7de0ba94dc701c4&#34;&gt;The megacontroller&lt;/h2&gt;

&lt;p&gt;Suppose we need to create a simple app to leave a feedback for a movie we just watched; the feedback will be divided in two categories:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;average&lt;/em&gt;: the movie was &lt;em&gt;good&lt;/em&gt;, &lt;em&gt;bad&lt;/em&gt; or &lt;em&gt;so and so&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;polarized&lt;/em&gt;: the movie was &lt;em&gt;very bad&lt;/em&gt; or &lt;em&gt;really good&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The app is going to present a page in which the user can select an &lt;em&gt;average&lt;/em&gt; or a &lt;em&gt;polarized&lt;/em&gt; feedback, and can tap a button that will present the user the available choices, i.e., respectively &lt;em&gt;good&lt;/em&gt;, &lt;em&gt;son and so&lt;/em&gt;, &lt;em&gt;bad&lt;/em&gt;, or &lt;em&gt;really&lt;/em&gt; and &lt;em&gt;very bad&lt;/em&gt;. The app is also going to thank the user if they&amp;rsquo;ve just left a positive feedback, but only if the previously left feedback was of lower value. The example is a little contrived but instructive, as we&amp;rsquo;re going to see. An &lt;strong&gt;easy, familiar approach&lt;/strong&gt; to the problem would be to start with the design of the two view controllers involved:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;MainPage&lt;/code&gt; will let the user select if the feedback is average or polarized, and will present a button to show the page where the actual feedback value will be selected; the &lt;code&gt;MainPage&lt;/code&gt; will also show the currently selected feedback (or none) in a label;&lt;/li&gt;
&lt;li&gt;the &lt;code&gt;SelectionPage&lt;/code&gt; is going to present several buttons with the various feedback values (different based on the feedback category), and at the tap of a button the page should actually pop from the navigation stack, going back to the now-updated &lt;code&gt;MainPage&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Armed with our &lt;strong&gt;imperative mind&lt;/strong&gt; we would probably start by adding a sequence of instructions to the &lt;code&gt;MainPage&lt;/code&gt;, that we&amp;rsquo;ll probably perceive as the &amp;ldquo;main&amp;rdquo; controller of our app. But soon, we would probably notice that a lot of &lt;strong&gt;clearly separated&lt;/strong&gt; responsibilities are being collected in the &lt;code&gt;MainPage&lt;/code&gt; class:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the &lt;code&gt;SelectionPage&lt;/code&gt; has to be constructed and initialized, and by doing this in &lt;code&gt;MainPage&lt;/code&gt; we are imposing a strict &lt;strong&gt;dependency&lt;/strong&gt; between the two classes;&lt;/li&gt;
&lt;li&gt;after its initialization, the &lt;code&gt;SelectionPage&lt;/code&gt; must be presented to the user: we would probably embed &lt;code&gt;MainPage&lt;/code&gt; in a &lt;code&gt;UINavigationController&lt;/code&gt;, then push the &lt;code&gt;SelectionPage&lt;/code&gt; from the &lt;code&gt;MainPage&lt;/code&gt;, resulting in a strict coupling of the two classes with a particular navigation and presentation strategy (i.e., using a &lt;code&gt;UINavigationController&lt;/code&gt;) that is going to cause headaches if the use cases change (for example, in developing the &lt;strong&gt;iPad version&lt;/strong&gt; of the app);&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s a feedback value &lt;strong&gt;stored somewhere&lt;/strong&gt;, because we need to know if the user selected &lt;code&gt;average&lt;/code&gt; or &lt;code&gt;polarized&lt;/code&gt;, and actually which was the selected feedback, because its value will be shown on the main page; the simplest solution seems to be just storing the selected feedback value in the &lt;code&gt;MainPage&lt;/code&gt; class;&lt;/li&gt;
&lt;li&gt;the act of &amp;ldquo;collecting the feedback&amp;rdquo; is a responsibility in itself, because the collected value is probably going to be used somewhere (for example, posting it to a web service);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We basically identified 4 different responsibilities, each of which is probably going to need its own class, but instead of thinking about the methods that need to be called on each one of them, we&amp;rsquo;re going to try and think with signals.&lt;/p&gt;

&lt;h2 id=&#34;the-model:98c10da2faa40144e7de0ba94dc701c4&#34;&gt;The model&lt;/h2&gt;

&lt;p&gt;For example, if the model changes we need to update the text shown on the &lt;code&gt;MainPage&lt;/code&gt;: a possible way to manage this could be to create a &lt;code&gt;ModelController&lt;/code&gt; class, which holds the model, and &lt;em&gt;emits a signal&lt;/em&gt; each time the model changes. Then, the &lt;code&gt;MainPage&lt;/code&gt; could &lt;em&gt;react&lt;/em&gt; to this signal, and change the UI accordingly. A nice to way to do this is injecting the &lt;code&gt;ModelController&lt;/code&gt; in the &lt;code&gt;MainPage&lt;/code&gt; constructor, so that &lt;code&gt;MainPage&lt;/code&gt; can establish the appropriate bindings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;/// MainPage initializer
init(feedbackModelController: ModelController&amp;lt;FeedbackModel&amp;gt;) {
  super.init(nibName: nil, bundle: nil)
  feedbackModelController.updateSignal.onReception § eachTime § updateViewsWithFeedbackModel
  viewReadyEmitter.signal.onReception § eachTime § feedbackModelController.notify
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;§&lt;/code&gt; operator and the &lt;code&gt;eachTime&lt;/code&gt; function are just helpers to make the &lt;strong&gt;functional composition&lt;/strong&gt; easier: as it often happens with functional programming, or declarative programming in general, we can infer the meaning of an expression just by reading it; in fact, &lt;code&gt;onReception § eachTime § updateViewsWithFeedbackModel&lt;/code&gt; means that when the signal is received, the &lt;code&gt;MainPage&lt;/code&gt; will update the view every time according to the new &lt;code&gt;FeedbackModel&lt;/code&gt;: &lt;code&gt;eachTime&lt;/code&gt; means that every time the signal triggers, so will the update; this is in contrast with the &lt;code&gt;once&lt;/code&gt; function, that makes the object listen only to the first signal trigger. This is  related to the &lt;code&gt;Persistence&lt;/code&gt; of a &lt;code&gt;Signal&lt;/code&gt; observation, that is, if the object should continue listen to a signal or not: &lt;code&gt;Persistence&lt;/code&gt; is a single &lt;code&gt;enum&lt;/code&gt; with two values, &lt;code&gt;Continue&lt;/code&gt; and &lt;code&gt;Stop&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;An important characteristic of the view controllers is the fact that the views are not yet initialized in the constructor, so we often need to memorize some data and use it in the &lt;code&gt;viewDidLoad&lt;/code&gt; method, that is called by the framework when all the views are loaded, and can consequently be manipulated; but we used a signal to express the update logic directly in the constructor, where the &lt;code&gt;ModelController&lt;/code&gt; is available: the line &lt;code&gt;viewReadyEmitter.signal.onReception § eachTime § feedbackModelController.notify&lt;/code&gt; means that when the &lt;code&gt;viewReadyEmitter&lt;/code&gt;, i.e., the emitter that will send a signal when the view is ready, is triggering, the model controller has to &lt;em&gt;notify&lt;/em&gt; its current value to all the observers; this way we don&amp;rsquo;t need to manually update the views in the &lt;code&gt;viewDidLoad&lt;/code&gt; method: everything is connected, and the signals will &lt;strong&gt;propagate&lt;/strong&gt; according to the declarative bindings.&lt;/p&gt;

&lt;h2 id=&#34;handling-page-creation-and-presentation:98c10da2faa40144e7de0ba94dc701c4&#34;&gt;Handling page creation and presentation&lt;/h2&gt;

&lt;p&gt;Transitioning between pages is one the key points in iOS programming: page presentation has to be &lt;strong&gt;predictable and smooth&lt;/strong&gt;, to avoid a confusing user experience. One of the main premises of the &lt;code&gt;UIViewController&lt;/code&gt; class was and still is the creation of a modular hierarchy of views, that&amp;rsquo;s independent from the way it&amp;rsquo;s presented to the user: that way we can easily reuse &lt;strong&gt;the same&lt;/strong&gt; view controller, for example, in full screen on the iPhone, or as a child view controller on a more complex hierarchy on iPad. The problem is that, if we write down the navigation and presentation logic &lt;em&gt;inside&lt;/em&gt; the view controller class, we are going to establish tight dependencies between the view controller and its presentation, thus going against the premise.&lt;/p&gt;

&lt;p&gt;A possible solution would be to use a &lt;code&gt;NavigationHandler&lt;/code&gt;, that will handle the transition between pages, along with the initial presentation during the application startup. The strategy here is to use a class that knows &lt;strong&gt;when and how&lt;/strong&gt; to present pages, oblivious of what pages actually do. For example, on receiving the appropriate signal from &lt;code&gt;MainPage&lt;/code&gt;, the &lt;code&gt;NavigationHandler&lt;/code&gt; will present the &lt;code&gt;SelectionPage&lt;/code&gt;. Where the &lt;code&gt;SelectionPage&lt;/code&gt; comes from? We should certainly avoid to burden the &lt;code&gt;NavigationHandler&lt;/code&gt; with pages&amp;rsquo; initialization responsibilities,  in fact we identified the class creation as a responsibility in itself. A frequent pattern used to handle the initialization of objects is the &lt;a href=&#34;http://www.oodesign.com/factory-pattern.html&#34;&gt;Factory Pattern&lt;/a&gt;: a &lt;code&gt;PageFactory&lt;/code&gt; will construct our pages with the options passed to the factory constructor. Thus, &lt;code&gt;NavigationHandler&lt;/code&gt; will ask the &lt;code&gt;PageFactory&lt;/code&gt; for pages, through the methods &lt;code&gt;makeMainPage&lt;/code&gt; and &lt;code&gt;makeSelectionPage&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But we incur in a problem: &lt;code&gt;makeSelectionPage&lt;/code&gt; will just return a &lt;code&gt;SelectionPage&lt;/code&gt; object, but we don&amp;rsquo;t know if it&amp;rsquo;s &lt;em&gt;always&lt;/em&gt; the same instance, or a new instance each time. In fact, &lt;code&gt;PageFactory&lt;/code&gt; doesn&amp;rsquo;t &lt;em&gt;promise&lt;/em&gt; always the same page. This is important because the &lt;code&gt;NavigationHandler&lt;/code&gt; will only take care of page presentation, but the very same page instance has to be considered, for example, for collecting the feedback. A possible strategy would be to &lt;em&gt;cache&lt;/em&gt; the &lt;code&gt;SelectionPage&lt;/code&gt;, but one of the main points of functional programming is &lt;strong&gt;avoiding state&lt;/strong&gt;: we don&amp;rsquo;t want to burden ourselves with the responsibility of managing mutable state, which is one of the &lt;a href=&#34;http://shaffner.us/cs/papers/tarpit.pdf&#34;&gt;main causes of complexity&lt;/a&gt; in software development. Instead, we will once again leverage signals to handle the situation. &lt;code&gt;PageFactory&lt;/code&gt; exposes two signals that are triggered at page creation; &lt;code&gt;NavigationHandler&lt;/code&gt;  uses those signal to bind its actions to the initialized pages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;pageFactory.signalMakeMainPage
  .flatMap { $0.signalLeaveFeedback }
  .onReception § eachTime § inAnyCase § presentSelectionPage
  
pageFactory.signalMakeSelectionPage
  .flatMap { $0.signalSelection }
  .onReception § eachTime § inAnyCase § popTopPage
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the code just shown, the signals that are triggered when the pages are initialized are &lt;em&gt;flatMapped&lt;/em&gt; to the respective interaction signals, that is, the observed signal is a signal that will trigger when the second signal is triggered, but the &lt;em&gt;second&lt;/em&gt; signal will be available only when the &lt;em&gt;first&lt;/em&gt; signal is triggered: the &lt;code&gt;flatMap&lt;/code&gt; method will let us reference a signal that is not yet available. The &lt;code&gt;inAnyCase&lt;/code&gt; function is used because &lt;code&gt;NavigationHandler&lt;/code&gt; is not interested in the &lt;em&gt;content&lt;/em&gt; of the signals, but just the fact that they are triggered; the content is going to be handled by another class: &lt;code&gt;FeedbackCollector&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;composing-signals:98c10da2faa40144e7de0ba94dc701c4&#34;&gt;Composing signals&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;FeedbackCollector&lt;/code&gt; has the responsibility of &lt;em&gt;collecting the whole feedback&lt;/em&gt;: this seems tricky, because the creation of a new feedback is not a synchronous procedure, and it&amp;rsquo;s the result of &lt;strong&gt;many different interactions&lt;/strong&gt; from the user in different contexts. As we saw, a signal is an abstraction over asynchronous programming: we declare the signal bindings for actions that will trigger at a certain point in time. Thanks to signals we can express the logic for collecting feedback in a single function call, executed during the app startup phase, even if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;at the app startup the pages are not yet initialized;&lt;/li&gt;
&lt;li&gt;to actually collect the feedback various interactions in multiple pages will be needed;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usually these consideration would lead to &lt;strong&gt;stateful&lt;/strong&gt; computations, where state would be expressed in various points, and mutated. But the class &lt;code&gt;FeedbackCollector&lt;/code&gt; can generate a signal triggered each time a new feedback is collected with a single expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func collectFeedbackModelChange() -&amp;gt; Signal&amp;lt;FeedbackModelChange&amp;gt; {
  return pageFactory.signalMakeMainPage
    .flatMap { $0.signalPolarizedChanged }
    .map(FeedbackModel.transformWithPolarized)
    + pageFactory.signalMakeSelectionPage
      .flatMap { $0.signalSelection }
      .map(FeedbackModel.transformWithFeedback)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;+&lt;/code&gt; operator will literally &lt;em&gt;add&lt;/em&gt; 2 signals together, producing a signal that is triggered each time either of the signals is triggered. The app uses the &lt;code&gt;Signal&amp;lt;FeedbackModelChange&amp;gt;&lt;/code&gt; produced by the &lt;code&gt;collectFeedbackModelChange()&lt;/code&gt; to update the model in the &lt;code&gt;ModelController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another example of asynchronous reaction to signals is shown in the &lt;code&gt;AppDelegate&lt;/code&gt;&amp;rsquo;s method &lt;code&gt;handleGoodFeedbacksWithAlert()&lt;/code&gt;; here&amp;rsquo;s the logic: if the user leaves a positive feedback, that is better than the previously left feedback, the app will show an alert, thanking the user. The entire logic for this is handled in the following expression:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;feedbackModelController.deltaSignal
  .filter { $0.feedback.rawValue &amp;lt; $1.feedback.rawValue}
  .filter { $1.feedback == .Good || $1.feedback == .ReallyGood }
  .onReception § eachTime § inAnyCase § showThankYouAlert
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ModelController&lt;/code&gt;&amp;rsquo;s &lt;code&gt;deltaSignal&lt;/code&gt; is triggered each time the model changes, and contains both the old and the new value: in the shown expression a signal is created by &lt;em&gt;filtering&lt;/em&gt; the &lt;code&gt;deltaSignal&lt;/code&gt;, because we need a signal that is triggered only when the new feedback is different from the previous and positive.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:98c10da2faa40144e7de0ba94dc701c4&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;A clean and decoupled architecture is hard to get right, and can be obtained in different ways. Using signals will help us achieve the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;we can work on &lt;strong&gt;a single piece at a time&lt;/strong&gt;, thinking about what &lt;em&gt;values&lt;/em&gt; are exchanged between classes, instead of interfaces and abstractions;&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ll be able to focus on what a view controller, or any class, really has to &lt;em&gt;produce&lt;/em&gt;, that is, what value is going to yield in the economy of the app;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Signals are not application-wide events: we don&amp;rsquo;t need a router or a dispatcher (like   &lt;code&gt;NSNotificationCenter&lt;/code&gt;) to properly handle them, because each object will declare its observation of specific signals. Also, because signals are easily transformed and composed, we can declaratively express our bindings without worrying about &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; things are going to happen, but just &lt;em&gt;what&lt;/em&gt; we need. Of course our architecture has to take into account the fact that getting a &lt;em&gt;precise sequence of events&lt;/em&gt; is basically impossible when working with signals: actually, &lt;em&gt;sequencing&lt;/em&gt; is not even considered in declarative programming, because, along with &lt;em&gt;state&lt;/em&gt;, is a great cause of complexity. In the end, a declarative architecture, like everything, has its tradeoffs, but I still think it&amp;rsquo;s worth trying.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Code reuse: a primer</title>
      <link>http://engineering.facile.it/blog/eng/code-reuse-a-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/eng/code-reuse-a-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c/&#34;&gt;Last time&lt;/a&gt; we looked at a possible implementation for the &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; type in Objective-C; while the main point was to port to Objective-C a tool that&amp;rsquo;s frequently used in Swift, making use of the &lt;code&gt;Optional&lt;/code&gt; class can be considered an application of a much more general concept: &lt;strong&gt;code reuse&lt;/strong&gt;. In fact, &lt;code&gt;Optional&lt;/code&gt; is not tied to a particular domain, and can be reused over and over again in multiple projects: that&amp;rsquo;s what actually happens in Swift. But, to think about it, that&amp;rsquo;s what happens for a wide range of &lt;em&gt;classes&lt;/em&gt; in Objective-C, or &lt;em&gt;types&lt;/em&gt; in Swift: for example, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are both constructs that expose a certain interface, have a certain implementation, and are reused multiple times within methods and functions. And again, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are not tied to a particular domain, and have two important properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they are &lt;strong&gt;generic&lt;/strong&gt;, that is, they are not dependent on a particular subtype: an array of numbers and an array of strings will work in the exact same way when it comes to behavior that&amp;rsquo;s strictly associated to arrays, like counting elements, removing or adding an element, mapping, filtering, reducing et cetera;&lt;/li&gt;
&lt;li&gt;they are &lt;strong&gt;composable&lt;/strong&gt;, that is, they can be stacked on top of each other, and assembled with other more specific things, while keeping the same &lt;strong&gt;predictable behavior&lt;/strong&gt;: an array of &lt;em&gt;customers&lt;/em&gt;, each with their own array of &lt;em&gt;purchased products&lt;/em&gt;, can be mapped to an array of arrays of &lt;em&gt;products&lt;/em&gt;, that can be flattened into an array of &lt;em&gt;products&lt;/em&gt;, that can be reduced into a number representing the total cost;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, like &lt;code&gt;Optional&lt;/code&gt;, is a nice example of perfectly reusable code, but there are many more constructs that satisfy the aforementioned rules: &lt;em&gt;genericity&lt;/em&gt; and &lt;em&gt;composability&lt;/em&gt;. What doesn&amp;rsquo;t satisfy the rules is domain-specific objects, even when it seems like an object is sufficiently generic to be reused. A &lt;code&gt;Customer&lt;/code&gt; class, for example, could seem a good candidate, but trying to reuse the same class in two different projects will result in &lt;strong&gt;bad news&lt;/strong&gt; and headaches: either we&amp;rsquo;ll need to &lt;strong&gt;specialize&lt;/strong&gt; the class for each project, making the two diverge, or we&amp;rsquo;ll need to add levels of &lt;strong&gt;indirection&lt;/strong&gt;, because we&amp;rsquo;re forcing an object into a project it doesn&amp;rsquo;t belong to.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another thing to consider: if we really want to reuse code, we&amp;rsquo;ll also need to make &lt;strong&gt;design choices&lt;/strong&gt; that allow that code to be reused. I could actually forget about the &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt; types, and create classes that never expose their underlying components; for example, I could create a class that represents a collection of optional objects, without ever exposing in the interface the fact that I&amp;rsquo;m using &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt; for its implementation: it would result in some serious &lt;strong&gt;contortion&lt;/strong&gt; of methods&amp;rsquo; signature, but it&amp;rsquo;s possible. Also, is it a good idea? &lt;strong&gt;I don&amp;rsquo;t think so&lt;/strong&gt;. Creating a specific, incomposable class for every possible need will result in thousands of lines of what&amp;rsquo;s essentially &lt;strong&gt;boilerplate&lt;/strong&gt; code, complicated interfaces, and ridiculously long class names. If we aspire to code reuse, other than the two rules we just defined, we also need to pay attention to the way we architect our apps, and the main design principle to follow here is one of &lt;strong&gt;composition&lt;/strong&gt;, that can be summed up with the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Domain-specific constructs and behaviors should be realized by composing atomic and generic building blocks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This basically means that, instead of creating every time a specific implementation for our needs, we should try and satisfy that need by composing reusable, atomic objects. This looks complex, and at this point we should ask ourselves if code reuse is really something we want to pursue. My answer is a definitive &lt;strong&gt;yes&lt;/strong&gt;, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;with reusable components we can &lt;strong&gt;encapsulate&lt;/strong&gt; a particular behavior, and avoid rewriting essentially the same thing over and over again;&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ll have a &lt;strong&gt;guideline&lt;/strong&gt; for designing the architecture of our app, because we wont&amp;rsquo;t need to constantly define new interfaces for the same behaviors;&lt;/li&gt;
&lt;li&gt;a reusable component is very easy to &lt;strong&gt;test&lt;/strong&gt;, because it&amp;rsquo;s small and atomic, so by using it we will be more confident about the correctness of our code;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That, again, is what happens when we use types like &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt;. As I said, there are many more of these building blocks, and actually the definition of their interfaces is a problem in itself, and has no obvious solution, but I think it&amp;rsquo;s a very interesting problem to tackle. By following the &lt;em&gt;generic&lt;/em&gt; and &lt;em&gt;composable&lt;/em&gt; rules we already have a guideline for designing them, but if we want to create our owns we should probably add one more rule:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a reusable object has to be &lt;strong&gt;simple&lt;/strong&gt;, that is, it should have a unique, linear, easily describable responsibility;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; follows this rule: it&amp;rsquo;s a generic container that represents an object that could be there, or not. &lt;code&gt;Array&lt;/code&gt; follows this rule: it represents and &lt;em&gt;ordered&lt;/em&gt; collection of objects, each one them accessible in constant time. Let&amp;rsquo;s try to apply the rule and create a new reusable object.&lt;/p&gt;

&lt;p&gt;Consider this real, kind of frequent use case: different objects must be notified when a certain object changes state or does something. A way to solve the problem is represented by the &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;, that is, make our objects implement an interface that exposes a &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish–subscribe_pattern&#34;&gt;publish-subscribe&lt;/a&gt; behavior. The point is, implementing an interface &lt;strong&gt;is not reusable&lt;/strong&gt;: each time we want to use this pattern we are going to &lt;strong&gt;rewrite&lt;/strong&gt; very similar code; instead, we want to encapsulate the behavior in a generic object, and reuse that object instead. What follows is a possible implementation, the one that I use in production, but there are many more: actually, &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming&lt;/a&gt; has spawned from this very problem, that is, finding a generic, composable way of representing and manipulating observable streams, but in this case we&amp;rsquo;re going to create a much simpler &lt;strong&gt;Signal&lt;/strong&gt; object.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Signal&lt;/code&gt; class we want to implement is going to represent an &lt;em&gt;update&lt;/em&gt; for a certain object: that update can be everything, like a new value for a property, or an action that was taken. We&amp;rsquo;ll use the Swift language, which is also going to give us a lot of &lt;strong&gt;type-safety&lt;/strong&gt; for free. Here&amp;rsquo;s a summary of what we want for the &lt;code&gt;Signal&lt;/code&gt; class:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it has to a have a &lt;strong&gt;parametric&lt;/strong&gt; subtype, that is, the type of the value that will be signaled in each update;&lt;/li&gt;
&lt;li&gt;it has to have an &lt;code&gt;observe&lt;/code&gt; method, that takes a closure representing an action that has to be taken every time an update is given;&lt;/li&gt;
&lt;li&gt;it has to have a &lt;code&gt;send&lt;/code&gt; method, which takes a new value of the underlying subtype;&lt;/li&gt;
&lt;li&gt;it has to have some simple methods for composition, that follow the usual naming conventions, like &lt;code&gt;map&lt;/code&gt;, for generating a new &lt;code&gt;Signal&lt;/code&gt; from an existing one by transforming the observed value, and &lt;code&gt;forwardTo&lt;/code&gt; to make another &lt;code&gt;Signal&lt;/code&gt; &lt;em&gt;trigger&lt;/em&gt; when a certain &lt;code&gt;Signal&lt;/code&gt; is producing a new value;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Semantically, we can describe a &lt;code&gt;Signal&lt;/code&gt; as a container for a value that&amp;rsquo;s going to be there at a certain point in time, and it&amp;rsquo;s going to update itself indefinitely.&lt;/p&gt;

&lt;p&gt;What follows is the entire implementation of the &lt;code&gt;Signal&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum SignalContinuation
{
  case Continue
  case Stop
}

public class Signal&amp;lt;Subtype&amp;gt;
{
  private var observers: [(Subtype -&amp;gt; SignalContinuation)] = []

  public init() {}

  public func observe (observeFunction: Subtype -&amp;gt; SignalContinuation)
  {
    observers.append(observeFunction)
  }

  public func send (value: Subtype)
  {
    var continuations: [(Subtype -&amp;gt; SignalContinuation)] = []
    while observers.count &amp;gt; 0
    {
      let observer = observers.removeFirst()
      let continuation = observer(value)
      switch continuation
      {
      case .Continue:
        continuations.append(observer)
      case .Stop: break
      }
    }
    observers = continuations
  }

  public func forwardTo (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(action)
      return .Continue
    }
    return self
  }

  public func forwardTo &amp;lt;OtherSubtype&amp;gt; (
    otherSignal: Signal&amp;lt;OtherSubtype&amp;gt;,
    mappingFunction: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(mappingFunction(action))
      return .Continue
    }
    return self
  }

  public func map &amp;lt;OtherSubtype&amp;gt; (transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;
  {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    forwardTo(mappedSignal, mappingFunction: transform)
    return mappedSignal
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is really simple, but still, really powerful. A problem that&amp;rsquo;s frequently found when implementing the observer pattern is how to manage unsubscriptions; it&amp;rsquo;s a responsibility of the observer object to stop observing something, and in this &lt;code&gt;Signal&lt;/code&gt; implementation this is easily managed within the closure passed to the &lt;code&gt;observe&lt;/code&gt; method: the closure must return a &lt;code&gt;SignalContinuation&lt;/code&gt; value, that can be simply &lt;code&gt;.Continue&lt;/code&gt; (that is, keep observing updates) or &lt;code&gt;.Stop&lt;/code&gt;. Another problem is memory management: we need to make sure that when an observer&amp;rsquo;s memory is released, it will also stop observing, or a message will be sent to a dangling pointer, resulting in the app crashing. Swift&amp;rsquo;s &lt;code&gt;weak&lt;/code&gt; memory semantics actually makes this really easy to do: we&amp;rsquo;ll put a &lt;code&gt;guard&lt;/code&gt; clause at the beginning of the closure passed to the &lt;code&gt;observe&lt;/code&gt; method; if the object has become &lt;code&gt;nil&lt;/code&gt;, we&amp;rsquo;ll simply return &lt;code&gt;.Stop&lt;/code&gt;. The following example shows a simple use of the &lt;code&gt;Signal&lt;/code&gt; class, including the &lt;em&gt;stop-observing-on-nil&lt;/em&gt; mechanism:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Sender
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func sendNew(value: Int)
  {
    signal.send(value)
  }
}

class Receiver&amp;lt;Type: CustomStringConvertible&amp;gt;
{
  func startObserving(signal: Signal&amp;lt;Type&amp;gt;)
  {
    signal.observe { [weak self] value in
      guard let this = self else { return .Stop }
      this.printNewValue(value)
      return .Continue
    }
  }

  func printNewValue(value: Type)
  {
    print(value)
  }
}

let sender = Sender()
let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(sender.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 3, 5, 10, 20 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example we can see an application of the concepts we talked about at the beginning of this article: instead of creating yet another interface for the same behavior, we are directly using and reusing the &lt;code&gt;Signal&lt;/code&gt; object. A more complex example would be the addition of something like a &lt;em&gt;resonator&lt;/em&gt;, that is, an object with a &lt;code&gt;Signal&lt;/code&gt; that resonates with another, like in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DoublingResonator
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func resonateWith(otherSignal: Signal&amp;lt;Int&amp;gt;)
  {
    otherSignal.forwardTo(signal) { $0*2 }
  }
}

let resonator = DoublingResonator()
resonator.resonateWith(sender.signal)

let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(resonator.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 6, 10, 20, 40 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many other options for composition of signals, but as long as we don&amp;rsquo;t need them, it&amp;rsquo;s better to keep the class &lt;strong&gt;simple&lt;/strong&gt;: then, gradually over time, we can start adding features to the class, and as long as they&amp;rsquo;re properly generic and tested, we will be able to use them in all of our projects.&lt;/p&gt;

&lt;p&gt;To conclude, finding the right abstractions for reusability is of course a problem, and the solution is not an easy one: plenty of academic papers address the problem in several ways (classic Charles W. Krueger&amp;rsquo;s paper &lt;a href=&#34;http://www.biglever.com/papers/Krueger_AcmReuseSurvey.pdf&#34;&gt;Software Reuse&lt;/a&gt; contains a good overview of the used techniques), and the reason why &lt;a href=&#34;https://en.wikipedia.org/wiki/Category_theory&#34;&gt;category theory&lt;/a&gt; has many applications in functional programming is because it offers an excellent set of abstractions for tackling several classes of problems. But still, I think the advantages of code reuse are many, and that achieving a compositional design through atomic, reusable components is &lt;strong&gt;a worthy goal&lt;/strong&gt; to pursue.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codice riusabile: un primer</title>
      <link>http://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/codice-riusabile-un-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c-ita/&#34;&gt;L&amp;rsquo;ultima volta&lt;/a&gt; abbiamo visto una possibile implementazione del tipo &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; in Objective-C; l&amp;rsquo;obiettivo primario dell&amp;rsquo;articolo era quello di importare in Objective-C uno strumento frequentemente utilizzato in Swift, ma usare una classe come &lt;code&gt;Optional&lt;/code&gt; può essere considerato un&amp;rsquo;applicazione di un concetto molto più generale: il &lt;strong&gt;riutilizzo del codice&lt;/strong&gt;. In effetti, &lt;code&gt;Optional&lt;/code&gt; non è legato a un particolare dominio, e può essere riutilizzato più e più volte in molti progetti: questo è esattamente ciò che accade in Swift. Ma a pensarci bene, questo è ciò che accade per una grande varietà di &lt;em&gt;classi&lt;/em&gt; in Objective-C (e di &lt;em&gt;tipi&lt;/em&gt; in Swift): ad esempio, &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; sono entrambi costrutti che espongono una specifica interfaccia, possiedono una certa implementazione, e vengono riutilizzati continuamente in metodi e funzioni. &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; non sono legati a un particolare dominio, e possiedono due importanti caratteristiche:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sono &lt;strong&gt;generici&lt;/strong&gt;, quindi non sono legati a un particolare sottotipo: un array di numeri e un array di stringhe funzioneranno esattamente allo stesso modo per quanto riguarda le funzioni strettamente associate agli array, come il conteggio degli elementi, rimuovere o aggiungere un elemento, mappare, filtrare, ridurre e così via;&lt;/li&gt;
&lt;li&gt;sono &lt;strong&gt;componibili&lt;/strong&gt;, quindi possono essere combinati tra loro e con altri oggetti più specifici, mantenendo comunque lo stesso &lt;strong&gt;comportamento predicibile&lt;/strong&gt;: un array di &lt;em&gt;clienti&lt;/em&gt;, ciascuno con il suo array &lt;em&gt;prodotti acquistati&lt;/em&gt;, può essere mappato in un array di array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere appiattito in un array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere ridotto a un numero che rappresenta il costo totale;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, come &lt;code&gt;Optional&lt;/code&gt;, è un ottimo esempio di codice perfettamente riutilizzabile, ma ci sono molti altri costrutti che soddisfano le regole di cui sopra, cioè &lt;em&gt;genericità&lt;/em&gt; e &lt;em&gt;componibilità&lt;/em&gt;. Gli oggetti specifici di dominio, invece, tipicamente non soddisfano queste regole, anche quando un oggetto sembra essere sufficientemente generico da poter essere riutilizzato. Una classe &lt;code&gt;Cliente&lt;/code&gt;, ad esempio, potrebbe sembrare un buon candidato, ma cercare di usare la stessa classe in due diversi progetti si rivelerebbe &lt;strong&gt;una pessima idea&lt;/strong&gt;: probabilmente saremo costretti a &lt;strong&gt;specializzare&lt;/strong&gt; la classe per ciascun progetto, portando a divergenza tra le implementazioni, o usare diversi livelli di &lt;strong&gt;indirezione&lt;/strong&gt;, perché stiamo inserendo a forza un oggetto in un dominio che non gli appartiene.&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;è un&amp;rsquo;altra cosa da considerare: se davvero vogliamo riutilizzare del codice, dovremo anche stare attenti alle nostre &lt;strong&gt;scelte di design&lt;/strong&gt;, perché non tutti i design permettono l&amp;rsquo;utilizzo di codice generico. Potrei dimenticarmi dell&amp;rsquo;esistenza dei tipi &lt;code&gt;Optional&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt;, e creare classi che non espongono mai i loro componenti di base; ad esempio, potrei creare una classe che rappresenta una collezione di oggetti opzionali, senza mai esporre nell&amp;rsquo;interfaccia il fatto che sto utilizzando &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt; nell&amp;rsquo;implementazione: ne risulterebbe una certa &lt;strong&gt;complicazione&lt;/strong&gt; della firma dei metodi, ma è possibile. Ma, a pensarci bene, è una buona idea? &lt;strong&gt;Ne dubito&lt;/strong&gt;. Creare una nuova e specifica classe, non componibile, per ogni possibile necessità produrrà migliaia di linee di codice &lt;strong&gt;boilerplate&lt;/strong&gt;, interfacce complicate, e nomi di classi assurdamente lunghi. Se vogliamo scrivere codice riutilizzabile, oltre a seguire le due regole già viste, dobbiamo anche prestare attenzione al modo in cui architettiamo le nostre app, e il principio di design da seguire in questo caso è il principio di &lt;strong&gt;composizione&lt;/strong&gt;, che può essere sintetizzato con la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Costrutti e comportamenti specifici del dominio dovrebbero essere realizzati componendo blocchi costruttivi atomici e generici.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ciò significa sostanzialmente che, invece di creare di volta in volta una specifica implementazione per ovviare alle nostre necessità, dovremmo costruire le nuove funzionalità aggregando oggetti atomici già definiti. Sembra un&amp;rsquo;idea complessa, e forse dovremmo fermarci un attimo e chiederci se scrivere codice riutilizzabile sia davvero una buona idea. La mia risposta è un definitivo &lt;strong&gt;si&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scrivendo componenti riutilizzabili possiamo &lt;strong&gt;incapsulare&lt;/strong&gt; uno specifico comportamento, evitando di dover riscrivere di continuo sostanzialmente lo stesso codice;&lt;/li&gt;
&lt;li&gt;potremmo disporre di &lt;strong&gt;linee guida&lt;/strong&gt; per progettare l&amp;rsquo;architettura delle nostre app, perché non avremmo bisogno di definire sempre nuove interfacce per rappresentare gli stessi comportamenti;&lt;/li&gt;
&lt;li&gt;un componente riutilizzabile è molto facile da &lt;strong&gt;testare&lt;/strong&gt;, perché piccolo e atomico, quindi usandolo potremmo confidare maggiormente sulla correttezza del nostro codice;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Questi stessi vantaggi si ottengono, infatti, proprio usando oggetti come &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt;. Ma, come ho detto, esistono molti altri componenti di questo tipo, e in effetti definire le loro interfacce è un problema a sé, di non facile soluzione: lo trovo tuttavia un problema molto interessante. Seguendo le regole &lt;em&gt;generico&lt;/em&gt; e &lt;em&gt;componibile&lt;/em&gt; abbiamo già una linea guida per definire nuovi componenti riusabili, ma per chiudere il cerchio abbiamo bisogno di una terza regola, non meno importante:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un oggetto riusabile deve essere &lt;strong&gt;semplice&lt;/strong&gt;, cioè deve avere una unica responsabilità, lineare e facile da descrivere;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; segue questa regola: è un contenitore generico per un oggetto che potrebbe esserci, oppure no. &lt;code&gt;Array&lt;/code&gt; segue questa regola: rappresenta una collezione ordinata di oggetti, ai quali posso accedere in un tempo costante. Proviamo a creare un nuovo componente riutilizzabile applicando le regole.&lt;/p&gt;

&lt;p&gt;Consideriamo questo caso d&amp;rsquo;uso reale (piuttosto frequente): diversi oggetti devono essere notificati quando un certo oggetto cambia il suo stato, o compie qualche azione. Un modo per risolvere il problema è rappresentato dall&amp;rsquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;, che consiste nel far implementare ai nostri oggetti un&amp;rsquo;interfaccia che indica un comportamento di tipo &lt;a href=&#34;https://it.wikipedia.org/wiki/Publish/subscribe&#34;&gt;publish-subscribe&lt;/a&gt;. Tuttavia, far implementare agli oggetti un&amp;rsquo;interfaccia &lt;strong&gt;non è riusabile&lt;/strong&gt;: ogni volta in cui useremo questo pattern finiremo per &lt;strong&gt;riscrivere&lt;/strong&gt; codice molto simile. Vogliamo invece incapsulare il comportamento alla base di questo pattern in un oggetto generico, e riutilizzare quell&amp;rsquo;oggetto. Quanto segue è una possibile implementazione di tale oggetto, quella che personalmente uso in produzione, ma ce ne sono molte altre: in effetti, l&amp;rsquo;idea di trovare un modo generico e componibile di rappresentare e manipolare &lt;em&gt;flussi&lt;/em&gt; di segnali osservabili ha fatto nascere un intero paradigma di programmazione, chiamato &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming&lt;/a&gt;. Ma nel nostro caso siamo interessati a creare un ben più semplice oggetto &lt;strong&gt;Signal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;La classe &lt;code&gt;Signal&lt;/code&gt; che vogliamo implementare deve rappresentare un &lt;em&gt;aggiornamento&lt;/em&gt; per un certo oggetto: l&amp;rsquo;aggiornamento può riguardare qualsiasi cosa, per esempio un nuovo valore per un attributo, o il fatto che una certa azione è stata compiuta. Useremo il linguaggio Swift, grazie al quale potremo godere anche di ottima sicurezza sulla manipolazione dei &lt;strong&gt;tipi&lt;/strong&gt; coinvolti. Ecco in sintesi cosa chiediamo alla classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;deve avere un sottotipo &lt;strong&gt;parametrico&lt;/strong&gt;, che sarà appunto il tipo del valore segnalato ad ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;observe&lt;/code&gt;, che prende in ingresso una &lt;em&gt;closure&lt;/em&gt; che rappresenta l&amp;rsquo;azione da compiere a ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;send&lt;/code&gt;, che prende in ingresso un nuovo valore del tipo sottostante;&lt;/li&gt;
&lt;li&gt;deve dichiarare semplici metodi di composizione, che seguano le convenzioni classiche per i nomi, come &lt;code&gt;map&lt;/code&gt; per generare un nuovo &lt;code&gt;Signal&lt;/code&gt; da uno esistente trasformando il valore osservato, e &lt;code&gt;forwardTo&lt;/code&gt; per fare in modo che un altro &lt;code&gt;Signal&lt;/code&gt;, quando produce un nuovo valore, &lt;em&gt;attivi&lt;/em&gt; il segnale di partenza;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dal punto di vista semantico, possiamo descrivere un &lt;code&gt;Signal&lt;/code&gt; come un contenitore di un valore che esisterà a un certo punto nel futuro, e continuerà ad aggiornarsi indefinitamente.&lt;/p&gt;

&lt;p&gt;Segue l&amp;rsquo;intera implementazione della classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum SignalContinuation
{
  case Continue
  case Stop
}

public class Signal&amp;lt;Subtype&amp;gt;
{
  private var observers: [(Subtype -&amp;gt; SignalContinuation)] = []

  public init() {}

  public func observe (observeFunction: Subtype -&amp;gt; SignalContinuation)
  {
    observers.append(observeFunction)
  }

  public func send (value: Subtype)
  {
    var continuations: [(Subtype -&amp;gt; SignalContinuation)] = []
    while observers.count &amp;gt; 0
    {
      let observer = observers.removeFirst()
      let continuation = observer(value)
      switch continuation
      {
      case .Continue:
        continuations.append(observer)
      case .Stop: break
      }
    }
    observers = continuations
  }

  public func forwardTo (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(action)
      return .Continue
    }
    return self
  }

  public func forwardTo &amp;lt;OtherSubtype&amp;gt; (
    otherSignal: Signal&amp;lt;OtherSubtype&amp;gt;,
    mappingFunction: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(mappingFunction(action))
      return .Continue
    }
    return self
  }

  public func map &amp;lt;OtherSubtype&amp;gt; (transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;
  {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    forwardTo(mappedSignal, mappingFunction: transform)
    return mappedSignal
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;implementazione è semplice, ma potente. Un problema affrontato di frequente quando si implementa l&amp;rsquo;&lt;em&gt;observer pattern&lt;/em&gt; è la gestione delle disiscrizioni; è responsabilità di chi osserva smettere di farlo, e in questa implementazione di &lt;code&gt;Signal&lt;/code&gt; la cosa è gestita direttamente nella &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;: la &lt;em&gt;closure&lt;/em&gt; deve ritornare un valore di tipo &lt;code&gt;SignalContinuation&lt;/code&gt; che può essere appunto &lt;code&gt;.Continue&lt;/code&gt; o &lt;code&gt;.Stop&lt;/code&gt;. Un altro problema è la gestione della memoria: dobbiamo assicurarci che quando la memoria di un osservatore è rilasciata, questo debba anche smettere di osservare i segnali, o il messaggio verrà inviato a un puntatore non valido, con conseguente crash dell&amp;rsquo;app. Swift definisce alcuni descrittori di &lt;em&gt;memory ownership&lt;/em&gt;, e &lt;code&gt;weak&lt;/code&gt; fa al caso nostro: sarà sufficiente inserire una &lt;em&gt;guard clause&lt;/em&gt; all&amp;rsquo;inizio della &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;; se l&amp;rsquo;oggetto è diventato &lt;code&gt;nil&lt;/code&gt;, la &lt;em&gt;closure&lt;/em&gt; ritornerà &lt;code&gt;.Stop&lt;/code&gt;. L&amp;rsquo;esempio seguente mostra un possibile utilizzo della classe &lt;code&gt;Signal&lt;/code&gt;, incluso il meccanismo appena descritto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Sender
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func sendNew(value: Int)
  {
    signal.send(value)
  }
}

class Receiver&amp;lt;Type: CustomStringConvertible&amp;gt;
{
  func startObserving(signal: Signal&amp;lt;Type&amp;gt;)
  {
    signal.observe { [weak self] value in
      guard let this = self else { return .Stop }
      this.printNewValue(value)
      return .Continue
    }
  }

  func printNewValue(value: Type)
  {
    print(value)
  }
}

let sender = Sender()
let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(sender.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 3, 5, 10, 20 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio possiamo osservare l&amp;rsquo;applicazione dei concetti introdotti all&amp;rsquo;inizio dell&amp;rsquo;articolo: invece di creare una nuova interfaccia per lo stesso comportamento, stiamo direttamente usando e riusando l&amp;rsquo;oggetto &lt;code&gt;Signal&lt;/code&gt;. Un esempio più complesso potrebbe essere rappresentato dall&amp;rsquo;aggiunta di un &lt;em&gt;resonator&lt;/em&gt;, cioè di un oggetto che possiede un segnale che risuona con un altro, quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DoublingResonator
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func resonateWith(otherSignal: Signal&amp;lt;Int&amp;gt;)
  {
    otherSignal.forwardTo(signal) { $0*2 }
  }
}

let resonator = DoublingResonator()
resonator.resonateWith(sender.signal)

let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(resonator.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 6, 10, 20, 40 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono molte altre opzioni per comporre segnali, ma finché non ne avremo bisogno sarà meglio mantenere la classe &lt;strong&gt;semplice&lt;/strong&gt;: gradualmente nel tempo potremo aggiungere nuove funzionalità, e fintanto che queste saranno sufficientemente generiche e propriamente testate, saremo in grado di usarle in tutti i nostri progetti.&lt;/p&gt;

&lt;p&gt;Per concludere, definire le giuste astrazioni per conseguire riusabilità del codice non è un problema di semplice soluzione: molte pubblicazioni accademiche affrontano il problema (il classico articolo &lt;a href=&#34;http://www.biglever.com/papers/Krueger_AcmReuseSurvey.pdf&#34;&gt;Software Reuse&lt;/a&gt; di Charles W. Krueger fornisce una buona panoramica delle tecniche considerate), e il motivo per il quale la &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt; ha trovato molte applicazioni in programmazione funzionale è perché essa offre un eccellente insieme di astrazioni per affrontare diverse classi di problemi. Tuttavia sono convinto che i vantaggi legati allo scrivere codice riutilizzabile siano molti, e che poter basare un design sulla composizione di oggetti atomici sia &lt;strong&gt;un degno obiettivo&lt;/strong&gt; da perseguire.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>http://engineering.facile.it/blog/eng/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/eng/optionals-in-objective-c/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Objective-C is not going anywhere&lt;/strong&gt;. While Swift is most certainly the new hotness for iOS and OS X programming, there are some concrete reasons to stick with Objective-C for a while:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Objective-C based projects still need maintenance and new features to be added, and mixing Swift and Objective-C, while possible, &lt;strong&gt;can be tricky&lt;/strong&gt; and possibly unconvenient, due to the dynamic nature of the latter;&lt;/li&gt;
&lt;li&gt;Swift is changing rapidly, has still some bugs and &lt;strong&gt;performance problems&lt;/strong&gt;, and still lacks some features that professionals need, while Objective-C is mature and has a strong community;&lt;/li&gt;
&lt;li&gt;some may &lt;strong&gt;prefer a more dynamic language&lt;/strong&gt;, and Objective-C support from Apple &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;is still strong&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personally, while I naturally lean towards a more static, &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; approach to programming, from time to time I like to work in a more dynamic environment, so both for preference and for business needs, I still didn&amp;rsquo;t put Objective-C completely away. But just after a few weeks of Swift I found myself missing one of the most powerful features of the language: &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;table-of-contents:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Table of contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#the-optional-type&#34;&gt;The &lt;code&gt;Optional&lt;/code&gt; type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionals-in-swift&#34;&gt;Optionals in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#back-to-objective-c&#34;&gt;Back to Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-a-json-parser&#34;&gt;Example: a JSON parser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;the-optional-type&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-optional-type:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;The &lt;code&gt;Optional&lt;/code&gt; type&lt;/h2&gt;

&lt;p&gt;A Optional is a &lt;em&gt;generic&lt;/em&gt; type, that is, a type that&amp;rsquo;s dependent  (actually, &lt;em&gt;parametric&lt;/em&gt;) on another &lt;strong&gt;subtype&lt;/strong&gt;, so whe can have, for example, a &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; or a &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt;: thanks to some syntactic sugar, those types are written in Swift as &lt;code&gt;String?&lt;/code&gt; and &lt;code&gt;Int?&lt;/code&gt;. So, what is an &lt;code&gt;Optional&lt;/code&gt;? It&amp;rsquo;s a representation   of a value that could be there, and be of a particular subtype, or could not, therefore being &lt;strong&gt;nil&lt;/strong&gt;: by &lt;em&gt;wrapping&lt;/em&gt; the subtype into an &lt;code&gt;Optional&lt;/code&gt;, the Swift compiler knows that the value could be nil, and complain in the cases where we are using an &lt;code&gt;Optional&lt;/code&gt; where a value that&amp;rsquo;s &lt;strong&gt;never&lt;/strong&gt; nil is expected. By itself, this simple feature grants us a lot of type-safety for free: for example, in Swift we can&amp;rsquo;t initialize a non-optional value with nil, and considering that, for the Swift&amp;rsquo;s compiler, a value cannot be used before being initialized, by saying that a value&amp;rsquo;s type is &lt;code&gt;String&lt;/code&gt; the compiler will assure us that the value will &lt;strong&gt;always&lt;/strong&gt; be a string, no matter what.&lt;/p&gt;

&lt;p&gt;In contrast, Objective-C objects can always be nil, and if we expect something not to be nil, we are forced to check for the actual existence of everything at any time. But actually, that&amp;rsquo;s not necessarily a big deal: it&amp;rsquo;s a classic &lt;strong&gt;tradeoff&lt;/strong&gt; of dynamic languages, and it can be even considered a &lt;em&gt;feature&lt;/em&gt; by some people: in using a dynamically typed language, we are always expected to design our APIs with &lt;a href=&#34;https://en.wikipedia.org/wiki/Late_binding&#34;&gt;late binding&lt;/a&gt; in mind. Also, the new &lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;Objective-C nullability specifiers&lt;/a&gt; will help the compiler trigger warnings when nil is passed to a property or method parameter when &lt;code&gt;nonnull&lt;/code&gt; is expected. But the problem is still there: we need a lot of boilerplate to always check for &lt;em&gt;nullness&lt;/em&gt;, and that can produce error-prone, less readable code. The need for this boilerplate is missing in Swift, and that&amp;rsquo;s thanks to the nature of the &lt;code&gt;Optional&lt;/code&gt; type: in fact, it works in the same way as the &lt;code&gt;Maybe&lt;/code&gt; type in Haskell, or the &lt;code&gt;Option&lt;/code&gt; type in Scala, that is, &lt;code&gt;Optional&lt;/code&gt; is actually a &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;The concept of &lt;em&gt;monad&lt;/em&gt; is inherited by functional programming from &lt;a href=&#34;https://en.wikipedia.org/wiki/Category_theory&#34;&gt;category theory&lt;/a&gt; and there are plenty of &lt;a href=&#34;https://wiki.haskell.org/Monad&#34;&gt;introductions&lt;/a&gt; &lt;a href=&#34;https://www.haskell.org/tutorial/monads.html&#34;&gt;about it&lt;/a&gt; &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;on the web&lt;/a&gt;, so I&amp;rsquo;m not going into the specifics here: let me just say that a monad is a &lt;em&gt;computational context&lt;/em&gt;, that is, a specification for the way some &lt;em&gt;computations&lt;/em&gt; need to be resolved. Applying a certain transformation to a monad will result in another instance of the same monad, different from the first, based on the specific kind of monad. For example, applying some transformation to an &lt;code&gt;Optional&lt;/code&gt; monad will result in applying the same transformation to the contained value if it&amp;rsquo;s there, or absolutely nothing if the &lt;code&gt;Optional&lt;/code&gt; contains nil: in both cases, the transformation&amp;rsquo;s output will be another &lt;code&gt;Optional&lt;/code&gt;, possibly of different subtype.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optionals-in-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;optionals-in-swift:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Optionals in Swift&lt;/h2&gt;

&lt;p&gt;Consider the following Swift code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalString = optionalInt.map(toString)
print(optionalString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example, &lt;code&gt;optionalInt&lt;/code&gt; is a &lt;code&gt;Int&lt;/code&gt; wrapped into an &lt;code&gt;Optional&lt;/code&gt;, thus having type &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; (Swift&amp;rsquo;s syntactic sugar allows us to write &lt;code&gt;Int?&lt;/code&gt;), and by applying the &lt;code&gt;toString&lt;/code&gt; function to that &lt;code&gt;Optional&lt;/code&gt; we get an instance of &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;. We can see that, to actually apply the &lt;code&gt;toString&lt;/code&gt; function to the &lt;code&gt;Optional&lt;/code&gt;, we passed the function to the &lt;code&gt;map&lt;/code&gt; method: this operation is usually called &lt;a href=&#34;https://wiki.haskell.org/Lifting&#34;&gt;&lt;em&gt;lifting&lt;/em&gt; a function&lt;/a&gt;, because the function &lt;code&gt;toString&lt;/code&gt;, of type &lt;code&gt;Int -&amp;gt; String&lt;/code&gt;, is &lt;em&gt;lifted&lt;/em&gt; into the type &lt;code&gt;Optional&amp;lt;Int&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As we can see, no conditional statements were used in manipulating the optional integer: by &lt;em&gt;lifting&lt;/em&gt; our transformations with the &lt;code&gt;map&lt;/code&gt; method, we can apply them directly to the &lt;code&gt;Optional&lt;/code&gt; instances, and we can also chain them pretty easily, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let doubled: Int -&amp;gt; Int = { $0*2 }

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalDoubledString = optionalInt.map(doubled).map(toString)
print(optionalDoubledString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to express the opposite operation, we run into a problem: transforming a &lt;code&gt;String&lt;/code&gt; into a &lt;code&gt;Int&lt;/code&gt; is not always considered possible by Swift (for example, no numbers in the string), therefore the operation is optional. In fact:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalStringFrom(value: String, ifTrue: Bool) -&amp;gt; String?
{
  return ifTrue ? value : nil
}

let toInt: String -&amp;gt; Int? = { Int($0) }

let anotherOptionalString = makeOptionalStringFrom(&amp;quot;3&amp;quot;, ifTrue: true)

let anotherOptionalInt = anotherOptionalString.map(toInt).map(doubled)
/// this won&#39;t compile!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem here is that &lt;code&gt;toInt&lt;/code&gt; is a function of type &lt;code&gt;String -&amp;gt; Optional&amp;lt;Int&amp;gt;&lt;/code&gt;, and lifting the function to the &lt;code&gt;Optional&lt;/code&gt; &amp;ldquo;world&amp;rdquo; will turn its type into something like &lt;code&gt;Optional&amp;lt;String&amp;gt; -&amp;gt; Optional&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;&lt;/code&gt;, that is, an optional integer wrapped into another optional: in &lt;em&gt;monadic&lt;/em&gt; terminology, to lift functions that transforms the wrapped type into another instance of the same monad, we need a &lt;code&gt;flatMap&lt;/code&gt; operation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let anotherOptionalInt = anotherOptionalString.flatMap(toInt).map(doubled)
/// this is fine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, for the &lt;code&gt;Optional&lt;/code&gt; type, &lt;code&gt;flatMap&lt;/code&gt; works like &lt;code&gt;map&lt;/code&gt; but for functions that transform the wrapped type into another &lt;code&gt;Optional&lt;/code&gt;. In reading the code, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; can be basically treated as the same: they both indicate a transformation, and the fact that computations passed to &lt;code&gt;flatMap&lt;/code&gt; are of slightly different type can be considered an implementation detail.&lt;/p&gt;

&lt;p&gt;Actually, Swift treats these types &lt;strong&gt;a little differently&lt;/strong&gt; than in other languages: for example, &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt; are usually &lt;em&gt;free functions&lt;/em&gt; in most &lt;em&gt;functional&lt;/em&gt; languages, while in Swift they are &lt;strong&gt;methods&lt;/strong&gt;. In general, Swift encourages the use of methods and &lt;strong&gt;method chaining&lt;/strong&gt; instead of free functions composed with special operators: it&amp;rsquo;s mostly a matter of philosophy, but in bringing these features back to Objective-C, the method-based approach is going to be really useful because there&amp;rsquo;s no easy syntax for free functions in the language, while methods have the signature clean and readable syntax that we&amp;rsquo;re used to.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;back-to-objective-c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;back-to-objective-c:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Back to Objective-C&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s implement the &lt;code&gt;Optional&lt;/code&gt; class in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface Optional : NSObject

+ (Optional*)with:(id _Nullable)value;

- (Optional*)map:(id(^)(id))mapBlock;
- (Optional*)flatMap:(Optional*(^)(id))flatMapBlock;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

#import &amp;quot;Optional.h&amp;quot;

@interface Optional ()

@property (strong, nonatomic, nullable) id value;

@end

@implementation Optional

+ (Optional*)with:(id _Nullable)value
{
  Optional* optional = [Optional new];
  optional.value = value;
  return optional;
}

- (Optional *)map:(id  _Nonnull (^)(id _Nonnull))mapBlock
{
  if (self.value != nil)
  {
    return [Optional with:mapBlock(self.value)];
  }
  return self;
}

- (Optional *)flatMap:(Optional* _Nonnull (^)(id _Nonnull))flatMapBlock
{
  if (self.value != nil)
  {
    return flatMapBlock(self.value);
  }
  return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, the &lt;code&gt;with:&lt;/code&gt; class method will create an &lt;code&gt;Optional&lt;/code&gt; object by wrapping some other object, of unspecified class: because there&amp;rsquo;s no true &lt;em&gt;generics&lt;/em&gt; in Objective-C, we won&amp;rsquo;t be able to make our Optional type as type-safe as in Swift, but as we&amp;rsquo;ll see, it won&amp;rsquo;t be a big deal and we&amp;rsquo;ll still be able to get some really &lt;strong&gt;powerful features&lt;/strong&gt;. The &lt;code&gt;map:&lt;/code&gt; method will check if the wrapped object is not nil, and apply the transformation expressed by the &lt;code&gt;mapBlock&lt;/code&gt; block only if the object is actually there: in this case, Objective-C nullability specifiers really help us in designing our APIs, because we clearly specified that &lt;code&gt;mapBlock&lt;/code&gt; will accept and will return non-nil objects only. The &lt;code&gt;flatMapBlock&lt;/code&gt; block will return instead another &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can test this by essentially recreating the same Swift example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Test : NSObject

+ (void)testOptional;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.m

#import &amp;quot;Test.h&amp;quot;
#import &amp;quot;Optional.h&amp;quot;

@implementation Test

+ (void)testOptional
{
  Optional* optionalInt = [self makeOptionalIntFrom:@3 ifTrue:YES];
  Optional* optionalDoubledString = [[optionalInt
                                      map:[self doubled]]
                                     map:[self toString]];
  NSLog(@&amp;quot;%@&amp;quot;, optionalDoubledString);
}

+ (Optional*)makeOptionalIntFrom:(NSNumber*)fromInt ifTrue:(BOOL)ifTrue
{
  return [Optional with:ifTrue ? fromInt : nil];
}


+ (NSNumber*(^)(NSNumber*))doubled
{
  return ^NSNumber*(NSNumber* value)  {
    return @(value.integerValue*2);
  };
}

+ (NSString*(^)(NSNumber*))toString
{
  return ^NSString*(NSNumber* value)  {
    return [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, value];
  };
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once we applied our transformations, we need a way to &lt;em&gt;unwrap&lt;/em&gt; the object inside our &lt;code&gt;Optional&lt;/code&gt;: in Swift this is done at language level, with some syntactic sugar, while in Objective-C we can follow the standard conventions of the functional programming community, that is, we can &lt;em&gt;get&lt;/em&gt; the wrapped object via a &lt;code&gt;get&lt;/code&gt; method.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id _Nullable)get;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)get
{
  return self.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course the &lt;code&gt;get&lt;/code&gt; method will return an &lt;code&gt;id _Nullable&lt;/code&gt;, which means that the returned object can (obviously) be nil. A frequent pattern when dealing with &lt;code&gt;nil&lt;/code&gt; objects is replacing them with &amp;ldquo;default&amp;rdquo; versions: that can be useful when we don&amp;rsquo;t really care about the data contained in an object, but we don&amp;rsquo;t want to be exposed to the risk of possibly null references. Once again, with the &lt;code&gt;Optional&lt;/code&gt; class we can avoid conditional statements and express the &amp;ldquo;defaulting&amp;rdquo; mechanism in a more declarative way: we just need to add a &lt;code&gt;getOrElse:&lt;/code&gt; method, that will return the wrapped object if it&amp;rsquo;s there, or will return a default object, that we&amp;rsquo;ll pass to the method:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id)getOrElse:(id(^)())elseBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)getOrElse:(id  _Nonnull (^)())elseBlock
{
  if (self.value != nil)
  {
    return self.value;
  }
  return elseBlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, &lt;code&gt;getOrElse:&lt;/code&gt; will &lt;strong&gt;not&lt;/strong&gt; return a &lt;code&gt;_Nullable&lt;/code&gt; object, and that&amp;rsquo;s thanks to &lt;code&gt;elseBlock&lt;/code&gt;: we&amp;rsquo;re not passing the actual default object here, but a block that will produce one; this way, we can get the default object &lt;strong&gt;lazily&lt;/strong&gt;, because if the wrapped object is not nil, the default object doesn&amp;rsquo;t need to be allocated.&lt;/p&gt;

&lt;p&gt;For the rest of the article we&amp;rsquo;ll work on a more real-world example, and in doing so we&amp;rsquo;ll add more features to the &lt;code&gt;Optional&lt;/code&gt; class, making it more and more powerful.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;example-a-json-parser&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;example-a-json-parser:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Example: a JSON parser&lt;/h2&gt;

&lt;p&gt;Suppose we want to create an app that shows movie informations: we are retrieving those informations in JSON format from a website like &lt;a href=&#34;http://api.myapifilms.com&#34;&gt;myapifilms&lt;/a&gt;. Each movie has a JSON representation like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;countries&amp;quot;: [
        &amp;quot;USA&amp;quot;
    ],
    &amp;quot;directors&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;filmingLocations&amp;quot;: [
        &amp;quot;St. Croix&amp;quot;,
        &amp;quot;U.S. Virgin Islands&amp;quot;
    ],
    &amp;quot;genres&amp;quot;: [
        &amp;quot;Crime&amp;quot;,
        &amp;quot;Drama&amp;quot;
    ],
    &amp;quot;idIMDB&amp;quot;: &amp;quot;tt0111161&amp;quot;,
    &amp;quot;languages&amp;quot;: [
        &amp;quot;English&amp;quot;
    ],
    &amp;quot;metascore&amp;quot;: &amp;quot;80/100&amp;quot;,
    &amp;quot;originalTitle&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;plot&amp;quot;: &amp;quot;Andy Dufresne is a young and successful banker whose life changes drastically when he is convicted and sentenced to life imprisonment for the murder of his wife and her lover. Set in the 1940s, the film shows how Andy, with the help of his friend Red, the prison entrepreneur, turns out to be a most unconventional prisoner.&amp;quot;,
    &amp;quot;ranking&amp;quot;: 1,
    &amp;quot;rated&amp;quot;: &amp;quot;R&amp;quot;,
    &amp;quot;rating&amp;quot;: &amp;quot;9.3&amp;quot;,
    &amp;quot;releaseDate&amp;quot;: &amp;quot;19941014&amp;quot;,
    &amp;quot;runtime&amp;quot;: [
        &amp;quot;142 min&amp;quot;
    ],
    &amp;quot;simplePlot&amp;quot;: &amp;quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;The Shawshank Redemption&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;Movie&amp;quot;,
    &amp;quot;urlIMDB&amp;quot;: &amp;quot;http://www.imdb.com/title/tt0111161&amp;quot;,
    &amp;quot;urlPoster&amp;quot;: &amp;quot;http://ia.media-imdb.com/images/M/MV5BODU4MjU4NjIwNl5BMl5BanBnXkFtZTgwMDU2MjEyMDE@._V1_SX214_AL_.jpg&amp;quot;,
    &amp;quot;votes&amp;quot;: &amp;quot;1,533,914&amp;quot;,
    &amp;quot;writers&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Stephen King&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0000175&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;year&amp;quot;: &amp;quot;1994&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course we want to define our own internal representation with a value object, change some structure and ignore the parts that we consider not relevant. Here&amp;rsquo;s a possible interface for the &lt;code&gt;Movie&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NS_ASSUME_NONNULL_BEGIN

@interface Movie : NSObject

@property (copy, nonatomic, readonly) NSString* title;
@property (copy, nonatomic, readonly) NSNumber* rating;
@property (copy, nonatomic, readonly) NSNumber* year;
@property (copy, nonatomic, readonly) NSNumber* lengthInMinutes;

+ (Movie*)withJSONDict:(NSDictionary*)dict;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class method &lt;code&gt;withJSONDict:&lt;/code&gt; will create an instance of &lt;code&gt;Movie&lt;/code&gt; from a JSON dictionary like the one showed before: as we can see from the interface declaration, we decided to not allow nil values for any of the properties; but when dealing with JSON, we must consider &lt;strong&gt;every possibility&lt;/strong&gt;, including missing keys, null values or wrong types. We&amp;rsquo;re going to use the &lt;code&gt;Optional&lt;/code&gt; type to parse the JSON dict in a clean, declarative and error-proof way.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s start with the title. From the JSON, the title should be given by the &amp;ldquo;title&amp;rdquo; key, and should be a string (&lt;code&gt;NSString&lt;/code&gt; in Objective-C), so we can get the title via the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt; NSString* title = [[[[Optional
                        with:[dict objectForKey:@&amp;quot;title&amp;quot;]]
                       
                       flatMap:^Optional*(id title) {
                         return [Optional with:[title isKindOfClass:[NSString class]] ? title : nil];
                       }]
                      
                      flatMap:^Optional*(NSString* title) {
                        return [Optional with:title.length &amp;gt; 0 ? title : nil];
                      }]
                     
                     getOrElse:^NSString*{
                       return @&amp;quot;NO TITLE&amp;quot;;
                     }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first &lt;code&gt;flatMap:&lt;/code&gt; step means that we want the title to be of &lt;code&gt;NSString&lt;/code&gt; class. It&amp;rsquo;s convenient to abstract this operation directly into the &lt;code&gt;Optional&lt;/code&gt; constructor, because we&amp;rsquo;re going to do it all the time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;+ (Optional *)with:(id)value as:(Class)valueClass
{
  if ([value isKindOfClass:valueClass])
  {
    return [Optional with:value];
  }
  return [Optional with:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second &lt;code&gt;flatMap:&lt;/code&gt; step means that if the found string is of length 0 (that is, empty), we are going to treat it as unknown. Actually, this step will act as a &lt;strong&gt;filter&lt;/strong&gt;, because it will only &lt;em&gt;let pass&lt;/em&gt; the strings that are not empty; with that in mind, let&amp;rsquo;s add a &lt;code&gt;filter:&lt;/code&gt; method to the &lt;code&gt;Optional&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (Optional*)filter:(BOOL(^)(id))filterBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (Optional*)filter:(BOOL (^)(id _Nonnull))filterBlock
{
  return [self flatMap:^Optional*(id value) {
    if (filterBlock(value))
    {
      return self;
    }
    else
    {
      return [Optional with:nil];
    }
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;filter:&lt;/code&gt; method takes as parameter a block that returns a &lt;code&gt;BOOL&lt;/code&gt; based on the wrapped value: internally, &lt;code&gt;filter:&lt;/code&gt; will actually call &lt;code&gt;flatMap:&lt;/code&gt;, with a conditional expression to check if the &lt;code&gt;filterBlock&lt;/code&gt; succeeds or fails.&lt;/p&gt;

&lt;p&gt;Finally:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[Optional
                       with:[dict objectForKey:@&amp;quot;title&amp;quot;]
                       as:[NSString class]]
                      
                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]
                     
                     getOrElse:^NSString*{ return @&amp;quot;NO TITLE&amp;quot;; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, no conditional statements, and very few lines of code, completely declarative.&lt;/p&gt;

&lt;p&gt;For the &lt;code&gt;rating&lt;/code&gt; and &lt;code&gt;year&lt;/code&gt; parameters we need to add a &lt;code&gt;map&lt;/code&gt; to convert the &lt;code&gt;NSString&lt;/code&gt; into an &lt;code&gt;NSNumber&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* rating = [[[[Optional
                         with:[dict objectForKey:@&amp;quot;rating&amp;quot;]
                         as:[NSString class]]
                        
                        filter:^BOOL(NSString* string) {
                          return string.length &amp;gt; 0;
                        }]
                       
                       map:^NSNumber*(NSString* stringValue) {
                         return [NSDecimalNumber decimalNumberWithString:stringValue];
                       }]
                      
                      getOrElse:^NSNumber*{ return @0; }];
  movie.rating = rating;
  
  NSNumber* year = [[[[Optional
                       with:[dict objectForKey:@&amp;quot;year&amp;quot;]
                       as:[NSString class]]
                      
                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]
                     
                     map:^NSNumber*(NSString* stringValue) {
                       return [NSDecimalNumber decimalNumberWithString:stringValue];
                     }]
                    
                    getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;lenghtInMinutes&lt;/code&gt; parameter is a little tricky; from the JSON we can see that the value is represented like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;runtime&amp;quot;: [ 
	&amp;quot;142 min&amp;quot; 
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we expect an array, of which we&amp;rsquo;re only interested in the first element (thus, the array must not be empty), that has to be a string; of this string we only need the first part, removing the &lt;code&gt;min&lt;/code&gt; portion. Luckily, we already have all the tools for the job:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;  NSNumber* lengthInMinutes =
  [[[[[[Optional
        with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
        as:[NSArray class]]
       
       flatMap:^Optional*(NSArray* array) {
         return [Optional with:[array firstObject]];
       }]
      
      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]
     
     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]
    
    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]
   
   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, something is missing: the method &lt;code&gt;[array firstObject]&lt;/code&gt; returns the first object of the array if the array has at least one element, or nil if the array is empty: there&amp;rsquo;s no indication that the first object is actually a &lt;code&gt;NSString&lt;/code&gt;, so we need to add a &lt;code&gt;filter&lt;/code&gt; step to insure that the object is an instance of the correct class. Let&amp;rsquo;s do it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt; NSNumber* lengthInMinutes =
  [[[[[[[Optional
         with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
         as:[NSArray class]]
        
        flatMap:^id(NSArray* array) {
          return [Optional with:[array firstObject]];
        }]
       
       filter:^BOOL(id value) {
         return [value isKindOfClass:[NSString class]];
       }]
      
      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]
     
     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]
    
    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]
   
   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see, when we work with the &lt;code&gt;Optional&lt;/code&gt; class, adding a condition simply means &lt;strong&gt;adding a step&lt;/strong&gt; in the linear &lt;strong&gt;flow of expressions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusion&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Bringing back the &lt;code&gt;Optional&lt;/code&gt; type from Swift to Objective-C allowed us to build a JSON parsing routine, often something hard to maintain and error-prone, in a simple, linear and readable way. Of course there&amp;rsquo;s &lt;strong&gt;plenty of cases&lt;/strong&gt; where working with optionals can give us the same advantages: by composing &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; operations we can express our intent in a clean and readable way. But this is not just about the &lt;code&gt;Optional&lt;/code&gt; type: some readers may have probably noticed that many languages (including Swift) allow operations with the same names on lists and arrays, and the meanings are also the same: &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;flatMap&lt;/code&gt;, in particular, are &lt;strong&gt;generic concepts&lt;/strong&gt; related to monads (in fact, the array type is also a monad) and allow declarative compositions of transformations. This concept is at the core of &lt;strong&gt;functional programming&lt;/strong&gt;, and I think there&amp;rsquo;s plenty of reasons to apply similar concepts to a more object-oriented environment: they will help the programmer in reasoning about the code and express the intent in a more declarative way.&lt;/p&gt;

&lt;p&gt;The code for the &lt;code&gt;Optional&lt;/code&gt; class used throughout the article can be found on &lt;a href=&#34;https://gist.github.com/broomburgo/e318228a5f7d6a605e82&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Optionals in Objective-C</title>
      <link>http://engineering.facile.it/blog/ita/optionals-in-objective-c/</link>
      <pubDate>Mon, 09 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/optionals-in-objective-c/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;Objective-C vivrà ancora per molto&lt;/strong&gt;. Nonostante Swift sia il nuovo punto di riferimento per lo sviluppo iOS e OS X, ci sono ragioni concrete per scegliere di continuare a sviluppare in Objective-C, almeno per un po&amp;rsquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;progetti esistenti basati su Objective-C richiedono ancora mantenimento e probabile aggiunta di nuove funzionalità, e anche se è tecnicamente possibile mescolare i linguaggi, la cosa può risultare &lt;strong&gt;poco conveniente&lt;/strong&gt; per via della natura molto dinamica di Objective-C;&lt;/li&gt;
&lt;li&gt;Swift sta cambiando rapidamente, presenta ancora alcuni bug e &lt;strong&gt;problemi di performance&lt;/strong&gt;, e il suo workflow manca ancora di alcune feature fondamentali per i professionisti, mentre Objective-C è un linguaggio maturo, con una community molto vivace;&lt;/li&gt;
&lt;li&gt;alcuni possono &lt;strong&gt;preferire un linguaggio più dinamico&lt;/strong&gt;, e il supporto di Apple su Objective-C è &lt;a href=&#34;https://netguru.co/blog/objective-c-generics&#34;&gt;ancora forte&lt;/a&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Personalmente ho la tendenza a preferire linguaggi più statici, e un approccio &lt;a href=&#34;http://engineering.facile.it/type-first-development-in-swift/&#34;&gt;type-first&lt;/a&gt; alla programmazione, ma di tanto in tanto mi piace lavorare in un ambiente più &lt;em&gt;dinamico&lt;/em&gt;, quindi, sia per preferenza personale che per esigenze di business, non ho ancora messo Objective-C da parte. Ma dopo poche settimane di Swift, mi è mancata subito una delle sue funzionalità più potenti: gli &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optionals&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;indice:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-optional&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionals-in-swift&#34;&gt;Optionals in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#torniamo-a-objective-c&#34;&gt;Torniamo a Objective-C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#esempio-un-parser-json&#34;&gt;Esempio: un parser JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-optional&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-optional:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Il tipo &lt;code&gt;Optional&lt;/code&gt; è un tipo &lt;em&gt;generico&lt;/em&gt; (o, più propriamente, &lt;em&gt;parametrico&lt;/em&gt;), dipendente da un &lt;strong&gt;tipo secondario&lt;/strong&gt;: è possibile ad esempio definire un &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt; oppure un &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt;: la sintassi di Swift permette di scrivere i tipi appena indicati con &lt;code&gt;String?&lt;/code&gt; e &lt;code&gt;Int?&lt;/code&gt;. Ma cos&amp;rsquo;è esattamente un &lt;code&gt;Optional&lt;/code&gt;?. È un tipo particolare che serve a rappresentare un dato che &lt;em&gt;potrebbe&lt;/em&gt; esistere, ed essere quindi di un certo tipo secondario, o potrebbe non esistere, ed essere quindi &lt;strong&gt;nil&lt;/strong&gt;: &lt;em&gt;inscatolando&lt;/em&gt; il valore opzionale in un &lt;code&gt;Optional&lt;/code&gt;, il compilatore di Swift saprà che quel valore potrà essere nil, e emettere un errore nei casi in cui stiamo usando un &lt;code&gt;Optional&lt;/code&gt; dove ci si aspetta un valore &lt;strong&gt;sempre&lt;/strong&gt; presente. Questa semplice funzionalità ci garantisce notevole rigore nella definizione dei nostri tipi di dato e funzione: ad esempio, in Swift non possiamo inizializzare un valore non opzionale con nil, e considerando che, per il compilatore, un valore non può essere usato prima di essere istanziato, se assegniamo il tipo &lt;code&gt;String&lt;/code&gt; a un valore, siamo sicuri al 100% che quel valore sarà &lt;strong&gt;sempre a comunque&lt;/strong&gt; una stringa.&lt;/p&gt;

&lt;p&gt;Al contrario, in Objective-C un oggetto può essere sempre nil, e spesso siamo costretti a controllare l&amp;rsquo;effettiva presenza di un oggetto ogni volta in cui abbiamo bisogno di un&amp;rsquo;istanza che non sia nil. In realtà non si tratta di un grosso problema: è un classico &lt;strong&gt;compromesso&lt;/strong&gt; dei linguaggi dinamici, e il fatto che posso sempre inviare un messaggio a un riferimento nil può essere anche considerato una &lt;em&gt;feature&lt;/em&gt;: usando un linguaggio dinamico, ci si aspetta che progettiamo le nostre API tenendo sempre in considerazione il concetto di &lt;a href=&#34;https://en.wikipedia.org/wiki/Late_binding&#34;&gt;late-binding&lt;/a&gt;. Inoltre, i nuovi &lt;a href=&#34;https://developer.apple.com/swift/blog/?id=25&#34;&gt;&lt;em&gt;nullability specifiers&lt;/em&gt;&lt;/a&gt; di Objective-C aiutano il compilatore a emettere avvisi quando stiamo passando nil a un metodo o una &lt;em&gt;property&lt;/em&gt; che richiedono invece che il parametro sia &lt;code&gt;nonnull&lt;/code&gt;. Ma il problema rimane: abbiamo bisogno di molto &lt;em&gt;boilerplate&lt;/em&gt; per verificare se qualcosa è nil, e ciò può portare a codice poco leggibile e comprensibile, soggetto ad errori. Swift non ha tipicamente bisogno di questo &lt;em&gt;boilerplate&lt;/em&gt; grazie alla natura stessa del tipo &lt;code&gt;Optional&lt;/code&gt;: esso ha le stesse caratteristiche del tipo &lt;code&gt;Maybe&lt;/code&gt; in Haskell, o del tipo &lt;code&gt;Option&lt;/code&gt; in Scala, cioè &lt;code&gt;Optional&lt;/code&gt; è in realtà un &lt;strong&gt;monad&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il concetto di &lt;em&gt;monad&lt;/em&gt; è ereditato, in programmazione funzionale, dalla &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt;, ed è facile trovare &lt;a href=&#34;https://wiki.haskell.org/Monad&#34;&gt;molti&lt;/a&gt; &lt;a href=&#34;https://www.haskell.org/tutorial/monads.html&#34;&gt;testi&lt;/a&gt; &lt;a href=&#34;http://learnyouahaskell.com/a-fistful-of-monads&#34;&gt;introduttivi&lt;/a&gt; sul tema, quindi non approfondirò ulteriormente: dirò solo che un &lt;em&gt;monad&lt;/em&gt; è un &lt;em&gt;contesto computazionale&lt;/em&gt;, quindi una &lt;em&gt;specifica&lt;/em&gt; per il modo in cui una espressione deve essere valutata. Applicare una certa trasformazione a un &lt;em&gt;monad&lt;/em&gt; avrà come risultato un&amp;rsquo;altra istanza dello stesso &lt;em&gt;monad&lt;/em&gt; differente dalla prima, a seconda dello specifico tipo di &lt;em&gt;monad&lt;/em&gt;. Ad esempio, applicare una trasformazione a un &lt;code&gt;Optional&lt;/code&gt; risulterà nell&amp;rsquo;applicazione della stessa trasformazione al valore &lt;em&gt;contenuto&lt;/em&gt;, se presente, o assolutamente niente se l&amp;rsquo;&lt;code&gt;Optional&lt;/code&gt; contiene nil: in entrambi i casi, il risultato della trasformazione sarà un nuovo &lt;code&gt;Optional&lt;/code&gt;, possibilmente con un tipo secondario diverso.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;optionals-in-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;optionals-in-swift:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Optionals in Swift&lt;/h2&gt;

&lt;p&gt;Consideriamo il seguente codice Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalString = optionalInt.map(toString)  
print(optionalString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio, &lt;code&gt;optionalInt&lt;/code&gt; è un &lt;code&gt;Int&lt;/code&gt; &lt;em&gt;contenuto&lt;/em&gt; in un &lt;code&gt;Optional&lt;/code&gt;, che quindi ha tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt;&lt;/code&gt; (in Swift è possibile abbreviarlo in &lt;code&gt;Int?&lt;/code&gt;), e applicando ad esso la funzione &lt;code&gt;toString&lt;/code&gt; otteniamo un&amp;rsquo;istanza di &lt;code&gt;Optional&amp;lt;String&amp;gt;&lt;/code&gt;. Possiamo vedere che, per applicare effettivamente la funzione &lt;code&gt;toString&lt;/code&gt;, abbiamo passato la funzione come argomento al metodo &lt;code&gt;map&lt;/code&gt; del &lt;code&gt;Optional&lt;/code&gt;: questa operazione è solitamente chiamata &lt;em&gt;lifting&lt;/em&gt; di una funzione, perché la funzione &lt;code&gt;toString&lt;/code&gt;, di tipo &lt;code&gt;Int -&amp;gt; String&lt;/code&gt;, è &lt;em&gt;sollevata&lt;/em&gt; (&lt;em&gt;lifted&lt;/em&gt;) fino a diventare di tipo &lt;code&gt;Optional&amp;lt;Int&amp;gt; -&amp;gt; Optional&amp;lt;String&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Come possiamo vedere, non sono state usate istruzioni condizionali nel manipolare il valore intero &lt;em&gt;opzionale&lt;/em&gt;: &lt;em&gt;sollevando&lt;/em&gt; le trasformazioni con il metodo &lt;code&gt;map&lt;/code&gt;, possiamo applicarle direttamente alle istanze di &lt;code&gt;Optional&lt;/code&gt;, e possiamo anche concatenarle molto facilmente, ad esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalIntFrom(value: Int, ifTrue: Bool) -&amp;gt; Int?  
{
  return ifTrue ? value : nil
}

let optionalInt = makeOptionalIntFrom(3, ifTrue: true)  
print(optionalInt.dynamicType) /// prints &#39;Optional&amp;lt;Int&amp;gt;&#39;

let doubled: Int -&amp;gt; Int = { $0*2 }

let toString: Int -&amp;gt; String = { &amp;quot;\($0)&amp;quot; }

let optionalDoubledString = optionalInt.map(doubled).map(toString)  
print(optionalDoubledString.dynamicType) /// prints &#39;Optional&amp;lt;String&amp;gt;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Volendo esprimere l&amp;rsquo;operazione opposta, avremmo un problema: trasformare una stringa in un intero non è sempre possibile in Swift (ad esempio se non c&amp;rsquo;è alcun numero nella stringa), quindi l&amp;rsquo;operazione stessa risulterebbe in un &lt;code&gt;Optional&lt;/code&gt;. Infatti:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;func makeOptionalStringFrom(value: String, ifTrue: Bool) -&amp;gt; String?  
{
  return ifTrue ? value : nil
}

let toInt: String -&amp;gt; Int? = { Int($0) }

let anotherOptionalString = makeOptionalStringFrom(&amp;quot;3&amp;quot;, ifTrue: true)

let anotherOptionalInt = anotherOptionalString.map(toInt).map(doubled)
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il problema qui è che la funzione &lt;code&gt;toInt&lt;/code&gt; è di tipo &lt;code&gt;String -&amp;gt; Optional&amp;lt;Int&amp;gt;&lt;/code&gt;, e il &lt;em&gt;lifting&lt;/em&gt; della funzione verso il &lt;em&gt;mondo opzionale&lt;/em&gt; la trasformerebbe in una funzione del tipo &lt;code&gt;Optional&amp;lt;String&amp;gt; -&amp;gt; Optional&amp;lt;Optional&amp;lt;Int&amp;gt;&amp;gt;&lt;/code&gt;, quindi un intero opzionale contenuto in un altro &lt;code&gt;Optional&lt;/code&gt;; in base alla terminologia accettata, abbiamo bisogno di un&amp;rsquo;operazione di &lt;code&gt;flatMap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Swift&#34;&gt;let anotherOptionalInt = anotherOptionalString.flatMap(toInt).map(doubled)  
/// funziona
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, per quanto riguarda il tipo &lt;code&gt;Optional&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; è simile a &lt;code&gt;map&lt;/code&gt;, ma deve essere usato per il &lt;em&gt;lifting&lt;/em&gt; di funzioni che generano altri valori opzionali. Nel leggere il codice, &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; possono sostanzialmente essere letti nello stesso modo: indicano entrambi una trasformazione, e il fatto che le funzioni passate a &lt;code&gt;flatMap&lt;/code&gt; abbiano un tipo diverso può essere considerato un dettaglio di implementazione.&lt;/p&gt;

&lt;p&gt;In realtà Swift tratta questi tipi di dato &lt;strong&gt;in maniera differente&lt;/strong&gt; rispetto ad altri linguaggi: ad esempio, nei linguaggi &lt;em&gt;funzionali&lt;/em&gt; &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt; sono di norma &lt;em&gt;funzioni libere&lt;/em&gt;, mentre in Swift sono &lt;strong&gt;metodi&lt;/strong&gt;. In generale, Swift incoraggia l&amp;rsquo;uso dei metodi, e del loro &lt;strong&gt;concatenamento&lt;/strong&gt;, invece di funzioni libere, composte con operatori speciali: si tratta, più che altro, di una questione filosofica, ma nel trasportare queste feature in Objective-C l&amp;rsquo;approccio basato sui metodi tornerà utile poiché non c&amp;rsquo;è un modo semplice di rappresentare funzioni libere nel linguaggio, mentre i metodi hanno la classica sintassi alla quale siamo abituati.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;torniamo-a-objective-c&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;torniamo-a-objective-c:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Torniamo a Objective-C&lt;/h2&gt;

&lt;p&gt;Implementiamo la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

NS_ASSUME_NONNULL_BEGIN

@interface Optional : NSObject

+ (Optional*)with:(id _Nullable)value;

- (Optional*)map:(id(^)(id))mapBlock;
- (Optional*)flatMap:(Optional*(^)(id))flatMapBlock;

@end

NS_ASSUME_NONNULL_END 
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

#import &amp;quot;Optional.h&amp;quot;

@interface Optional ()

@property (strong, nonatomic, nullable) id value;

@end

@implementation Optional

+ (Optional*)with:(id _Nullable)value
{
  Optional* optional = [Optional new];
  optional.value = value;
  return optional;
}

- (Optional *)map:(id  _Nonnull (^)(id _Nonnull))mapBlock
{
  if (self.value != nil)
  {
    return [Optional with:mapBlock(self.value)];
  }
  return self;
}

- (Optional *)flatMap:(Optional* _Nonnull (^)(id _Nonnull))flatMapBlock
{
  if (self.value != nil)
  {
    return flatMapBlock(self.value);
  }
  return self;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, il metodo di classe &lt;code&gt;with:&lt;/code&gt; crea un oggetto &lt;code&gt;Optional&lt;/code&gt; inscatolando un altro oggetto, di tipo non specificato: poiché non esiste un vero concetto di &lt;em&gt;generic&lt;/em&gt; in Objective-C, non sarà possibile realizzare un tipo &lt;code&gt;Optional&lt;/code&gt; sicuro, dal punto di vista dei tipi, come in Swift, ma non sarà un grosso problema, e saremo comunque in grado di ereditare da Swift &lt;strong&gt;potenti features&lt;/strong&gt;. Il metodo &lt;code&gt;map:&lt;/code&gt; verifica se l&amp;rsquo;oggetto contenuto non sia nil, e in tal caso applica la trasformazione espressa con &lt;code&gt;mapBlock&lt;/code&gt;: in questo caso i &lt;em&gt;nullability specifiers&lt;/em&gt; di Objective-C ci hanno aiutato nello scrivere la firma dei metodi, infatti abbiamo chiaramente specificato che &lt;code&gt;mapBlock&lt;/code&gt; accetta e ritorna oggetti che non siano nil; &lt;code&gt;flatMapBlock&lt;/code&gt; ritorna invece un altro &lt;code&gt;Optional&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Possiamo testare la cosa riscrivendo lo stesso esempio visto per Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.h

#import &amp;lt;Foundation/Foundation.h&amp;gt;

@interface Test : NSObject

+ (void)testOptional;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Test.m

#import &amp;quot;Test.h&amp;quot;
#import &amp;quot;Optional.h&amp;quot;

@implementation Test

+ (void)testOptional
{
  Optional* optionalInt = [self makeOptionalIntFrom:@3 ifTrue:YES];
  Optional* optionalDoubledString = [[optionalInt
                                      map:[self doubled]]
                                     map:[self toString]];
  NSLog(@&amp;quot;%@&amp;quot;, optionalDoubledString);
}

+ (Optional*)makeOptionalIntFrom:(NSNumber*)fromInt ifTrue:(BOOL)ifTrue
{
  return [Optional with:ifTrue ? fromInt : nil];
}


+ (NSNumber*(^)(NSNumber*))doubled
{
  return ^NSNumber*(NSNumber* value)  {
    return @(value.integerValue*2);
  };
}

+ (NSString*(^)(NSNumber*))toString
{
  return ^NSString*(NSNumber* value)  {
    return [NSString stringWithFormat:@&amp;quot;%@&amp;quot;, value];
  };
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Un volta applicate le trasformazioni, abbiamo bisogno di un metodo per &amp;ldquo;estrarre&amp;rdquo; l&amp;rsquo;oggetto all&amp;rsquo;interno del &lt;code&gt;Optional&lt;/code&gt;: Swift permette questa operazione a livello di sintassi, mentre in Objective-C possiamo seguire le convenzioni standard in programmazione funzionale, e cioè definire un metodo &lt;code&gt;get&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id _Nullable)get;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)get
{
  return self.value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;get&lt;/code&gt; ritorna un &lt;code&gt;id _Nullable&lt;/code&gt;: ciò vuol dire che l&amp;rsquo;oggetto ritornato può (ovviamente) essere nil. Un pattern frequente quando si ha a che fare con oggetti nil consiste nel sostituirli con versioni di &amp;ldquo;default&amp;rdquo;: può essere utile quando non ci interessano tanto i dati contenuti in un oggetto, ma non vogliamo correre i rischi associati al lavorare riferimenti &lt;em&gt;null&lt;/em&gt;. Ancora una volta, con la classe &lt;code&gt;Optional&lt;/code&gt; possiamo evitare istruzioni condizionali ed esprimere il meccanismo di &amp;ldquo;defaulting&amp;rdquo; in un modo più dichiarativo: dobbiamo semplicemente aggiungere un metodo &lt;code&gt;getOrElse:&lt;/code&gt;, che ritorni l&amp;rsquo;oggetto contenuto se presente, o un oggetto di default passato al metodo stesso:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (id)getOrElse:(id(^)())elseBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (id)getOrElse:(id  _Nonnull (^)())elseBlock
{
  if (self.value != nil)
  {
    return self.value;
  }
  return elseBlock();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, il metodo &lt;code&gt;getOrElse:&lt;/code&gt; &lt;strong&gt;non&lt;/strong&gt; ritorna un oggetto &lt;code&gt;_Nullable&lt;/code&gt;: in effetti non stiamo passando l&amp;rsquo;oggetto, ma un block che &amp;ldquo;produrrà&amp;rdquo; l&amp;rsquo;oggetto una volta invocato; in questo modo riusciamo a ottenere l&amp;rsquo;oggetto di default in maniera &lt;strong&gt;lazy&lt;/strong&gt;, perché se l&amp;rsquo;oggetto contenuto è presente, non è necessario generare l&amp;rsquo;oggetto di default.&lt;/p&gt;

&lt;p&gt;Per il resto dell&amp;rsquo;articolo lavoreremo su un esempio più concreto, e implementeremo diverse funzionalità per la classe &lt;code&gt;Optional&lt;/code&gt;, rendendola via via più utile e potente.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;esempio-un-parser-json&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;esempio-un-parser-json:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Esempio: un parser JSON&lt;/h2&gt;

&lt;p&gt;Supponiamo di voler realizzare un&amp;rsquo;app che mostra informazioni sui film: possiamo ottenerle in formato JSON da un sito come &lt;a href=&#34;http://api.myapifilms.com/index.do&#34;&gt;myapifilms&lt;/a&gt;. La rappresentazione JSON di ogni film è del tipo seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;{
    &amp;quot;countries&amp;quot;: [
        &amp;quot;USA&amp;quot;
    ],
    &amp;quot;directors&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;filmingLocations&amp;quot;: [
        &amp;quot;St. Croix&amp;quot;,
        &amp;quot;U.S. Virgin Islands&amp;quot;
    ],
    &amp;quot;genres&amp;quot;: [
        &amp;quot;Crime&amp;quot;,
        &amp;quot;Drama&amp;quot;
    ],
    &amp;quot;idIMDB&amp;quot;: &amp;quot;tt0111161&amp;quot;,
    &amp;quot;languages&amp;quot;: [
        &amp;quot;English&amp;quot;
    ],
    &amp;quot;metascore&amp;quot;: &amp;quot;80/100&amp;quot;,
    &amp;quot;originalTitle&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;plot&amp;quot;: &amp;quot;Andy Dufresne is a young and successful banker whose life changes drastically when he is convicted and sentenced to life imprisonment for the murder of his wife and her lover. Set in the 1940s, the film shows how Andy, with the help of his friend Red, the prison entrepreneur, turns out to be a most unconventional prisoner.&amp;quot;,
    &amp;quot;ranking&amp;quot;: 1,
    &amp;quot;rated&amp;quot;: &amp;quot;R&amp;quot;,
    &amp;quot;rating&amp;quot;: &amp;quot;9.3&amp;quot;,
    &amp;quot;releaseDate&amp;quot;: &amp;quot;19941014&amp;quot;,
    &amp;quot;runtime&amp;quot;: [
        &amp;quot;142 min&amp;quot;
    ],
    &amp;quot;simplePlot&amp;quot;: &amp;quot;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&amp;quot;,
    &amp;quot;title&amp;quot;: &amp;quot;The Shawshank Redemption&amp;quot;,
    &amp;quot;type&amp;quot;: &amp;quot;Movie&amp;quot;,
    &amp;quot;urlIMDB&amp;quot;: &amp;quot;http://www.imdb.com/title/tt0111161&amp;quot;,
    &amp;quot;urlPoster&amp;quot;: &amp;quot;http://ia.media-imdb.com/images/M/MV5BODU4MjU4NjIwNl5BMl5BanBnXkFtZTgwMDU2MjEyMDE@._V1_SX214_AL_.jpg&amp;quot;,
    &amp;quot;votes&amp;quot;: &amp;quot;1,533,914&amp;quot;,
    &amp;quot;writers&amp;quot;: [
        {
            &amp;quot;name&amp;quot;: &amp;quot;Stephen King&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0000175&amp;quot;
        },
        {
            &amp;quot;name&amp;quot;: &amp;quot;Frank Darabont&amp;quot;,
            &amp;quot;nameId&amp;quot;: &amp;quot;nm0001104&amp;quot;
        }
    ],
    &amp;quot;year&amp;quot;: &amp;quot;1994&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vogliamo definire la nostra rappresentazione interna del film con un &lt;em&gt;value object&lt;/em&gt;, modificare in parte la struttura e magari ignorare alcuni elementi che non consideriamo rilevanti. Ecco un&amp;rsquo;interfaccia possibile per la classe &lt;code&gt;Movie&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NS_ASSUME_NONNULL_BEGIN

@interface Movie : NSObject

@property (copy, nonatomic, readonly) NSString* title;
@property (copy, nonatomic, readonly) NSNumber* rating;
@property (copy, nonatomic, readonly) NSNumber* year;
@property (copy, nonatomic, readonly) NSNumber* lengthInMinutes;

+ (Movie*)withJSONDict:(NSDictionary*)dict;

@end

NS_ASSUME_NONNULL_END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo di classe &lt;code&gt;withJSONDict:&lt;/code&gt; crea un&amp;rsquo;istanza di &lt;code&gt;Movie&lt;/code&gt; da un dizionario JSON come quello appena mostrato: come si può vedere dall&amp;rsquo;interfaccia dichiarata, abbiamo deciso di non permettere valori nil per le varie &lt;em&gt;property&lt;/em&gt;; ma quando abbiamo a che fare con JSON &lt;strong&gt;tutto può succedere&lt;/strong&gt;, come chiavi mancanti, valori null o di tipo diverso. Useremo il tipo &lt;code&gt;Optional&lt;/code&gt; per parsare il dizionario JSON in modo chiaro, dichiarativo e a prova di errore.&lt;/p&gt;

&lt;p&gt;Iniziamo con i titolo. Dal JSON vediamo che il titolo si trova in corrispondenza della chiave &amp;ldquo;title&amp;rdquo;, e dovrebbe essere una stringa (&lt;code&gt;NSString&lt;/code&gt; in Objective-C), quindi possiamo ottenere il titolo così:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[[Optional
                        with:[dict objectForKey:@&amp;quot;title&amp;quot;]]

                       flatMap:^Optional*(id title) {
                         return [Optional with:[title isKindOfClass:[NSString class]] ? title : nil];
                       }]

                      flatMap:^Optional*(NSString* title) {
                        return [Optional with:title.length &amp;gt; 0 ? title : nil];
                      }]

                     getOrElse:^NSString*{
                       return @&amp;quot;NO TITLE&amp;quot;;
                     }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il primo &lt;code&gt;flatMap&lt;/code&gt; indica che l&amp;rsquo;oggetto &amp;ldquo;titolo&amp;rdquo; deve appartenere alla classe &lt;code&gt;NSString&lt;/code&gt;. Conviene astrarre questa operazione inserendola direttamente nel costruttore, perché l&amp;rsquo;applicheremo ogni volta per tutti i dati:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;+ (Optional *)with:(id)value as:(Class)valueClass
{
  if ([value isKindOfClass:valueClass])
  {
    return [Optional with:value];
  }
  return [Optional with:nil];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il secondo &lt;code&gt;flatMap:&lt;/code&gt; indica che se la stringa trovata ha lunghezza 0, considereremo il titolo come &amp;ldquo;sconosciuto&amp;rdquo;. In effetti questo step avrà l&amp;rsquo;effetto di &amp;ldquo;filtro&amp;rdquo;, perché lascerà &amp;ldquo;passare&amp;rdquo; solo le stringhe non vuote; considerando ciò, aggiungiamo un metodo &lt;code&gt;filter:&lt;/code&gt; alla classe &lt;code&gt;Optional&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.h

- (Optional*)filter:(BOOL(^)(id))filterBlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;///Optional.m

- (Optional*)filter:(BOOL (^)(id _Nonnull))filterBlock
{
  return [self flatMap:^Optional*(id value) {
    if (filterBlock(value))
    {
      return self;
    }
    else
    {
      return [Optional with:nil];
    }
  }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il metodo &lt;code&gt;filter:&lt;/code&gt; accetta come parametro un block che ritorna un &lt;code&gt;BOOL&lt;/code&gt; basato sul valore contenuto: internamente, &lt;code&gt;filter:&lt;/code&gt; chiamerà comunque &lt;code&gt;flatMap:&lt;/code&gt;, con un&amp;rsquo;espressione condizionale che verifichi se &lt;code&gt;filterBlock&lt;/code&gt; riesce o fallisce.&lt;/p&gt;

&lt;p&gt;Infine:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSString* title = [[[Optional  
                       with:[dict objectForKey:@&amp;quot;title&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     getOrElse:^NSString*{ return @&amp;quot;NO TITLE&amp;quot;; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi, nessuna espressione condizionale, e poche linee di codice, completamente dichiarative.&lt;/p&gt;

&lt;p&gt;Per quanto riguarda i parametri &lt;code&gt;rating&lt;/code&gt; e &lt;code&gt;year&lt;/code&gt; abbiamo bisogno di un &lt;code&gt;map&lt;/code&gt; che converta &lt;code&gt;NSString&lt;/code&gt; in &lt;code&gt;NSNumber&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* rating = [[[[Optional  
                         with:[dict objectForKey:@&amp;quot;rating&amp;quot;]
                         as:[NSString class]]

                        filter:^BOOL(NSString* string) {
                          return string.length &amp;gt; 0;
                        }]

                       map:^NSNumber*(NSString* stringValue) {
                         return [NSDecimalNumber decimalNumberWithString:stringValue];
                       }]

                      getOrElse:^NSNumber*{ return @0; }];
  movie.rating = rating;

  NSNumber* year = [[[[Optional
                       with:[dict objectForKey:@&amp;quot;year&amp;quot;]
                       as:[NSString class]]

                      filter:^BOOL(NSString* string) {
                        return string.length &amp;gt; 0;
                      }]

                     map:^NSNumber*(NSString* stringValue) {
                       return [NSDecimalNumber decimalNumberWithString:stringValue];
                     }]

                    getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Il parametro &lt;code&gt;lengthInMinutes&lt;/code&gt; è un po&amp;rsquo; complicato; dal JSON possiamo vedere che la sua rappresentazione è la seguente:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;&amp;quot;runtime&amp;quot;: [ 
    &amp;quot;142 min&amp;quot; 
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quindi ci aspettiamo un array, del quale siamo interessati solo al primo elemento (quindi l&amp;rsquo;array non deve essere vuoto), che deve essere una stringa; di questa stringa abbiamo bisogno solo della prima parte, rimuovendo &lt;code&gt;min&lt;/code&gt;. Fortunatamente abbiamo già tutti gli strumenti necessari per procedere:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[Optional
        with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
        as:[NSArray class]]

       flatMap:^Optional*(NSArray* array) {
         return [Optional with:[array firstObject]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In realtà manca qualcosa: il metodo &lt;code&gt;[array firstObject]&lt;/code&gt; ritorna il primo oggetto dell&amp;rsquo;array se questo ha almeno un elemento, oppure ritorna nil se l&amp;rsquo;array è vuoto: non c&amp;rsquo;è alcuna indicazione sul fatto che vogliamo che il primo elemento sia di tipo &lt;code&gt;NSString&lt;/code&gt;, quindi dobbiamo aggiungere uno step &lt;code&gt;filter&lt;/code&gt; per assicurarci che la classe dell&amp;rsquo;istanza trovata sia corretta. Quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ObjectiveC&#34;&gt;NSNumber* lengthInMinutes =
  [[[[[[[Optional
         with:[dict objectForKey:@&amp;quot;runtime&amp;quot;]
         as:[NSArray class]]

        flatMap:^id(NSArray* array) {
          return [Optional with:[array firstObject]];
        }]

       filter:^BOOL(id value) {
         return [value isKindOfClass:[NSString class]];
       }]

      map:^NSString*(NSString* string) {
        return [string
                stringByReplacingOccurrencesOfString:@&amp;quot; min&amp;quot;
                withString:@&amp;quot;&amp;quot;];
      }]

     filter:^BOOL(NSString* string) {
       return string.length &amp;gt; 0;
     }]

    map:^NSNumber*(NSString* stringValue) {
      return @([stringValue integerValue]);
    }]

   getOrElse:^NSNumber*{ return @0; }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come possiamo vedere, lavorando con la classe &lt;code&gt;Optional&lt;/code&gt;, aggiungere una condizione significa semplicemente &lt;strong&gt;aggiungere uno step&lt;/strong&gt; nella sequenza lineare di espressioni.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:356e4f51f7182f15c3c3e75bc317d5ff&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Implementare la classe &lt;code&gt;Optional&lt;/code&gt; in Objective-C ci ha permesso di parsare un JSON, cosa spesso difficile da mantenere e soggetta a errori, in un modo semplice e lineare. In realtà ci sono &lt;strong&gt;molti casi&lt;/strong&gt; in cui lavorare con gli &lt;em&gt;optionals&lt;/em&gt; ci può dare gli stessi vantaggi: componendo operazioni di tipo &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;flatMap&lt;/code&gt; e &lt;code&gt;filter&lt;/code&gt; possiamo esprimere il nostro intento in maniera chiara e leggibile. Ma tutto questo non riguarda solo il tipo &lt;code&gt;Optional&lt;/code&gt;: alcuni lettori avranno probabilmente notato che molti linguaggi (incluso Swift) permettono operazioni dell stesso tipo su liste e array, e il loro significato è identico: &lt;code&gt;map&lt;/code&gt; e &lt;code&gt;flatMap&lt;/code&gt;, in particolare, sono &lt;strong&gt;concetti generici&lt;/strong&gt; legati ai &lt;em&gt;monad&lt;/em&gt; (in effetti, anche il tipo &lt;code&gt;Array&lt;/code&gt; è un &lt;em&gt;monad&lt;/em&gt;), e riguarda la composizione dichiarativa di trasformazioni. Questo concetto è alla base della &lt;strong&gt;programmazione funzionale&lt;/strong&gt;, e penso ci siano molti motivi per applicare concetti simili ad ambienti più &lt;em&gt;object-oriented&lt;/em&gt;, perché aiuterebbero il programmatore a ragionare sul codice ed esprimere l&amp;rsquo;intento in maniera più dichiarativa.&lt;/p&gt;

&lt;p&gt;Il codice per la classe &lt;code&gt;Optional&lt;/code&gt; mostrata nell&amp;rsquo;articolo è reperibile su &lt;a href=&#34;https://gist.github.com/broomburgo/e318228a5f7d6a605e82&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>http://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/xcode-testing-in-pratica/&#34;&gt;In un precedente articolo&lt;/a&gt; abbiamo visto le impostazioni di base in Xcode per la scrittura dei &lt;strong&gt;test unitari&lt;/strong&gt;: abbiamo evidenziato inoltre &lt;strong&gt;l&amp;rsquo;importanza e l&amp;rsquo;utilità intrinseca dei test&lt;/strong&gt;, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; più avanzate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implementeremo uno &lt;strong&gt;Stub Object&lt;/strong&gt; in Swift;&lt;/li&gt;
&lt;li&gt;analizzeremo un altro caso di test &lt;em&gt;asincrono&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lo-stub-object:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Lo &lt;em&gt;Stub Object&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Uno &lt;em&gt;Stub Object&lt;/em&gt; (per il resto dell&amp;rsquo;articolo, &lt;em&gt;stub&lt;/em&gt;) rappresenta un&amp;rsquo;istanza di una certa classe, la quale &lt;em&gt;mima&lt;/em&gt; una vera classe presente nella nostra &lt;em&gt;code base&lt;/em&gt;:  l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio &lt;strong&gt;alcuni metodi possono essere sovrascritti&lt;/strong&gt; per poter fornire &lt;strong&gt;un determinato output&lt;/strong&gt; utile per i test. Nell&amp;rsquo;implementare uno &lt;em&gt;stub&lt;/em&gt; non è generalmente consentito modificare dettagli di logica interni relativi alla classe che stiamo mimando, ma &lt;strong&gt;è possibile sovrascrivere metodi pubblici&lt;/strong&gt;, in modo che essi ritornino i valori che vogliamo, oppure che svolgano una particolare procedura necessaria per i test. Tanto per fare un esempio pratico potremmo &lt;em&gt;stubbare&lt;/em&gt; una classe che ci fornisce la data precisa in un certo istante, in modo da ottenere una data diversa da usare nei test, oppure un client che chiede a un server delle informazioni su un utente, in modo da far ritonare al client &lt;em&gt;stub&lt;/em&gt; delle informazioni arbitrarie.&lt;/p&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; fanno parte di una classe di strumenti che sono usati nell&amp;rsquo;ambito dello &lt;em&gt;Unit Testing&lt;/em&gt; per verificare che determinati oggetti rispettino precisi &lt;strong&gt;contratti&lt;/strong&gt; stipulati tra essi: il classico articolo di Martin Fowler &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Mocks Aren&amp;rsquo;t Stubs&lt;/a&gt; è solitamente considerato un buon punto di riferimento per comprendere i possibili strumenti usati a tal scopo. L&amp;rsquo;idea è che, dal punto di vista dei nostri test unitari, un oggetto risulterà essere &lt;em&gt;correttamente implementato&lt;/em&gt; se avrà rispettato la sua parte del &lt;em&gt;contratto&lt;/em&gt; stipulato con altri oggetti, con la seguente conseguenza:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;se l&amp;rsquo;oggetto A è correttamente implementato e l&amp;rsquo;oggetto B rispetta il contratto stipulato con l&amp;rsquo;oggetto A, allora anche l&amp;rsquo;oggetto B è correttamente implementato&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; permettono di &lt;strong&gt;disaccoppiare le logiche di funzionamento degli oggetti&lt;/strong&gt; perché, se abbiamo verificato il corretto funzionamento dell&amp;rsquo;oggetto A (attraverso appropriati test unitari), possiamo usare uno &lt;em&gt;stub&lt;/em&gt; di tale oggetto per verificare il corretto funzionamento dell&amp;rsquo;oggetto B nei suoi confronti, eliminando qualsiasi dipendenza di B nei confronti della logica interna dell&amp;rsquo;oggetto A. L&amp;rsquo;obiettivo è scrivere quindi dei &lt;strong&gt;test veramente unitari&lt;/strong&gt; per l&amp;rsquo;oggetto B, anche se questo dipende dall&amp;rsquo;oggetto A. Il classico talk &lt;a href=&#34;https://vimeo.com/80533536&#34;&gt;Integration Tests are a scam&lt;/a&gt; di J.B. Rainsberger fornisce un punto di vista particolarmente &amp;ldquo;radicale&amp;rdquo; sull&amp;rsquo;argomento.&lt;/p&gt;

&lt;p&gt;Il classico caso in cui uno &lt;em&gt;stub&lt;/em&gt; risulta utile è quello del client che fa una richiesta al server: se la logica di implementazione del server è sotto il nostro controllo possiamo &lt;strong&gt;testare che il server rispetti il contratto con i suoi client&lt;/strong&gt; generando degli &lt;em&gt;stub&lt;/em&gt; di questi per ogni possibile richiesta; d&amp;rsquo;altra parte, per verificare che i client siano in grado di &lt;strong&gt;gestire correttamente ogni possibile risposta del server&lt;/strong&gt;, possiamo generare uno &lt;em&gt;stub&lt;/em&gt; del server che fornisca ogni possibile risposta: in questo modo possiamo testare in maniera disaccoppiata client e server.&lt;/p&gt;

&lt;h2 id=&#34;un-caso-d-uso-location-services:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Un caso d&amp;rsquo;uso: &lt;em&gt;Location Services&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Il caso d&amp;rsquo;uso che tratteremo è relativo ai &lt;strong&gt;servizi di localizzazione&lt;/strong&gt;, uno strumento frequentemente utilizzato dagli sviluppatori iOS e in generale da chi sviluppa su &lt;strong&gt;smartphone&lt;/strong&gt;: per tali sviluppatori, quello dei servizi di localizzazione è un tema molto importante, &lt;strong&gt;fonte di complessità e sfide&lt;/strong&gt; che caratterizzano tipicamente il mondo &lt;em&gt;mobile&lt;/em&gt;. Non è infatti possibile ottenere l&amp;rsquo;attuale posizione GPS in un preciso momento: l&amp;rsquo;ultima posizione GPS disponibile si basa su una regressione, effettuata dal sistema, dei dati ricevuti da diversi sensori - antenne wifi, cellulare e ovviamente GPS, e spesso anche i sensori di movimento - in diversi momenti; &lt;strong&gt;il sistema può inviare notifiche alla nostra app in qualsiasi momento&lt;/strong&gt;, ed essa deve essere in grado di &amp;ldquo;digerire&amp;rdquo; correttamente i dati ricevuti, interpretando anche eventuali errori. Scrivere dei test unitari per verificare che la nostra app geolocalizzata funzioni correttamente può presentare non poche difficoltà: non possiamo infatti affidarci ai &amp;ldquo;veri&amp;rdquo; sensori del dispositivo, perché probabilmente i test verranno eseguiti sul simulatore, oppure magari su un vero iPhone la cui ricezione GPS in un certo istante potrà essere più o meno buona, ma essa rappresenterà un solo caso possibile rispetto a tanti. Vogliamo essere in grado di &lt;strong&gt;testare ogni possibile risposta&lt;/strong&gt; del sistema GPS del dispositivo, dall&amp;rsquo;assenza totale di segnale al cambiamento frequente di posizione, alla &lt;strong&gt;mancata autorizzazione&lt;/strong&gt; da parte dell&amp;rsquo;utente per l&amp;rsquo;accesso ai servizi di localizzazione.&lt;/p&gt;

&lt;p&gt;Supponiamo ad esempio che una certa classe, diciamo un &lt;code&gt;UIViewController&lt;/code&gt;, esegua delle &lt;strong&gt;azioni che dipendono dalla posizione ricevuta&lt;/strong&gt;. L&amp;rsquo;idea è quella di testare che il nostro &lt;code&gt;UIViewController&lt;/code&gt; si comporti &amp;ldquo;bene&amp;rdquo; rispetto alle notifiche del sistema di localizzazione. Il progetto Xcode contenente il codice mostrato in questo articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/AsyncTestingStubbing&#34;&gt;GitHub&lt;/a&gt;: si consiglia di scaricare il progetto e tenerlo a riferimento per il resto dell&amp;rsquo;articolo.&lt;/p&gt;

&lt;p&gt;Invece di usare direttamente &lt;code&gt;CLLocationManager&lt;/code&gt; per ottenere la posizione GPS del dispositivo, implementeremo una semplice classe che fungerà da &lt;em&gt;wrapper&lt;/em&gt;, chiamata &lt;code&gt;LocationCoordinator&lt;/code&gt;: un&amp;rsquo;istanza di tale classe potrà essere configurata con due semplici funzioni &lt;code&gt;onUpdate&lt;/code&gt; e &lt;code&gt;onFailure&lt;/code&gt;, in modo da evitare l&amp;rsquo;implementazione dei vari metodi di callback del &lt;code&gt;protocol&lt;/code&gt; &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt;. L&amp;rsquo;idea è quella di passare un&amp;rsquo;istanza di &lt;code&gt;LocationCoordinator&lt;/code&gt; al nostro &lt;code&gt;UIViewController&lt;/code&gt;: quest&amp;rsquo;ultimo quindi imposterà le due funzioni di callback indicate sopra, in modo da modificare il suo stato e i dati mostrati all&amp;rsquo;utente.&lt;/p&gt;

&lt;p&gt;Di seguito è riportato il codice della classe &lt;code&gt;LocationCoordinator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import CoreLocation

public class LocationCoordinator: NSObject {
    
    public let locationManager: CLLocationManager
    
    public override init() {
        locationManager = CLLocationManager()
        super.init()
        locationManager.delegate = self
        locationManager.requestWhenInUseAuthorization()
    }
    
    private var updated: (CLLocation -&amp;gt; ())?
    public func onUpdate(value: CLLocation -&amp;gt; ()) {
        updated = value
    }
    
    private var failed: (NSError -&amp;gt; ())?
    public func onFailure(value: NSError -&amp;gt; ()) {
        failed = value
    }
}

extension LocationCoordinator: CLLocationManagerDelegate {
    
    public func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {
        let location = locations.last as! CLLocation
        if let updated = self.updated {
            updated(location)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didFailWithError error: NSError!) {
        if let failed = self.failed {
            failed(error)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
        switch status {
        case .AuthorizedWhenInUse:
            locationManager.startUpdatingLocation()
        default:
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la classe è configurata per richiedere l&amp;rsquo;autorizzazione a leggere la posizione GPS del dispositivo quando l&amp;rsquo;app è in uso, ma non sarà necessario fornire questa autorizzazione per i test: creeremo infatti uno &lt;em&gt;stub&lt;/em&gt; che genererà posizioni arbitrarie, senza usare i sensori di sistema. Si ricorda inoltre che usando iOS SDK &amp;gt;= 8.0, per usare i servizi di localizzazione sarà necessario inserire nel file Info.plist una chiave che descrive il motivo per il quale l&amp;rsquo;app chiede l&amp;rsquo;autorizzazione ad accedere a tali servizi:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/swift-testing-avanzato-stubbing-e-test-asincroni/locationUsageDescription.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sebbene l&amp;rsquo;aggiunta della chiave &lt;code&gt;NSLocationWhenIsUseUsageDescription&lt;/code&gt; non sia necessaria per eseguire i test, senza questa chiave l&amp;rsquo;app non potrà funzionare in iOS8 nel caso in cui provassimo ad avviarla normalmente.&lt;/p&gt;

&lt;p&gt;La classe di cui vogliamo testare il corretto funzionamento è indicata nel progetto con il nome di &lt;code&gt;LocationViewController&lt;/code&gt;, e il suo scopo è mostrare le attuali coordinate GPS dell&amp;rsquo;utente o mostrare un messaggio in caso di errore: un sua istanza è, in ogni instante, caratterizzata da un &lt;code&gt;LocationState&lt;/code&gt; che rappresenta in quale stato essa si trova rispetto alla ricerca della posizione GPS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum LocationState {
    case Searching
    case Found
    case Error(CLError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementiamo-i-test:4b7c206247a0a425bb1064c53b31df66&#34;&gt;Implementiamo i test&lt;/h2&gt;

&lt;p&gt;Per testare la classe verificheremo che, a seconda dei diversi possibili risultati ottenibili dalla ricerca della posizione GPS, un&amp;rsquo;istanza di essa &lt;strong&gt;aggiorni correttamente il suo stato attuale&lt;/strong&gt;. È quindi necessario fare in modo che un&amp;rsquo;istanza del &lt;code&gt;LocationCoordinator&lt;/code&gt; ignori le notifiche ricevute da &lt;code&gt;CLLocationManager&lt;/code&gt;, in modo da forzare posizioni ed errori comodi per i nostri test; per farlo dichiariamo una sottoclasse di &lt;code&gt;LocationCoordinator&lt;/code&gt; chiamata &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt; che modifichi la &lt;em&gt;parent class&lt;/em&gt; nel seguente modo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ignora le notifiche del &lt;code&gt;locationManager&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locationManager.stopUpdatingLocation()
locationManager.delegate = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dichiara 4 funzioni per forzare posizione GPS e/o errori:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forceLocation
forceError
forceRandomDelayedLocations
forceDelayedErrorLocationUnknown
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ciascuna di queste funzioni genera le stesse notifiche che normalmente genererebbe &lt;code&gt;CLLocationManager&lt;/code&gt;. Le prime due funzioni, &lt;code&gt;forceLocation&lt;/code&gt; e &lt;code&gt;forceError&lt;/code&gt; forzano immediatamente una certa posizione GPS o un certo errore, mentre la funzione &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; genera una serie di posizioni casuali dopo un certo ritardo e a intervalli regolari, e la funzione &lt;code&gt;forceDelayedErrorLocationUnknown&lt;/code&gt; forza un errore del tipo &lt;code&gt;.LocationUnknown&lt;/code&gt; dopo un certo ritardo.&lt;/p&gt;

&lt;p&gt;Prima di procedere con i test osserviamo che nel file &lt;code&gt;AsyncTestingStubbingTests.swift&lt;/code&gt; c&amp;rsquo;è una sezione &lt;em&gt;utility&lt;/em&gt; nella quale sono implementate alcune funzioni comode per &lt;strong&gt;rendere  il codice dei test più espressivo&lt;/strong&gt;. Ad esempio la funzione &lt;code&gt;mainViewController&lt;/code&gt; ritorna l&amp;rsquo;istanza del LocationViewController utilizzata nell&amp;rsquo;interfaccia grafica nell&amp;rsquo;app. Il &lt;em&gt;testing framework&lt;/em&gt; integrato in Xcode è chiamato &lt;code&gt;XCTest&lt;/code&gt;, e per quanto adeguatamente completo nelle sue funzionalità, esso è principalmente basato su funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt; che verificano che una qualche condizione sia vera, e se non lo è stampano in console un messaggio di errore passato alla stessa funzione &lt;code&gt;XCTAssert&lt;/code&gt; nel momento in cui essa è chiamata: questo può portare alla scrittura di &lt;strong&gt;test verbosi e poco espressivi&lt;/strong&gt;. Ci sono diverse librerie facilmente integrabili nei progetti Xcode che semplificano la scrittura dei nostri &lt;em&gt;assert&lt;/em&gt;, come ad esempio &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt;, ma come si può vedere dalle poche funzioni di utility implementate nel progetto associato a questo articolo, basta poco per migliorare consistentemente la leggibilità dei nostri test.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo procedere all&amp;rsquo;implementazione dei test. Le funzioni &lt;code&gt;testLocation&lt;/code&gt; e &lt;code&gt;testError&lt;/code&gt; testano semplicemente che lo stato del &lt;code&gt;mainViewController&lt;/code&gt; sia corretto prima e dopo la generazione di una posizione GPS e di un errore arbitrari. Tuttavia questi test non permettono di rappresentare correttamente un caso d&amp;rsquo;uso tipico, perché &lt;strong&gt;le notifiche sulla posizione GPS posso arrivare in qualsiasi momento&lt;/strong&gt;, e il &lt;code&gt;LocationViewController&lt;/code&gt; deve essere in grado di &lt;em&gt;reagire&lt;/em&gt; alle notifiche nel momento in cui queste si presentano. Per simulare la cosa useremo due test &lt;em&gt;asincroni&lt;/em&gt;, cioè test il cui risultato non è ottenuto immediatamente, ma dopo un certo tempo: l&amp;rsquo;idea è quella di &amp;ldquo;mettere in pausa&amp;rdquo; i test per un certo numero di secondi, finché non si verifica una certa condizione oppure non scade il tempo: in quest&amp;rsquo;ultimo caso il test verrà considerato &lt;strong&gt;fallito&lt;/strong&gt; da &lt;code&gt;XCTest&lt;/code&gt; perché la condizione attesa non si è verificata entro il tempo richiesto.&lt;/p&gt;

&lt;p&gt;Riportiamo ad esempio il codice della funzione &lt;code&gt;testDelayedLocation&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDelayedLocation() {
        if let vc = mainViewController() {
            let locationExpectation = expectationWithDescription(&amp;quot;locationExpectation&amp;quot;)
            let coordinator = STUB_LocationCoordinator()
            vc.showLocationWithCoordinator(coordinator)
            vc.locationState.assertState(.Searching)
            coordinator.forceRandomDelayedLocations(0.25, times:3)
            after(0.5) {
                vc.locationState.assertState(.Found)
                after(0.25) {
                    vc.locationState.assertState(.Found)
                    locationExpectation.fulfill()
                }
            }
            vc.locationState.assertState(.Searching)
            waitForExpectationsWithTimeout(1, handler: nil)
        }
        else {
            fail(&amp;quot;this will never happen&amp;quot;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione di utility &lt;code&gt;after&lt;/code&gt; semplicemente esegue del codice dopo un certo numero di secondi: in base all&amp;rsquo;implementazione di &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; presente in &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt;, il &lt;code&gt;LocationViewController&lt;/code&gt; dovrebbe  ricevere alcune posizioni GPS a intervalli regolari dopo un certo ritardo, e per verificarlo inseriamo due &lt;em&gt;assert&lt;/em&gt;, dopo mezzo secondo e poi ancora un quarto di secondo. Per realizzare il test asincrono  definiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt;, quindi una &amp;ldquo;aspettativa&amp;rdquo;, chiamata &lt;code&gt;locationExpectation&lt;/code&gt;: in coda al codice di test chiamiamo la funzione &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; che fa continuare la funzione di test - senza che essa &lt;em&gt;ritorni&lt;/em&gt; - fino alla &amp;ldquo;realizzazione&amp;rdquo; delle aspettative, tenendo conto di un certo tempo di timeout. Quindi, per &amp;ldquo;realizzare&amp;rdquo; un&amp;rsquo;aspettativa, chiamiamo la funzione &lt;code&gt;fulfill&lt;/code&gt; su &lt;code&gt;locationExpectation&lt;/code&gt;, ma solo dopo aver verificato che lo stato del &lt;code&gt;LocationViewController&lt;/code&gt; sia quello corretto.&lt;/p&gt;

&lt;p&gt;Possiamo estendere ulteriormente la &lt;em&gt;test suite&lt;/em&gt; implementando altri test che simulano ogni tipo di errore possibile, oppure che simulano una situazione in cui posizioni GPS e errori si alternano: una volta compresa la struttura di base per realizzare &lt;em&gt;stub&lt;/em&gt; e test asincroni sarà facile migliorare la &lt;a href=&#34;http://engineering.facile.it/software-testing-coverage-vs-efficacia/&#34;&gt;coverage&lt;/a&gt; dei nostri test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type First Development in Swift</title>
      <link>http://engineering.facile.it/blog/ita/type-first-development-in-swift/</link>
      <pubDate>Tue, 05 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/type-first-development-in-swift/</guid>
      <description>

&lt;p&gt;Con &lt;em&gt;Type First Development&lt;/em&gt; può intendersi un approccio allo sviluppo di nuove funzionalità o moduli di un software partendo dai &lt;strong&gt;tipi&lt;/strong&gt; di dati coinvolti: non si tratta quindi di un pattern o una pratica codificata, ma solo di &lt;strong&gt;un possibile punto di partenza&lt;/strong&gt; per iniziare il ragionamento. Ragionando esclusivamente sui tipi, prima ancora di pensare alle singole specifiche implementazioni dei vari blocchi di codice, è possibile costruire più facilmente una mappa dei vari di flussi di dati che attraversano il nostro software, e verificare immediatamente se stiamo scrivendo qualcosa di sensato, solido ed adeguatamente estendibile.&lt;/p&gt;

&lt;p&gt;Ragionare sui tipi di dato è un classico approccio usato nel paradigma di programmazione noto come &lt;a href=&#34;http://en.wikipedia.org/wiki/Functional_programming&#34;&gt;&lt;em&gt;programmazione funzionale&lt;/em&gt;&lt;/a&gt;, e il presente articolo adotta tale paradigma in maniera piuttosto pura.&lt;/p&gt;

&lt;h2 id=&#34;indice:9546cc279181b22e90a8ccdde798a866&#34;&gt;Indice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#il-type-system-di-swift&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#costruiamo-un-form-il-tipo-field&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#funzioni-generiche-e-composizione-funzionale&#34;&gt;Funzioni generiche e composizione funzionale&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#il-tipo-form&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;Modifica di un form e ricerca di un campo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusione&#34;&gt;Conclusione&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a name=&#34;il-type-system-di-swift&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-type-system-di-swift:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift&lt;/h2&gt;

&lt;p&gt;Il linguaggio &lt;strong&gt;Swift&lt;/strong&gt;, usato nello sviluppo di software per Mac OSX e iOS, si presta molto bene all&amp;rsquo;approccio basato sui tipi illustrato in questo articolo, a causa di due particolari caratteristiche del linguaggio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Type_system#Static_type-checking&#34;&gt;staticamente tipizzato&lt;/a&gt;, cioè ogni parametro, costante o variabile che sia, è caratterizzato da uno specifico tipo, e se una funzione vuole in ingresso un valore di un certo tipo, chiamare la funzione con un valore di un altro tipo risulterà in un errore di compilazione;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Swift è &lt;a href=&#34;http://en.wikipedia.org/wiki/Strong_and_weak_typing&#34;&gt;fortemente tipizzato&lt;/a&gt;, cioè non esiste alcuna conversione implicita tra i tipi: ad esempio, in Swift &lt;code&gt;1&lt;/code&gt; è diverso da &lt;code&gt;true&lt;/code&gt; e i due valori non posso essere usati indifferentemente nello stesso contesto;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il &lt;em&gt;type system&lt;/em&gt; di Swift è molto rigido, ma è in tale rigore che risiede la sua potenza: usare tipi errati provoca un errore di compilazione, e manipolando adeguatamente i tipi di dato nella costruzione di funzioni è possibile verificare gran parte della correttezza del proprio codice già nella fase di compilazione, evitando potenziali problemi in fase di esecuzione.&lt;/p&gt;

&lt;p&gt;Swift usa molti termini ereditati da C, come &lt;code&gt;struct&lt;/code&gt; e &lt;code&gt;enum&lt;/code&gt;, ma il loro significato è completamente diverso, ad esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;una &lt;code&gt;struct&lt;/code&gt; in Swift può dichiarare metodi ed essere estesa con interfacce;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum&lt;/code&gt; in Swift è ciò che in altri linguaggi è spesso chiamato &amp;ldquo;sum type&amp;rdquo; o &amp;ldquo;&lt;a href=&#34;http://en.wikipedia.org/wiki/Tagged_union&#34;&gt;tagged union&lt;/a&gt;&amp;rdquo;, e a ogni &lt;code&gt;case&lt;/code&gt; possono essere assegnati dei valori associati, ad esempio &lt;code&gt;case Text(String)&lt;/code&gt; rappresenta il caso &lt;code&gt;Text&lt;/code&gt; e ha un valore &lt;code&gt;String&lt;/code&gt; associato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per illustrare un modo per applicare l&amp;rsquo;approccio &lt;em&gt;Type First&lt;/em&gt; nello sviluppo in Swift inizieremo a scrivere una libreria per gestire &lt;strong&gt;form&lt;/strong&gt;, quindi liste strutturate di campi valorizzati, utili per raccogliere dati degli utenti tramite moduli da compilare, per effettuare sondaggi o inserire i parametri di query a un server.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;costruiamo-un-form-il-tipo-field&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;costruiamo-un-form-il-tipo-field:9546cc279181b22e90a8ccdde798a866&#34;&gt;Costruiamo un form: il tipo &lt;em&gt;Field&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Un possibile tipo di dato da cui partire è &lt;strong&gt;Field&lt;/strong&gt;, il campo, cioè il mattone costruttivo di base di un form.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: String
    let name: String
    let value: String
    let visible: Bool
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Questa definizione di Field è molto basilare, il ché non è un problema nelle prime fasi dello sviluppo, ma &lt;strong&gt;sembra poco estendibile&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt; è definito come &lt;code&gt;String&lt;/code&gt; - ad esempio testo inserito dall&amp;rsquo;utente - ma un campo potrebbe contenere altri tipi di valori, ad esempio un checkbox si/no, oppure un preciso valore selezionato da una lista;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;visibile&lt;/code&gt; è definito come &lt;code&gt;Bool&lt;/code&gt;, e vuole indicare se il campo è visibile oppure nascosto, ma se volessimo assegnare altri valori di visibilità, ad esempio &amp;ldquo;evidenziato&amp;rdquo; o &amp;ldquo;oscurato&amp;rdquo; dovremmo aggiungere altri parametri &lt;code&gt;Bool&lt;/code&gt;, che alla fine potrebbero andare in contrasto l&amp;rsquo;uno con l&amp;rsquo;altro;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo risolvere immediatamente il problema, &lt;strong&gt;senza cadere nell&amp;rsquo;eccessiva ottimizzazione preventiva&lt;/strong&gt;, semplicemente modificando il tipo di &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visible&lt;/code&gt; con degli &lt;code&gt;enum&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum FieldValue: Equatable {
    case Text(String)
    case Empty
}

func == (lhs: FieldValue, rhs: FieldValue) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Empty, .Empty):
        return true
    case (.Text(let lhsText), .Text(let rhsText)):
        return lhsText == rhsText
    default:
        return false
    }
}

enum FieldVisibility: Equatable {
    case Visible
    case Hidden
}

func == (lhs: FieldVisibility, rhs: FieldVisibility) -&amp;gt; Bool {
    switch (lhs, rhs) {
    case (.Visible, .Visible), (.Hidden, .Hidden):
        return true
    default:
        return false
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo fatto adottare il protocollo &lt;code&gt;Equatable&lt;/code&gt; a entrambi i tipi, in modo da poter confrontare &lt;code&gt;value&lt;/code&gt; e &lt;code&gt;visibility&lt;/code&gt; di due campi per verificare se sono uguali: il vantaggio degli &lt;code&gt;enum&lt;/code&gt; è che &lt;strong&gt;possiamo facilmente aggiungere nuovi casi&lt;/strong&gt; senza rompere il codice esistente, ci basterà gestire i nuovi &lt;code&gt;case&lt;/code&gt; via via che vengono aggiunti.&lt;/p&gt;

&lt;p&gt;Un&amp;rsquo;altra piccola modifica utile corrisponde a ridefinire il tipo del parametro &lt;code&gt;id&lt;/code&gt;: a tale parametro deve essere assegnata &lt;strong&gt;una chiave univoca&lt;/strong&gt;, diversa per ogni campo, quindi può convenire definire un tipo &lt;code&gt;UniqueKey&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias UniqueKey = String
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift, la keyword &lt;code&gt;typealias&lt;/code&gt; ci permette di definire un &lt;em&gt;alias&lt;/em&gt; di un tipo, cioè un termine che corrisponde esattamente a quel tipo, e permette di:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;migliorare la leggibilità&lt;/strong&gt;, la chiarezza e la compattezza del codice;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;facilitare la manipolazione dei tipi&lt;/strong&gt;, come vedremo a breve;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ogni volta in cui una funzione richiederà &lt;code&gt;UniqueKey&lt;/code&gt; sapremo che in quel campo sarà necessario inserire una stringa univoca, che identifica un particolare campo.&lt;/p&gt;

&lt;p&gt;Definiamo nuovamente &lt;code&gt;Field&lt;/code&gt; incorporando i nuovi tipi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Field {
    let id: UniqueKey    
    let name: String
    let value: FieldValue
    let visibility: FieldVisibility
    init (_ id: Key, _ name: String, _ value: FieldValue, _ visibility: FieldVisibility) {
        self.id = id
        self.name = name
        self.value = value
        self.visibility = visibility
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Abbiamo aggiunto anche un costruttore di convenienza che ci permetterà di creare un &lt;code&gt;Field&lt;/code&gt; semplicemente passando i 4 dati richiesti.&lt;/p&gt;

&lt;p&gt;&lt;a name=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modificare-un-campo-tipi-di-funzione-come-tipi-di-dato:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modificare un campo: tipi di funzione come tipi di dato&lt;/h2&gt;

&lt;p&gt;La prima e più semplice operazione che vogliamo poter effettuare su &lt;code&gt;Field&lt;/code&gt; è quella di modificarlo in qualche modo: ogni operazione di questo tipo, in Swift, può essere indicata con &lt;code&gt;Field -&amp;gt; Field&lt;/code&gt;, cioè una trasformazione che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e produce un &lt;code&gt;Field&lt;/code&gt; in uscita:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChange = Field -&amp;gt; Field
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;operatore &lt;code&gt;-&amp;gt;&lt;/code&gt; ha lo stesso significato che ha già in &lt;a href=&#34;http://en.wikipedia.org/wiki/Haskell_(programming_language&#34;&gt;Haskell&lt;/a&gt;): definisce il tipo di una funzione che prende in ingresso un dato del tipo indicato a sinistra dell&amp;rsquo;operatore, e ritorna un dato del tipo indicato a destra dell&amp;rsquo;operatore (in questo caso entrambi i dati sono di tipo &lt;code&gt;Field&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;È da evidenziare che &lt;code&gt;FieldChange&lt;/code&gt; non rappresenta un tipo di &amp;ldquo;dato&amp;rdquo; in senso stretto, ma &lt;strong&gt;un tipo di &amp;ldquo;funzione&lt;/strong&gt;&amp;ldquo;: in effetti, definendo &lt;code&gt;FieldChange&lt;/code&gt;, possiamo trattare le funzioni di quel tipo come se fossero dati.&lt;/p&gt;

&lt;p&gt;Per fare un esempio potremmo definire la funzione &lt;code&gt;setVisibility&lt;/code&gt;, che prende in ingresso un valore di &lt;code&gt;FieldVisibility&lt;/code&gt; e ritorna, appunto, un &lt;code&gt;FieldChange&lt;/code&gt;, cioè un&amp;rsquo;altra funzione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibility (visibility: FieldVisibility) -&amp;gt; FieldChange {
    return { field in
        return Field (
            field.id,
            field.name,
            field.value,
            visibility
        )
    }
}

/// alcuni esempi
let setHidden = setVisibility(.Hidden)
let visibleField1 = Field (&amp;quot;&amp;quot;,&amp;quot;&amp;quot;, .Empty, .Visible)
let isTrue1 = visibleField1.visibility == .Visible
let hiddenField1 = setHidden(visibleField1)
let isTrue2 = hiddenField1.visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Negli esempi mostrati, &lt;code&gt;setHidden&lt;/code&gt; è una funzione ma dal punto di vista sintattico è indistinguibile da un qualsiasi altro valore, e il suo tipo (cioè &lt;code&gt;FieldChange&lt;/code&gt;) è dedotto dal compilatore di Swift in base alla definizione della funzione.&lt;/p&gt;

&lt;p&gt;Una funzionalità che vogliamo certamente introdurre nella libreria corrisponde al poter operare una trasformazione su un campo in base a un qualche parametro definito in un altro campo: ad esempio, un particolare campo mostra un check che permette di mostrare/nascondere altri campi. Definiamo quindi un nuovo tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldChangeGenerator = Field -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è il tipo di una funzione dalla quale otteniamo, in base allo stato un certo campo origine, una certa trasformazione di tipo &lt;code&gt;FieldChange&lt;/code&gt;, cioè qualcosa che prende un &lt;code&gt;Field&lt;/code&gt; in ingresso e ritorna un &lt;code&gt;Field&lt;/code&gt; in uscita: si tratta quindi di una funzione che ritorna un&amp;rsquo;altra funzione, di tipo diverso. Vorremmo ad esempio poter scrivere una funzione del tipo &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, che imposta un valore di visibilità in base allo stato di un campo origine: ok, ma quale valore di visibilità? Dipende dal campo origine, e possiamo risolvere il problema definendo un nuovo tipo di funzione, che prende in ingresso un campo, e ritorna un valore di visibilità:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition = Field -&amp;gt; FieldVisibility
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La nostra funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt; semplicemente prenderà ingresso un dato di tipo &lt;code&gt;FieldCondition&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition) -&amp;gt; FieldChangeGenerator {
    return { origin in
        let newVisibility = condition(origin)
        return setVisibility(newVisibility)
    }
}

/// alcuni esempi

let setVisibleIfNotEmpty = setVisibilityIfOrigin { field in
    switch field.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
}

let nonEmptyField = Field (&amp;quot;&amp;quot;, &amp;quot;&amp;quot;, .Text(&amp;quot;something&amp;quot;), .Visible)

let anotherVisibleField = setVisibleIfNotEmpty(nonEmptyField)(invisibleField)

let isTrue3 = anotherVisibleField.visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;funzioni-generiche-e-composizione-funzionale&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;funzioni-generiche-e-composizione-funzionale:9546cc279181b22e90a8ccdde798a866&#34;&gt;Funzioni generiche e composizione funzionale&lt;/h2&gt;

&lt;p&gt;In realtà la nostra &lt;code&gt;FieldCondition&lt;/code&gt; sembra essere un po&amp;rsquo; limitata: ritorna un valore di &lt;code&gt;FieldVisibility&lt;/code&gt;, mentre una vera &lt;em&gt;condition&lt;/em&gt; &lt;strong&gt;dovrebbe ritornare un valore generico&lt;/strong&gt;, a seconda dei casi: ad esempio, potrebbe cambiare il &lt;strong&gt;valore&lt;/strong&gt; di un campo bersaglio in base allo stato di un campo origine. L&amp;rsquo;ideale sarebbe scrivere qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCondition&amp;lt;T&amp;gt; = Field -&amp;gt; T
/// errore di compilazione!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sfortunatamente in Swift non è possibile scrivere dei &lt;code&gt;typealias&lt;/code&gt; generici, ma possiamo facilmente aggirare l&amp;rsquo;ostacolo costruendo una &lt;code&gt;struct&lt;/code&gt; generica che contiene un solo parametro, al quale è assegnata una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct FieldCondition&amp;lt;T&amp;gt; {
    let apply: Field -&amp;gt; T
    init(_ apply: Field -&amp;gt; T) {
        self.apply = apply
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se prima abbiamo scritto semplicemente una funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;, l&amp;rsquo;idea è riuscire ora a scrivere &lt;strong&gt;una funzione generica&lt;/strong&gt; &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; che ritorna un &lt;code&gt;FieldChangeGenerator&lt;/code&gt; che trasforma un campo bersaglio rispetto a un certo parametro, definito in base allo stato di un campo origine: come scrivere questa funzione? &lt;strong&gt;Ragioniamo sui tipi&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FieldCondition&amp;lt;T&amp;gt;&lt;/code&gt; è un contenitore per una funzione di tipo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChangeGenerator&lt;/code&gt; è un alias per &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;per completare la catena abbiamo bisogno di una trasformazione del tipo &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; perché unendo &lt;code&gt;Field -&amp;gt; T&lt;/code&gt; e &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt; otteniamo appunto &lt;code&gt;Field -&amp;gt; FieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Possiamo scrivere quindi la funzione generica di cui sopra:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setTargetIfOrigin&amp;lt;T&amp;gt; (condition: FieldCondition&amp;lt;T&amp;gt;, generate: T -&amp;gt; FieldChange) -&amp;gt; FieldChangeGenerator {
    return { field in
        return generate(condition.apply(field))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se tutto sembra molto astratto è perché &lt;strong&gt;lo è&lt;/strong&gt;: stiamo gradualmente costruendo degli strumenti di manipolazione dei dati (e delle funzioni, che sono anch&amp;rsquo;esse dati) operando su astrazioni successive.&lt;/p&gt;

&lt;p&gt;Nella funzione &lt;code&gt;setTargetIfOrigin&amp;lt;T&amp;gt;&lt;/code&gt; c&amp;rsquo;è un parametro &lt;code&gt;generate&lt;/code&gt; che è definito come &lt;code&gt;T -&amp;gt; FieldChange&lt;/code&gt;: cosa è &lt;code&gt;T&lt;/code&gt;? È semplicemente lo stesso tipo di dato con il quale viene passata la condizione in &lt;code&gt;condition&lt;/code&gt;; se passiamo una condizione sulla visibilità, ad esempio, &lt;code&gt;T&lt;/code&gt; sarà &lt;code&gt;FieldVisibility&lt;/code&gt;: &lt;strong&gt;una funzione generica si specializza nel momento in cui è definito il tipo concreto da assegnare ai tipi generici&lt;/strong&gt;. Volendo fare un esempio concreto, possiamo ridefinire la funzione &lt;code&gt;setVisibilityIfOrigin&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func setVisibilityIfOrigin (condition: FieldCondition&amp;lt;FieldVisibility&amp;gt;) -&amp;gt; FieldChangeGenerator {
    return setTargetIfOrigin (condition) { visibility in setVisibility(visibility) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione chiama &lt;code&gt;setTargetIfOrigin&lt;/code&gt;, passando una condizione del tipo &lt;code&gt;FieldCondition&amp;lt;FieldVisibility&amp;gt;&lt;/code&gt;: il secondo parametro dovrà essere quindi una funzione del tipo &lt;code&gt;FieldVisibility -&amp;gt; FieldChange&lt;/code&gt;, e possiamo usare la funzione &lt;code&gt;setVisibility&lt;/code&gt; definita prima. Vediamo qualche altro esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let setVisibleIfNotEmpty = setVisibilityIfOrigin (FieldCondition { origin in
    switch origin.value {
    case .Empty:
        return .Hidden
    default:
        return .Visible
    }
})

let copyValue = setTargetIfOrigin (FieldCondition { $0.value}) { value in
    return { target in
        return Field(target.id,target.name,value,target.visibility)
    }
}

let field1 = Field(&amp;quot;field1&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;1&amp;quot;),.Visible)
let field2 = Field(&amp;quot;field2&amp;quot;,&amp;quot;&amp;quot;,.Text(&amp;quot;2&amp;quot;),.Visible)

let newField1 = copyValue(field2)(field1)

let isTrue4 = newField1.value == .Text(&amp;quot;2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Può essere interessante spendere qualche parola per la funzione &lt;code&gt;copyValue&lt;/code&gt; definita nell&amp;rsquo;esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la condizione è chiaramente del tipo &lt;code&gt;FieldCondition&amp;lt;FieldValue&amp;gt;&lt;/code&gt; perché la &lt;em&gt;closure&lt;/em&gt; passata ritorna il &lt;code&gt;value&lt;/code&gt; del campo;&lt;/li&gt;
&lt;li&gt;nella seconda &lt;em&gt;closure&lt;/em&gt; passata, il valore è usato per costruire un nuovo campo, uguale al bersaglio tranne proprio per quel valore;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quindi &lt;code&gt;copyValue&lt;/code&gt;, che ricordiamo è di tipo &lt;code&gt;FieldChangeGenerator&lt;/code&gt;, è una trasformazione che prende il valore di un campo origine e lo assegna a un campo bersaglio.&lt;/p&gt;

&lt;p&gt;Nel caso in cui avessimo una serie di campi e volessimo applicare una certa trasformazione a un solo campo particolare, avremmo bisogno di un check sul campo bersaglio. Come al solito, pensiamo prima al &lt;strong&gt;tipo&lt;/strong&gt; di questo check: sarà qualcosa che prende un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un altro &lt;code&gt;FieldChange&lt;/code&gt;, che potrebbe essere uguale a quello in ingresso, oppure diverso in base a una certa condizione applicata al campo bersaglio.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldCheck = FieldChange -&amp;gt; FieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Per quanto riguarda la condizione, possiamo usare lo stesso FieldCondition&lt;T&gt; di prima, ma in questo caso lo specializzeremo direttamente in &lt;code&gt;FieldCondition&amp;lt;Bool&amp;gt;&lt;/code&gt; perché quello che ci interessa sapere è se un certo campo bersaglio è interessato oppure no da una certa trasformazione.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldConditionBool = FieldCondition&amp;lt;Bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Definiamo quindi una funzione &lt;code&gt;checkTarget&lt;/code&gt; che prende in ingresso una condizione, e ritorna un &lt;code&gt;FieldCheck&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func checkTarget (condition: FieldConditionBool) -&amp;gt; FieldCheck {
    return { change in
        return { field in
            if condition.apply(field) {
                return change(field)
            }
            else {
                return field
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nel definire &lt;code&gt;checkTarget&lt;/code&gt; possiamo vedere un altro caso in cui ragionare solo sui tipi ci aiuta a capire cosa poi dobbiamo effettivamente fare nel codice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;la funzione deve ritornare un dato di tipo &lt;code&gt;FieldCheck&lt;/code&gt;, che è una funzione che prende in ingresso un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, quindi la prima riga della funzione è appunto &lt;code&gt;return { change in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldCheck&lt;/code&gt; è una funzione che ritorna un dato di tipo &lt;code&gt;FieldChange&lt;/code&gt;, che come definito prima corrisponde a una funzione che prende in ingresso un &lt;code&gt;Field&lt;/code&gt;, quindi la seconda riga è &lt;code&gt;return { field in&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FieldChange&lt;/code&gt; deve ritornare un &lt;code&gt;Field&lt;/code&gt;, ma a questo punto possiamo applicare la nostra condizione sul campo in ingresso: se la condizione è verificata allora ritorniamo il campo trasformato, mentre se non lo è &amp;ldquo;facciamo uscire&amp;rdquo; il campo esattamente come è &amp;ldquo;entrato&amp;rdquo;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Come si può vedere, abbiamo iniziato a implementare funzioni ragionando quasi esclusivamente sui tipi coinvolti. Vediamo alcuni esempi:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func ifTargetId (id: UniqueKey) -&amp;gt; FieldCheck {
    return checkTarget (FieldCondition { $0.id == id })
}

let visibleField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field1)
let hiddenField = ifTargetId(&amp;quot;field2&amp;quot;)(setHidden)(field2)

let isTrue5 = visibleField.visibility == .Visible
let isTrue6 = hiddenField.visibility == .Hidden

let fields = [field1,field2]
let newFields = fields.map(ifTargetId(&amp;quot;field2&amp;quot;)(setHidden))

let isTrue7 = newFields[0].visibility == .Visible
let isTrue8 = newFields[1].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;il-tipo-form&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;il-tipo-form:9546cc279181b22e90a8ccdde798a866&#34;&gt;Il tipo &lt;em&gt;Form&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Abbiamo implementato quindi alcuni strumenti per manipolare i singoli campi: a questo punto proviamo a unire il tutto definendo un &lt;code&gt;Form&lt;/code&gt; come contenitore strutturato di campi, insieme ad alcune funzioni di manipolazione. Intanto &lt;strong&gt;pensiamo al tipo da assegnare al nostro form&lt;/strong&gt;: una possibilità è quella di definire alcuni blocchi costruttivi che ne descrivono la struttura:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// sezione: è una semplice lista di campi
struct Section {
    let fields: [Field]
}

/// step: un gruppo di sezioni, ad esempio una pagina
struct Step {
    let sections: [Section]
}

/// form: un insieme di pagine
struct Form {
    let steps: [Step]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono però due problemi con questo approccio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stiamo prematuramente fornendo al nostro form &lt;strong&gt;una struttura rigida&lt;/strong&gt;: se in futuro decidessimo di voler creare una sottostruttura rispetto a &lt;code&gt;Section&lt;/code&gt; sarebbe probabilmente molto complesso modificare il tutto;&lt;/li&gt;
&lt;li&gt;nello scrivere le logiche di ricerca e manipolazione dei campi ci ritroveremmo a dover gestire le &lt;code&gt;struct&lt;/code&gt; appena definite: stiamo quindi automaticamente &lt;strong&gt;accoppiando&lt;/strong&gt; un particolare modello di dati con la logica di manipolazione dei form, che &lt;strong&gt;dovrebbero essere adattabili a più modelli, senza cambiare la logica&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per evitare questi problemi gli approcci possibili sono molti: un&amp;rsquo;opzione, ad esempio, è quella definire un tipo di dato corrispondente a un contenitore &lt;em&gt;ricorsivo&lt;/em&gt; per un valore generico, che chiameremo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Un valore di tipo &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; definisce due casi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;branch&lt;/em&gt;, cioè una lista di valori di tipo T;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;root&lt;/em&gt;, cioè una lista di altri &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;enum Node&amp;lt;T&amp;gt; {
    case Branch([T])
    case Root([Node&amp;lt;T&amp;gt;])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possiamo quindi definire un &lt;code&gt;Form&lt;/code&gt; come una versione specializzata di &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; dove &lt;code&gt;T&lt;/code&gt; è &lt;code&gt;Field&lt;/code&gt;, e definiremo un paio di funzioni di convenienza per generare un &lt;em&gt;branch&lt;/em&gt; di &lt;code&gt;Field&lt;/code&gt; o una &lt;em&gt;root&lt;/em&gt; di &lt;code&gt;Form&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias Form = Node&amp;lt;Field&amp;gt;

func branch (fields: [Field]) -&amp;gt; Form {
    return Node.Branch(fields)
}

func root (nodes: [Form]) -&amp;gt; Form {
    return Node.Root(nodes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;modifica-di-un-form-e-ricerca-di-un-campo&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;modifica-di-un-form-e-ricerca-di-un-campo:9546cc279181b22e90a8ccdde798a866&#34;&gt;Modifica di un form e ricerca di un campo&lt;/h2&gt;

&lt;p&gt;Come accadeva per &lt;code&gt;Field&lt;/code&gt;, la prima operazione che vogliamo poter effettuare su &lt;code&gt;Form&lt;/code&gt; è quella modificarlo; definiamo quindi il tipo &lt;code&gt;FormChange&lt;/code&gt; in maniera a simile a come avevamo definito &lt;code&gt;FieldChange&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FormChange = Form -&amp;gt; Form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Supponiamo ad esempio di avere un form, e voler applicare una modifica a un campo presente nel form, ottenendo un nuovo form con il campo modificato: abbiamo bisogno di una funzione che potremmo chiamare &lt;code&gt;changeFromFieldChange&lt;/code&gt; che prende in ingresso un &lt;code&gt;FieldChange&lt;/code&gt; e ritorna un &lt;code&gt;FormChange&lt;/code&gt;; grazie alla struttura ricorsiva del tipo &lt;code&gt;Form&lt;/code&gt; definito, possiamo scrivere in poche righe una funzione che attraversa un form nei suoi vari livelli e lo ricostruisce applicando la modifica passata in ingresso a ogni campo, tenendo eventualmente conto di una certa condizione per verificare se un certo campo è interessato dalla modifica o meno.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func changeFromFieldChange (fieldChange: FieldChange) -&amp;gt; FormChange {
    return { form in
        switch form {
        case .Branch (let fields):
            return branch(fields.map(fieldChange))
        case .Root (let subforms):
            return root(subforms.map(changeFromFieldChange(fieldChange)))
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la funzione verifica se un form è del tipo &lt;code&gt;.Branch&lt;/code&gt; o &lt;code&gt;.Root&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nel primo caso, ricostruisce il &lt;em&gt;branch&lt;/em&gt; applicando la funzione &lt;code&gt;FieldChange&lt;/code&gt; in ingresso a ogni campo nel &lt;em&gt;branch&lt;/em&gt;;&lt;/li&gt;
&lt;li&gt;nel secondo caso, ricostruisce il &lt;em&gt;root&lt;/em&gt; applicando ricorsivamente la stessa funzione &lt;code&gt;changeFromFieldChange&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Per migliorare la leggibilità possiamo definire una nuova funzione &lt;code&gt;updateField&lt;/code&gt; identica a &lt;code&gt;changeFromFieldChange&lt;/code&gt; che dichiara &lt;strong&gt;in maniera più espressiva&lt;/strong&gt; il tipo di operazione che vogliamo poter effettuare su un form, e cioè aggiornare un certo campo in base a una certa trasformazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let updateField = changeFromFieldChange
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Vediamo quindi un esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let form = branch([field1,field2])

let newForm = updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere dall&amp;rsquo;esempio, otteniamo &lt;code&gt;newForm&lt;/code&gt; componendo alcune funzioni definite in precedenza con &lt;code&gt;updateField&lt;/code&gt;: se l&amp;rsquo;id del campo bersaglio è &amp;ldquo;field1&amp;rdquo;, nascondiamo il campo.&lt;/p&gt;

&lt;p&gt;Come verificare se il campo con id &amp;ldquo;field1&amp;rdquo; è effettivamente nascosto? Come ultima operazione vogliamo definire una funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; che ci permetta di cercare uno o più campi in un form in base a una certa condizione: la condizione sarà ancora di tipo &lt;code&gt;FieldConditionBool&lt;/code&gt;, cioè da un campo otteniamo un valore &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt;. Per scrivere la funzione ragioniamo sul tipo di dato ritornato: esso deve corrispondere a una funzione che prende un form e ritorna un array di campi; chiameremo questo tipo &lt;code&gt;FieldGet&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typealias FieldGet = Form -&amp;gt; [Field]

func fieldsWithCondition (condition: FieldConditionBool) -&amp;gt; FieldGet {
    return { form in
        switch form {
        case .Branch(let fields):
            return fields.filter(condition.apply)
        case .Root(let subforms):
            return subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt; opera ricorsivamente, come è ovvio che sia considerando la natura ricorsiva del tipo di dato &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;. Vediamo qualche applicazione:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func fieldsWithId (id: UniqueKey) -&amp;gt; FieldGet {
    return fieldsWithCondition (FieldConditionBool { $0.id == id })
}

let allFields: FieldGet = fieldsWithCondition (FieldConditionBool { _ in true })

let twoFields = allFields(form)

let isTrue9 = count(twoFields) == 2

let isTrue10 = fieldsWithId(&amp;quot;field1&amp;quot;)(form)[0].visibility == .Visible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione &lt;code&gt;fieldsWithId&lt;/code&gt; prende una &lt;code&gt;UniqueKey&lt;/code&gt; e permette di ottenere tutti i campi con quell&amp;rsquo;id (presumibilmente l&amp;rsquo;array risultante conterrà un solo elemento); &lt;code&gt;allFields&lt;/code&gt; genera semplicemente un array con tutti i campi: da notare che la &lt;em&gt;closure&lt;/em&gt; &lt;code&gt;{ _ in true }&lt;/code&gt; ignora il valore in ingresso e ritorna sempre &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Usando &lt;code&gt;fieldsWithId&lt;/code&gt; possiamo infine verificare che il campo con id &amp;ldquo;field1&amp;rdquo; sia effettivamente nascosto, in base alle manipolazioni precedenti:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let isTrue11 = fieldsWithId(&amp;quot;field1&amp;quot;)(newForm)[0].visibility == .Hidden
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a name=&#34;conclusione&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusione:9546cc279181b22e90a8ccdde798a866&#34;&gt;Conclusione&lt;/h2&gt;

&lt;p&gt;Per concludere, abbiamo visto come partendo da &lt;strong&gt;tipi&lt;/strong&gt;, che siano essi relativi a singoli valori o a funzioni, è stato possibile iniziare a scrivere una libreria composta da semplici tipi di base e funzioni elementari che vengono composte via via a livelli di astrazione più alti. Definendo tipi specifici per molte astrazioni siamo riusciti a &lt;strong&gt;gestire meglio la complessità&lt;/strong&gt; inerente nel manipolare e comporre funzioni, al punto da poter &lt;strong&gt;trattare funzioni complesse come semplici dati&lt;/strong&gt; da passare ad altre funzioni. In un articolo successivo vedremo come estendere la libreria qui iniziata, abbracciando completamente la composizione funzionale e usando operatori specificamente definiti per migliorare la chiarezza del codice e rendere più semplice la manipolazione e combinazione delle funzioni.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;Nello scrivere questo articolo si è scelto specificamente di non definire operatori su misura per comporre le funzioni, per evitare un ulteriore appesantimento legato alla presenza di codice dalla sintassi poco familiare. La chiamata di una funzione in Swift è c-like: si scrive il nome della funzione e poi si inseriscono i dati di ingresso tra due parentesi tonde; questo purtroppo può portare a diverse chiamate in parentesi annidate; inoltre, può non risultar chiara una chiamata del tipo &lt;code&gt;updateField(ifTargetId(&amp;quot;field1&amp;quot;)(setHidden))(form)&lt;/code&gt;: come accennato, in un articolo futuro vedremo come usare operatori personalizzati per rendere il tutto più semplice e leggibile.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; &lt;em&gt;La chiamata &lt;code&gt;subforms.map(fieldsWithCondition(condition)).reduce([], combine: +)&lt;/code&gt;, nella funzione &lt;code&gt;fieldsWithCondition&lt;/code&gt;, è piuttosto inefficiente dal punto di vista della performance: l&amp;rsquo;inefficienza è dovuta al fatto che a ogni chiamata vengono generati array intermedi dovuti alle varie mappature dei dati; non è in realtà necessario creare questi array intermedi: basta utilizzare procedure &amp;ldquo;lazy&amp;rdquo;, che vedremo in un articolo futuro.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;riferimenti:9546cc279181b22e90a8ccdde798a866&#34;&gt;Riferimenti&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Tomas Petricek - &lt;a href=&#34;http://tomasp.net/blog/type-first-development.aspx&#34;&gt;Why type-first development matters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Michael Feathers - &lt;a href=&#34;http://www.infoq.com/presentations/Type-Functional-Design&#34;&gt;A Type Driven Approach to Functional Design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Johannes Weiß - &lt;a href=&#34;https://speakerdeck.com/johannesweiss/type-driven-development-in-swift&#34;&gt;Type Driven Development in Swift&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Luca Cardelli - &lt;a href=&#34;http://www.lucacardelli.name/Papers/TypefulProg.pdf&#34;&gt;Typeful Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://gist.github.com/broomburgo/ba8e5dd6cd509fdfd781&#34;&gt;GitHub Gist&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>http://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>

&lt;p&gt;Tra i molti strumenti utili presenti in Xcode, il testing framework &lt;strong&gt;XCTest&lt;/strong&gt; è certamente uno dei più rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilità con la quale è possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE &lt;em&gt;out-of-the-box&lt;/em&gt;, &lt;strong&gt;senza la necessità di installare componenti di terze parti&lt;/strong&gt; o impostare una particolare configurazione per i progetti.&lt;/p&gt;

&lt;p&gt;In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un &lt;strong&gt;target di test&lt;/strong&gt;, cioè un bundle aggiuntivo che può essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app. Nell&amp;rsquo;immagine seguente è possibile vedere come, in un progetto appena creato, sia già presente il test bundle, in questo caso chiamato &lt;em&gt;AwesomeAppTests.xctest&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Come mostrato nell&amp;rsquo;immagine, Xcode ha anche creato automaticamente il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, all&amp;rsquo;interno del quale potremo iniziare a scrivere i nostri test.&lt;/p&gt;

&lt;h2 id=&#34;setup-dell-ambiente-di-test:8e547c1c6819d235540b10fca98b5c29&#34;&gt;Setup dell&amp;rsquo;ambiente di test&lt;/h2&gt;

&lt;p&gt;Al di là del meccanismo con il quale il testing avviene, è importante capire che il codice con il quale i test sono stati scritti è compilato in un bundle diverso, e per far sì che i test &amp;ldquo;vedano&amp;rdquo; il resto dell&amp;rsquo;app, è necessario seguire le &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html&#34;&gt;regole di access control tra i moduli in Swift&lt;/a&gt;; quindi classi, struct, funzioni, costanti e così via che abbiamo dichiarato e implementato nella nostra app, o libreria che sia, &lt;strong&gt;dovranno essere marcati con la keyword *public&lt;/strong&gt;*:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func sumOfInts (x: Int, y: Int) -&amp;gt; Int {
    return x + y
}
    
public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo modo, qualsiasi modulo esterno che importerà il modulo costituito dalla nostra app potrà vedere la firma della funzione &lt;code&gt;sumOfInts&lt;/code&gt; e della classe &lt;code&gt;AwesomeItem&lt;/code&gt;. Per importare nei file di testing nel modulo dell&amp;rsquo;app sarà sufficiente scrivere &lt;code&gt;import AwesomeApp&lt;/code&gt; all&amp;rsquo;inizio del file. Aggiungiamo al progetto un file .swift, inserendo il codice appena visto: useremo questo file per scrivere tutto il codice da testare.&lt;/p&gt;

&lt;p&gt;Apriamo quindi il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, importiamo il modulo &lt;code&gt;AwesomeApp&lt;/code&gt;, eliminiamo le due funzioni di test di esempio, che hanno il solo scopo di presentare la sintassi di base dei test all&amp;rsquo;utente, e scriviamo un test banale per la funzione &lt;code&gt;sumOfInts&lt;/code&gt;; avremo quindi qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testSumOfInts() {
        /// test the sumOfIntsFunction
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xcode ha identificato la funzione &lt;code&gt;testSumOfInts&lt;/code&gt; come &lt;strong&gt;una funzione di test&lt;/strong&gt; perché il suo nome inizia con &amp;ldquo;test&amp;rdquo;, e ha posizionato un pulsante di avvio test proprio di fianco alla sua dichiarazione:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per far eseguire a Xcode questo test, e solo questo, sarà sufficiente cliccare su quel pulsante. In alternativa sarà possibile selezione &amp;ldquo;Test&amp;rdquo; dal menu &amp;ldquo;Product&amp;rdquo; per far eseguire a Xcode tutti i test che l&amp;rsquo;IDE ha riconosciuto. Xcode offre anche un &lt;strong&gt;Test Navigator&lt;/strong&gt;, che mostra il nome di tutti i test implementati, raggruppati per &lt;em&gt;Test Case&lt;/em&gt;: spostando il puntatore del mouse su un test apparirà un pulsante a forma di freccia che permetterà di avviare singolarmente i test, oppure tutti i test relativi a un particolare &lt;em&gt;Test Case&lt;/em&gt;, o anche tutti i test scritti.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per poter eseguire i test, Xcode deve effettivamente avviare l&amp;rsquo;app: selezioniamo uno dei simulatori disponibili in modo che a ogni avvio di test Xcode apra automaticamente il simulatore scelto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;xctestcase-e-xctassert:8e547c1c6819d235540b10fca98b5c29&#34;&gt;XCTestCase e XCTAssert&lt;/h2&gt;

&lt;p&gt;Nel framework &lt;strong&gt;XCTest&lt;/strong&gt; un &lt;em&gt;Test Case&lt;/em&gt; è rappresentato da una sottoclasse della classe &lt;code&gt;XCTestCase&lt;/code&gt;: al momento dell&amp;rsquo;avvio dei test viene automaticamente generata un&amp;rsquo;istanza di ciascun Test Case che abbiamo implementato, e vengono eseguiti uno a uno tutti i test dichiarati, avviando le funzioni &lt;code&gt;testSomething()&lt;/code&gt; che li implementano. Anche i metodi &lt;code&gt;setUp()&lt;/code&gt; e &lt;code&gt;tearDown()&lt;/code&gt; sono chiamati automaticamente nel corso dei test: come indicano i commenti inseriti da Xcode, il metodo &lt;code&gt;setUp()&lt;/code&gt; è chiamato immediatamente prima di ogni test, e permette di inizializzare eventuali attributi d&amp;rsquo;istanza, o variabili globali; come è intuibile, il metodo &lt;code&gt;tearDown()&lt;/code&gt; permette di ripristinare eventualmente lo stato iniziale dopo ciascun test. L&amp;rsquo;implementazione di questi due metodi è comunque del tutto opzionale: essi rappresentano semplicemente degli strumenti in più.&lt;/p&gt;

&lt;p&gt;Poiché &lt;strong&gt;i nostri Test Case sono effettivamente delle classi&lt;/strong&gt;, possiamo implementare anche altri metodi e attributi per ciascuna classe, che possono facilmente essere richiamati nei singoli test, come nel seguente esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
		var firstInt = 0
		var secondInt = 0
		var expectedSum = 0

    override func setUp() {
        super.setUp()
        
				self.firstInt = 1
				self.secondInt = 2
				self.expectedSum = 3
    }
    
    override func tearDown() {
        self.firstInt = 0
				self.secondInt = 0
				self.expectedSum = 0
        super.tearDown()
    }
   	
    func testSumOfInts() {
				let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si vede dall&amp;rsquo;esempio, per testare la funzione &lt;code&gt;sumOfInts&lt;/code&gt; si è impiegata la funzione &lt;code&gt;XCTAssert&lt;/code&gt;: tale funzione rappresenta il blocco costruttivo di base per poter scrivere i nostri unit test, e prende in ingresso da 1 a 4 parametri: il primo parametro, l&amp;rsquo;unico obbligatorio, deve essere un&amp;rsquo;espressione la cui valutazione restituisce un valore Booleano true/false, mentre gli altri parametri, del tutto opzionali poiché caratterizzati da valori di default, rappresentano rispettivamente:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un messaggio testuale che verrà mostrato in console nel caso in cui il test fallisca;&lt;/li&gt;
&lt;li&gt;il file all&amp;rsquo;interno del quale è presente il test fallito;&lt;/li&gt;
&lt;li&gt;la linea di codice in corrispondenza della quale è presente la funzione XCTAssert relativa al test fallito;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La libreria &lt;code&gt;XCTest&lt;/code&gt; dichiara molte diverse funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt;, &lt;strong&gt;i cui casi di utilizzo sono chiaramente dedotti dal nome delle funzioni&lt;/strong&gt;: ad esempio la funzione &lt;code&gt;XCTAssertNil&lt;/code&gt; verifica che l&amp;rsquo;argomento, cioè il primo parametro, sia &lt;code&gt;nil&lt;/code&gt;; la funzione &lt;code&gt;XCTAssertGreaterThan&lt;/code&gt; prende due espressioni invece di una, la cui valutazione deve restituire un valore di tipo &lt;code&gt;Comparable&lt;/code&gt; - cioè che può essere confrontato con altri valori tramite gli operatori maggiore/minore e derivati - e verifica che il risultato della prima espressione sia maggiore del risultato della seconda.&lt;/p&gt;

&lt;p&gt;Sfruttando le altre funzioni &lt;code&gt;XCTAssert&lt;/code&gt;, possiamo estendere &lt;code&gt;testSumOfInts&lt;/code&gt; per includere altre verifiche su &lt;code&gt;sumOfInts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testSumOfInts() {
        
        XCTAssertEqual(sumOfInts(self.firstInt, self.secondInt), sumOfInts(self.secondInt, self.firstInt))

        let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
        if self.firstInt &amp;lt; 0 &amp;amp;&amp;amp; self.secondInt &amp;lt; 0 {
            XCTAssertLessThan(sum, 0)
        }
        else {
            if self.firstInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.secondInt)
            }
            if self.secondInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.firstInt)
            }
            if self.firstInt &amp;gt;= 0 &amp;amp;&amp;amp; self.secondInt &amp;gt;= 0 {
                XCTAssertGreaterThanOrEqual(sum, 0)
                XCTAssertGreaterThanOrEqual(sum, self.firstInt)
                XCTAssertGreaterThanOrEqual(sum, self.secondInt)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-asincroni:8e547c1c6819d235540b10fca98b5c29&#34;&gt;Test asincroni&lt;/h2&gt;

&lt;p&gt;La libreria XCTest include alcuni strumenti per eseguire &lt;strong&gt;test su computazioni asincrone&lt;/strong&gt;, cioè eseguite da funzioni che non ritornano immediatamente un valore ma che potrebbero chiamare una funzione di callback a un certo punto nel futuro. Per testare una funzione asincrona è necessario:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;creare un&amp;rsquo;istanza di &lt;code&gt;XCTestExpectation&lt;/code&gt;, un oggetto che rappresenta l&amp;rsquo;&lt;strong&gt;aspettativa&lt;/strong&gt; che ad un certo punto nel futuro accada qualcosa;&lt;/li&gt;
&lt;li&gt;informare l&amp;rsquo;istanza del &lt;code&gt;XCTestCase&lt;/code&gt;, generata automaticamente all&amp;rsquo;avvio dei test, che nel corso di un certo test è necessario che le &lt;em&gt;aspettative&lt;/em&gt; vengano &lt;em&gt;soddisfatte&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Per fare un esempio, aggiungiamo una semplice funzione pubblica a &lt;em&gt;AwesomeItem.swift&lt;/em&gt; che permette di scaricare un&amp;rsquo;immagine presente a un certo URL, e chiama una funzione callback restituendo appunto una &lt;code&gt;UIImage&lt;/code&gt; che rappresenti l&amp;rsquo;immagine scaricata: per semplicità non gestiremo gli errori, e nel caso in cui qualcosa vada storto otterremo semplicemente &lt;code&gt;nil&lt;/code&gt; al posto dell&amp;rsquo;immagine (quindi l&amp;rsquo;oggetto effettivamente ottenuto sarà di tipo &lt;code&gt;UIImage?&lt;/code&gt;, cioè un oggetto opzionale). Per poter manipolare &lt;code&gt;UIImage&lt;/code&gt; dobbiamo importare &lt;code&gt;UIKit&lt;/code&gt; in &lt;em&gt;AwesomeItem.swift&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import UIKit

public func sumOfInts (a: Int, b: Int) -&amp;gt; Int {
    return a + b
}

public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
}

public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Che si riesca a meno a scaricare l&amp;rsquo;immagine, la funzione di callback deve comunque essere chiamata in un tempo ragionevole, e l&amp;rsquo;obbiettivo del test asincrono sarà proprio quello di verificare che la tale funzione venga chiamata, ignorando  l&amp;rsquo;oggetto ottenuto per l&amp;rsquo;immagine. Segue una possibile implementazione per questo test, nella quale creiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt; e impostiamo un&amp;rsquo;attesa di 5 secondi: è ovviamente possibile sincronizzare il tempo di attesa con il tempo di timeout della sessione di download creata, ma per semplicità imposteremo un tempo forfettario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDownloadImageCallback() {
        
        let downloadImageCallbackExpectation = self.expectationWithDescription(&amp;quot;downloadImageCallbackExpectation&amp;quot;)
        
        let imageUrl = NSURL(string: &amp;quot;http://goo.gl/XYwppm&amp;quot;)!
        
        downloadImage(imageUrl) { image in
            downloadImageCallbackExpectation!.fulfill();
        }
        
        self.waitForExpectationsWithTimeout(5.0, handler: nil)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se proviamo ad avviare il test cliccando sull&amp;rsquo;icona di avvio apparsa in Xcode proprio a sinistra della riga di dichiarazione della funzione, analogamente a quando mostrato prima, vedremo che Xcode rimarrà bloccato per 5 secondi prima di mostrare il messaggio &lt;code&gt;Asynchronous wait failed: Exceeded timeout of 5 seconds, with unfulfilled expectations: &amp;quot;downloadImageCallbackExpectation&amp;quot;.&lt;/code&gt;: come mai? Il fallimento del test ci informa subito del fatto che la funzione di download dell&amp;rsquo;immagine che abbiamo scritto ha qualche problema: è facile vedere che esso è dovuto al fatto che non abbiamo chiamato &lt;code&gt;resume()&lt;/code&gt; sulla task di download creata. Correggiamo quindi la nostra funzione &lt;code&gt;downloadImage&lt;/code&gt; nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
    task.resume()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Il test ci ha immediatamente informati dell&amp;rsquo;errore&lt;/strong&gt;, e ci ha permesso di evitare una possibile sorgente di bug nel nostro codice, e diversi mal di testa. Grazie al modo &lt;em&gt;seamless&lt;/em&gt; nel quale il framework XCTest è integrato in Xcode, risulta facile e veloce scrivere test che permettano di verificare immediatamente se il nostro codice funziona come dovrebbe, ed &lt;strong&gt;è Xcode stesso a incoraggiare la scrittura di test&lt;/strong&gt; nel corso della realizzazione di un&amp;rsquo;app o di una libreria generando automaticamente un target di test ogni volta in cui si crea un nuovo progetto: non ci sono più scuse quindi per non iniziare a scrivere test completi ed efficienti che permettano di &lt;strong&gt;realizzare software migliore&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il progetto Xcode contenente tutto il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/xcode-testing-in-pratica&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>