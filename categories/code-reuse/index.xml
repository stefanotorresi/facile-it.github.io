<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code reuse on Facile.it Engineering</title>
    <link>engineering.facile.it/categories/code-reuse/</link>
    <description>Recent content in Code reuse on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="engineering.facile.it/categories/code-reuse/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Code reuse: a primer</title>
      <link>/engineering.facile.it/blog/eng/code-reuse-a-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/engineering.facile.it/blog/eng/code-reuse-a-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c/&#34;&gt;Last time&lt;/a&gt; we looked at a possible implementation for the &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; type in Objective-C; while the main point was to port to Objective-C a tool that&amp;rsquo;s frequently used in Swift, making use of the &lt;code&gt;Optional&lt;/code&gt; class can be considered an application of a much more general concept: &lt;strong&gt;code reuse&lt;/strong&gt;. In fact, &lt;code&gt;Optional&lt;/code&gt; is not tied to a particular domain, and can be reused over and over again in multiple projects: that&amp;rsquo;s what actually happens in Swift. But, to think about it, that&amp;rsquo;s what happens for a wide range of &lt;em&gt;classes&lt;/em&gt; in Objective-C, or &lt;em&gt;types&lt;/em&gt; in Swift: for example, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are both constructs that expose a certain interface, have a certain implementation, and are reused multiple times within methods and functions. And again, &lt;code&gt;NSArray&lt;/code&gt; and &lt;code&gt;Array&lt;/code&gt; are not tied to a particular domain, and have two important properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;they are &lt;strong&gt;generic&lt;/strong&gt;, that is, they are not dependent on a particular subtype: an array of numbers and an array of strings will work in the exact same way when it comes to behavior that&amp;rsquo;s strictly associated to arrays, like counting elements, removing or adding an element, mapping, filtering, reducing et cetera;&lt;/li&gt;
&lt;li&gt;they are &lt;strong&gt;composable&lt;/strong&gt;, that is, they can be stacked on top of each other, and assembled with other more specific things, while keeping the same &lt;strong&gt;predictable behavior&lt;/strong&gt;: an array of &lt;em&gt;customers&lt;/em&gt;, each with their own array of &lt;em&gt;purchased products&lt;/em&gt;, can be mapped to an array of arrays of &lt;em&gt;products&lt;/em&gt;, that can be flattened into an array of &lt;em&gt;products&lt;/em&gt;, that can be reduced into a number representing the total cost;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, like &lt;code&gt;Optional&lt;/code&gt;, is a nice example of perfectly reusable code, but there are many more constructs that satisfy the aforementioned rules: &lt;em&gt;genericity&lt;/em&gt; and &lt;em&gt;composability&lt;/em&gt;. What doesn&amp;rsquo;t satisfy the rules is domain-specific objects, even when it seems like an object is sufficiently generic to be reused. A &lt;code&gt;Customer&lt;/code&gt; class, for example, could seem a good candidate, but trying to reuse the same class in two different projects will result in &lt;strong&gt;bad news&lt;/strong&gt; and headaches: either we&amp;rsquo;ll need to &lt;strong&gt;specialize&lt;/strong&gt; the class for each project, making the two diverge, or we&amp;rsquo;ll need to add levels of &lt;strong&gt;indirection&lt;/strong&gt;, because we&amp;rsquo;re forcing an object into a project it doesn&amp;rsquo;t belong to.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another thing to consider: if we really want to reuse code, we&amp;rsquo;ll also need to make &lt;strong&gt;design choices&lt;/strong&gt; that allow that code to be reused. I could actually forget about the &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt; types, and create classes that never expose their underlying components; for example, I could create a class that represents a collection of optional objects, without ever exposing in the interface the fact that I&amp;rsquo;m using &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt; for its implementation: it would result in some serious &lt;strong&gt;contortion&lt;/strong&gt; of methods&amp;rsquo; signature, but it&amp;rsquo;s possible. Also, is it a good idea? &lt;strong&gt;I don&amp;rsquo;t think so&lt;/strong&gt;. Creating a specific, incomposable class for every possible need will result in thousands of lines of what&amp;rsquo;s essentially &lt;strong&gt;boilerplate&lt;/strong&gt; code, complicated interfaces, and ridiculously long class names. If we aspire to code reuse, other than the two rules we just defined, we also need to pay attention to the way we architect our apps, and the main design principle to follow here is one of &lt;strong&gt;composition&lt;/strong&gt;, that can be summed up with the following:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Domain-specific constructs and behaviors should be realized by composing atomic and generic building blocks.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This basically means that, instead of creating every time a specific implementation for our needs, we should try and satisfy that need by composing reusable, atomic objects. This looks complex, and at this point we should ask ourselves if code reuse is really something we want to pursue. My answer is a definitive &lt;strong&gt;yes&lt;/strong&gt;, for the following reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;with reusable components we can &lt;strong&gt;encapsulate&lt;/strong&gt; a particular behavior, and avoid rewriting essentially the same thing over and over again;&lt;/li&gt;
&lt;li&gt;we&amp;rsquo;ll have a &lt;strong&gt;guideline&lt;/strong&gt; for designing the architecture of our app, because we wont&amp;rsquo;t need to constantly define new interfaces for the same behaviors;&lt;/li&gt;
&lt;li&gt;a reusable component is very easy to &lt;strong&gt;test&lt;/strong&gt;, because it&amp;rsquo;s small and atomic, so by using it we will be more confident about the correctness of our code;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That, again, is what happens when we use types like &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt;. As I said, there are many more of these building blocks, and actually the definition of their interfaces is a problem in itself, and has no obvious solution, but I think it&amp;rsquo;s a very interesting problem to tackle. By following the &lt;em&gt;generic&lt;/em&gt; and &lt;em&gt;composable&lt;/em&gt; rules we already have a guideline for designing them, but if we want to create our owns we should probably add one more rule:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a reusable object has to be &lt;strong&gt;simple&lt;/strong&gt;, that is, it should have a unique, linear, easily describable responsibility;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; follows this rule: it&amp;rsquo;s a generic container that represents an object that could be there, or not. &lt;code&gt;Array&lt;/code&gt; follows this rule: it represents and &lt;em&gt;ordered&lt;/em&gt; collection of objects, each one them accessible in constant time. Let&amp;rsquo;s try to apply the rule and create a new reusable object.&lt;/p&gt;

&lt;p&gt;Consider this real, kind of frequent use case: different objects must be notified when a certain object changes state or does something. A way to solve the problem is represented by the &lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;, that is, make our objects implement an interface that exposes a &lt;a href=&#34;https://en.wikipedia.org/wiki/Publish–subscribe_pattern&#34;&gt;publish-subscribe&lt;/a&gt; behavior. The point is, implementing an interface &lt;strong&gt;is not reusable&lt;/strong&gt;: each time we want to use this pattern we are going to &lt;strong&gt;rewrite&lt;/strong&gt; very similar code; instead, we want to encapsulate the behavior in a generic object, and reuse that object instead. What follows is a possible implementation, the one that I use in production, but there are many more: actually, &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming&lt;/a&gt; has spawned from this very problem, that is, finding a generic, composable way of representing and manipulating observable streams, but in this case we&amp;rsquo;re going to create a much simpler &lt;strong&gt;Signal&lt;/strong&gt; object.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Signal&lt;/code&gt; class we want to implement is going to represent an &lt;em&gt;update&lt;/em&gt; for a certain object: that update can be everything, like a new value for a property, or an action that was taken. We&amp;rsquo;ll use the Swift language, which is also going to give us a lot of &lt;strong&gt;type-safety&lt;/strong&gt; for free. Here&amp;rsquo;s a summary of what we want for the &lt;code&gt;Signal&lt;/code&gt; class:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;it has to a have a &lt;strong&gt;parametric&lt;/strong&gt; subtype, that is, the type of the value that will be signaled in each update;&lt;/li&gt;
&lt;li&gt;it has to have an &lt;code&gt;observe&lt;/code&gt; method, that takes a closure representing an action that has to be taken every time an update is given;&lt;/li&gt;
&lt;li&gt;it has to have a &lt;code&gt;send&lt;/code&gt; method, which takes a new value of the underlying subtype;&lt;/li&gt;
&lt;li&gt;it has to have some simple methods for composition, that follow the usual naming conventions, like &lt;code&gt;map&lt;/code&gt;, for generating a new &lt;code&gt;Signal&lt;/code&gt; from an existing one by transforming the observed value, and &lt;code&gt;forwardTo&lt;/code&gt; to make another &lt;code&gt;Signal&lt;/code&gt; &lt;em&gt;trigger&lt;/em&gt; when a certain &lt;code&gt;Signal&lt;/code&gt; is producing a new value;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Semantically, we can describe a &lt;code&gt;Signal&lt;/code&gt; as a container for a value that&amp;rsquo;s going to be there at a certain point in time, and it&amp;rsquo;s going to update itself indefinitely.&lt;/p&gt;

&lt;p&gt;What follows is the entire implementation of the &lt;code&gt;Signal&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum SignalContinuation
{
  case Continue
  case Stop
}

public class Signal&amp;lt;Subtype&amp;gt;
{
  private var observers: [(Subtype -&amp;gt; SignalContinuation)] = []

  public init() {}

  public func observe (observeFunction: Subtype -&amp;gt; SignalContinuation)
  {
    observers.append(observeFunction)
  }

  public func send (value: Subtype)
  {
    var continuations: [(Subtype -&amp;gt; SignalContinuation)] = []
    while observers.count &amp;gt; 0
    {
      let observer = observers.removeFirst()
      let continuation = observer(value)
      switch continuation
      {
      case .Continue:
        continuations.append(observer)
      case .Stop: break
      }
    }
    observers = continuations
  }

  public func forwardTo (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(action)
      return .Continue
    }
    return self
  }

  public func forwardTo &amp;lt;OtherSubtype&amp;gt; (
    otherSignal: Signal&amp;lt;OtherSubtype&amp;gt;,
    mappingFunction: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(mappingFunction(action))
      return .Continue
    }
    return self
  }

  public func map &amp;lt;OtherSubtype&amp;gt; (transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;
  {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    forwardTo(mappedSignal, mappingFunction: transform)
    return mappedSignal
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is really simple, but still, really powerful. A problem that&amp;rsquo;s frequently found when implementing the observer pattern is how to manage unsubscriptions; it&amp;rsquo;s a responsibility of the observer object to stop observing something, and in this &lt;code&gt;Signal&lt;/code&gt; implementation this is easily managed within the closure passed to the &lt;code&gt;observe&lt;/code&gt; method: the closure must return a &lt;code&gt;SignalContinuation&lt;/code&gt; value, that can be simply &lt;code&gt;.Continue&lt;/code&gt; (that is, keep observing updates) or &lt;code&gt;.Stop&lt;/code&gt;. Another problem is memory management: we need to make sure that when an observer&amp;rsquo;s memory is released, it will also stop observing, or a message will be sent to a dangling pointer, resulting in the app crashing. Swift&amp;rsquo;s &lt;code&gt;weak&lt;/code&gt; memory semantics actually makes this really easy to do: we&amp;rsquo;ll put a &lt;code&gt;guard&lt;/code&gt; clause at the beginning of the closure passed to the &lt;code&gt;observe&lt;/code&gt; method; if the object has become &lt;code&gt;nil&lt;/code&gt;, we&amp;rsquo;ll simply return &lt;code&gt;.Stop&lt;/code&gt;. The following example shows a simple use of the &lt;code&gt;Signal&lt;/code&gt; class, including the &lt;em&gt;stop-observing-on-nil&lt;/em&gt; mechanism:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Sender
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func sendNew(value: Int)
  {
    signal.send(value)
  }
}

class Receiver&amp;lt;Type: CustomStringConvertible&amp;gt;
{
  func startObserving(signal: Signal&amp;lt;Type&amp;gt;)
  {
    signal.observe { [weak self] value in
      guard let this = self else { return .Stop }
      this.printNewValue(value)
      return .Continue
    }
  }

  func printNewValue(value: Type)
  {
    print(value)
  }
}

let sender = Sender()
let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(sender.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 3, 5, 10, 20 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the example we can see an application of the concepts we talked about at the beginning of this article: instead of creating yet another interface for the same behavior, we are directly using and reusing the &lt;code&gt;Signal&lt;/code&gt; object. A more complex example would be the addition of something like a &lt;em&gt;resonator&lt;/em&gt;, that is, an object with a &lt;code&gt;Signal&lt;/code&gt; that resonates with another, like in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DoublingResonator
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func resonateWith(otherSignal: Signal&amp;lt;Int&amp;gt;)
  {
    otherSignal.forwardTo(signal) { $0*2 }
  }
}

let resonator = DoublingResonator()
resonator.resonateWith(sender.signal)

let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(resonator.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 6, 10, 20, 40 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many other options for composition of signals, but as long as we don&amp;rsquo;t need them, it&amp;rsquo;s better to keep the class &lt;strong&gt;simple&lt;/strong&gt;: then, gradually over time, we can start adding features to the class, and as long as they&amp;rsquo;re properly generic and tested, we will be able to use them in all of our projects.&lt;/p&gt;

&lt;p&gt;To conclude, finding the right abstractions for reusability is of course a problem, and the solution is not an easy one: plenty of academic papers address the problem in several ways (classic Charles W. Krueger&amp;rsquo;s paper &lt;a href=&#34;http://www.biglever.com/papers/Krueger_AcmReuseSurvey.pdf&#34;&gt;Software Reuse&lt;/a&gt; contains a good overview of the used techniques), and the reason why &lt;a href=&#34;https://en.wikipedia.org/wiki/Category_theory&#34;&gt;category theory&lt;/a&gt; has many applications in functional programming is because it offers an excellent set of abstractions for tackling several classes of problems. But still, I think the advantages of code reuse are many, and that achieving a compositional design through atomic, reusable components is &lt;strong&gt;a worthy goal&lt;/strong&gt; to pursue.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Codice riusabile: un primer</title>
      <link>/engineering.facile.it/blog/ita/codice-riusabile-un-primer/</link>
      <pubDate>Wed, 09 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/engineering.facile.it/blog/ita/codice-riusabile-un-primer/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/optionals-in-objective-c-ita/&#34;&gt;L&amp;rsquo;ultima volta&lt;/a&gt; abbiamo visto una possibile implementazione del tipo &lt;a href=&#34;https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID330&#34;&gt;Optional&lt;/a&gt; in Objective-C; l&amp;rsquo;obiettivo primario dell&amp;rsquo;articolo era quello di importare in Objective-C uno strumento frequentemente utilizzato in Swift, ma usare una classe come &lt;code&gt;Optional&lt;/code&gt; può essere considerato un&amp;rsquo;applicazione di un concetto molto più generale: il &lt;strong&gt;riutilizzo del codice&lt;/strong&gt;. In effetti, &lt;code&gt;Optional&lt;/code&gt; non è legato a un particolare dominio, e può essere riutilizzato più e più volte in molti progetti: questo è esattamente ciò che accade in Swift. Ma a pensarci bene, questo è ciò che accade per una grande varietà di &lt;em&gt;classi&lt;/em&gt; in Objective-C (e di &lt;em&gt;tipi&lt;/em&gt; in Swift): ad esempio, &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; sono entrambi costrutti che espongono una specifica interfaccia, possiedono una certa implementazione, e vengono riutilizzati continuamente in metodi e funzioni. &lt;code&gt;NSArray&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt; non sono legati a un particolare dominio, e possiedono due importanti caratteristiche:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;sono &lt;strong&gt;generici&lt;/strong&gt;, quindi non sono legati a un particolare sottotipo: un array di numeri e un array di stringhe funzioneranno esattamente allo stesso modo per quanto riguarda le funzioni strettamente associate agli array, come il conteggio degli elementi, rimuovere o aggiungere un elemento, mappare, filtrare, ridurre e così via;&lt;/li&gt;
&lt;li&gt;sono &lt;strong&gt;componibili&lt;/strong&gt;, quindi possono essere combinati tra loro e con altri oggetti più specifici, mantenendo comunque lo stesso &lt;strong&gt;comportamento predicibile&lt;/strong&gt;: un array di &lt;em&gt;clienti&lt;/em&gt;, ciascuno con il suo array &lt;em&gt;prodotti acquistati&lt;/em&gt;, può essere mappato in un array di array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere appiattito in un array di &lt;em&gt;prodotti&lt;/em&gt;, che può essere ridotto a un numero che rappresenta il costo totale;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;, come &lt;code&gt;Optional&lt;/code&gt;, è un ottimo esempio di codice perfettamente riutilizzabile, ma ci sono molti altri costrutti che soddisfano le regole di cui sopra, cioè &lt;em&gt;genericità&lt;/em&gt; e &lt;em&gt;componibilità&lt;/em&gt;. Gli oggetti specifici di dominio, invece, tipicamente non soddisfano queste regole, anche quando un oggetto sembra essere sufficientemente generico da poter essere riutilizzato. Una classe &lt;code&gt;Cliente&lt;/code&gt;, ad esempio, potrebbe sembrare un buon candidato, ma cercare di usare la stessa classe in due diversi progetti si rivelerebbe &lt;strong&gt;una pessima idea&lt;/strong&gt;: probabilmente saremo costretti a &lt;strong&gt;specializzare&lt;/strong&gt; la classe per ciascun progetto, portando a divergenza tra le implementazioni, o usare diversi livelli di &lt;strong&gt;indirezione&lt;/strong&gt;, perché stiamo inserendo a forza un oggetto in un dominio che non gli appartiene.&lt;/p&gt;

&lt;p&gt;C&amp;rsquo;è un&amp;rsquo;altra cosa da considerare: se davvero vogliamo riutilizzare del codice, dovremo anche stare attenti alle nostre &lt;strong&gt;scelte di design&lt;/strong&gt;, perché non tutti i design permettono l&amp;rsquo;utilizzo di codice generico. Potrei dimenticarmi dell&amp;rsquo;esistenza dei tipi &lt;code&gt;Optional&lt;/code&gt; e &lt;code&gt;Array&lt;/code&gt;, e creare classi che non espongono mai i loro componenti di base; ad esempio, potrei creare una classe che rappresenta una collezione di oggetti opzionali, senza mai esporre nell&amp;rsquo;interfaccia il fatto che sto utilizzando &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt; nell&amp;rsquo;implementazione: ne risulterebbe una certa &lt;strong&gt;complicazione&lt;/strong&gt; della firma dei metodi, ma è possibile. Ma, a pensarci bene, è una buona idea? &lt;strong&gt;Ne dubito&lt;/strong&gt;. Creare una nuova e specifica classe, non componibile, per ogni possibile necessità produrrà migliaia di linee di codice &lt;strong&gt;boilerplate&lt;/strong&gt;, interfacce complicate, e nomi di classi assurdamente lunghi. Se vogliamo scrivere codice riutilizzabile, oltre a seguire le due regole già viste, dobbiamo anche prestare attenzione al modo in cui architettiamo le nostre app, e il principio di design da seguire in questo caso è il principio di &lt;strong&gt;composizione&lt;/strong&gt;, che può essere sintetizzato con la seguente frase:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Costrutti e comportamenti specifici del dominio dovrebbero essere realizzati componendo blocchi costruttivi atomici e generici.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ciò significa sostanzialmente che, invece di creare di volta in volta una specifica implementazione per ovviare alle nostre necessità, dovremmo costruire le nuove funzionalità aggregando oggetti atomici già definiti. Sembra un&amp;rsquo;idea complessa, e forse dovremmo fermarci un attimo e chiederci se scrivere codice riutilizzabile sia davvero una buona idea. La mia risposta è un definitivo &lt;strong&gt;si&lt;/strong&gt;, per i seguenti motivi:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;scrivendo componenti riutilizzabili possiamo &lt;strong&gt;incapsulare&lt;/strong&gt; uno specifico comportamento, evitando di dover riscrivere di continuo sostanzialmente lo stesso codice;&lt;/li&gt;
&lt;li&gt;potremmo disporre di &lt;strong&gt;linee guida&lt;/strong&gt; per progettare l&amp;rsquo;architettura delle nostre app, perché non avremmo bisogno di definire sempre nuove interfacce per rappresentare gli stessi comportamenti;&lt;/li&gt;
&lt;li&gt;un componente riutilizzabile è molto facile da &lt;strong&gt;testare&lt;/strong&gt;, perché piccolo e atomico, quindi usandolo potremmo confidare maggiormente sulla correttezza del nostro codice;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Questi stessi vantaggi si ottengono, infatti, proprio usando oggetti come &lt;code&gt;Array&lt;/code&gt; e &lt;code&gt;Optional&lt;/code&gt;. Ma, come ho detto, esistono molti altri componenti di questo tipo, e in effetti definire le loro interfacce è un problema a sé, di non facile soluzione: lo trovo tuttavia un problema molto interessante. Seguendo le regole &lt;em&gt;generico&lt;/em&gt; e &lt;em&gt;componibile&lt;/em&gt; abbiamo già una linea guida per definire nuovi componenti riusabili, ma per chiudere il cerchio abbiamo bisogno di una terza regola, non meno importante:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un oggetto riusabile deve essere &lt;strong&gt;semplice&lt;/strong&gt;, cioè deve avere una unica responsabilità, lineare e facile da descrivere;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Optional&lt;/code&gt; segue questa regola: è un contenitore generico per un oggetto che potrebbe esserci, oppure no. &lt;code&gt;Array&lt;/code&gt; segue questa regola: rappresenta una collezione ordinata di oggetti, ai quali posso accedere in un tempo costante. Proviamo a creare un nuovo componente riutilizzabile applicando le regole.&lt;/p&gt;

&lt;p&gt;Consideriamo questo caso d&amp;rsquo;uso reale (piuttosto frequente): diversi oggetti devono essere notificati quando un certo oggetto cambia il suo stato, o compie qualche azione. Un modo per risolvere il problema è rappresentato dall&amp;rsquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Observer_pattern&#34;&gt;observer pattern&lt;/a&gt;, che consiste nel far implementare ai nostri oggetti un&amp;rsquo;interfaccia che indica un comportamento di tipo &lt;a href=&#34;https://it.wikipedia.org/wiki/Publish/subscribe&#34;&gt;publish-subscribe&lt;/a&gt;. Tuttavia, far implementare agli oggetti un&amp;rsquo;interfaccia &lt;strong&gt;non è riusabile&lt;/strong&gt;: ogni volta in cui useremo questo pattern finiremo per &lt;strong&gt;riscrivere&lt;/strong&gt; codice molto simile. Vogliamo invece incapsulare il comportamento alla base di questo pattern in un oggetto generico, e riutilizzare quell&amp;rsquo;oggetto. Quanto segue è una possibile implementazione di tale oggetto, quella che personalmente uso in produzione, ma ce ne sono molte altre: in effetti, l&amp;rsquo;idea di trovare un modo generico e componibile di rappresentare e manipolare &lt;em&gt;flussi&lt;/em&gt; di segnali osservabili ha fatto nascere un intero paradigma di programmazione, chiamato &lt;a href=&#34;https://en.wikipedia.org/wiki/Functional_reactive_programming&#34;&gt;functional reactive programming&lt;/a&gt;. Ma nel nostro caso siamo interessati a creare un ben più semplice oggetto &lt;strong&gt;Signal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;La classe &lt;code&gt;Signal&lt;/code&gt; che vogliamo implementare deve rappresentare un &lt;em&gt;aggiornamento&lt;/em&gt; per un certo oggetto: l&amp;rsquo;aggiornamento può riguardare qualsiasi cosa, per esempio un nuovo valore per un attributo, o il fatto che una certa azione è stata compiuta. Useremo il linguaggio Swift, grazie al quale potremo godere anche di ottima sicurezza sulla manipolazione dei &lt;strong&gt;tipi&lt;/strong&gt; coinvolti. Ecco in sintesi cosa chiediamo alla classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;deve avere un sottotipo &lt;strong&gt;parametrico&lt;/strong&gt;, che sarà appunto il tipo del valore segnalato ad ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;observe&lt;/code&gt;, che prende in ingresso una &lt;em&gt;closure&lt;/em&gt; che rappresenta l&amp;rsquo;azione da compiere a ogni aggiornamento;&lt;/li&gt;
&lt;li&gt;deve dichiarare un metodo &lt;code&gt;send&lt;/code&gt;, che prende in ingresso un nuovo valore del tipo sottostante;&lt;/li&gt;
&lt;li&gt;deve dichiarare semplici metodi di composizione, che seguano le convenzioni classiche per i nomi, come &lt;code&gt;map&lt;/code&gt; per generare un nuovo &lt;code&gt;Signal&lt;/code&gt; da uno esistente trasformando il valore osservato, e &lt;code&gt;forwardTo&lt;/code&gt; per fare in modo che un altro &lt;code&gt;Signal&lt;/code&gt;, quando produce un nuovo valore, &lt;em&gt;attivi&lt;/em&gt; il segnale di partenza;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dal punto di vista semantico, possiamo descrivere un &lt;code&gt;Signal&lt;/code&gt; come un contenitore di un valore che esisterà a un certo punto nel futuro, e continuerà ad aggiornarsi indefinitamente.&lt;/p&gt;

&lt;p&gt;Segue l&amp;rsquo;intera implementazione della classe &lt;code&gt;Signal&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum SignalContinuation
{
  case Continue
  case Stop
}

public class Signal&amp;lt;Subtype&amp;gt;
{
  private var observers: [(Subtype -&amp;gt; SignalContinuation)] = []

  public init() {}

  public func observe (observeFunction: Subtype -&amp;gt; SignalContinuation)
  {
    observers.append(observeFunction)
  }

  public func send (value: Subtype)
  {
    var continuations: [(Subtype -&amp;gt; SignalContinuation)] = []
    while observers.count &amp;gt; 0
    {
      let observer = observers.removeFirst()
      let continuation = observer(value)
      switch continuation
      {
      case .Continue:
        continuations.append(observer)
      case .Stop: break
      }
    }
    observers = continuations
  }

  public func forwardTo (otherSignal: Signal&amp;lt;Subtype&amp;gt;) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(action)
      return .Continue
    }
    return self
  }

  public func forwardTo &amp;lt;OtherSubtype&amp;gt; (
    otherSignal: Signal&amp;lt;OtherSubtype&amp;gt;,
    mappingFunction: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal
  {
    observe { action in
      otherSignal.send(mappingFunction(action))
      return .Continue
    }
    return self
  }

  public func map &amp;lt;OtherSubtype&amp;gt; (transform: Subtype -&amp;gt; OtherSubtype) -&amp;gt; Signal&amp;lt;OtherSubtype&amp;gt;
  {
    let mappedSignal = Signal&amp;lt;OtherSubtype&amp;gt;()
    forwardTo(mappedSignal, mappingFunction: transform)
    return mappedSignal
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L&amp;rsquo;implementazione è semplice, ma potente. Un problema affrontato di frequente quando si implementa l&amp;rsquo;&lt;em&gt;observer pattern&lt;/em&gt; è la gestione delle disiscrizioni; è responsabilità di chi osserva smettere di farlo, e in questa implementazione di &lt;code&gt;Signal&lt;/code&gt; la cosa è gestita direttamente nella &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;: la &lt;em&gt;closure&lt;/em&gt; deve ritornare un valore di tipo &lt;code&gt;SignalContinuation&lt;/code&gt; che può essere appunto &lt;code&gt;.Continue&lt;/code&gt; o &lt;code&gt;.Stop&lt;/code&gt;. Un altro problema è la gestione della memoria: dobbiamo assicurarci che quando la memoria di un osservatore è rilasciata, questo debba anche smettere di osservare i segnali, o il messaggio verrà inviato a un puntatore non valido, con conseguente crash dell&amp;rsquo;app. Swift definisce alcuni descrittori di &lt;em&gt;memory ownership&lt;/em&gt;, e &lt;code&gt;weak&lt;/code&gt; fa al caso nostro: sarà sufficiente inserire una &lt;em&gt;guard clause&lt;/em&gt; all&amp;rsquo;inizio della &lt;em&gt;closure&lt;/em&gt; passata al metodo &lt;code&gt;observe&lt;/code&gt;; se l&amp;rsquo;oggetto è diventato &lt;code&gt;nil&lt;/code&gt;, la &lt;em&gt;closure&lt;/em&gt; ritornerà &lt;code&gt;.Stop&lt;/code&gt;. L&amp;rsquo;esempio seguente mostra un possibile utilizzo della classe &lt;code&gt;Signal&lt;/code&gt;, incluso il meccanismo appena descritto:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Sender
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func sendNew(value: Int)
  {
    signal.send(value)
  }
}

class Receiver&amp;lt;Type: CustomStringConvertible&amp;gt;
{
  func startObserving(signal: Signal&amp;lt;Type&amp;gt;)
  {
    signal.observe { [weak self] value in
      guard let this = self else { return .Stop }
      this.printNewValue(value)
      return .Continue
    }
  }

  func printNewValue(value: Type)
  {
    print(value)
  }
}

let sender = Sender()
let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(sender.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 3, 5, 10, 20 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nell&amp;rsquo;esempio possiamo osservare l&amp;rsquo;applicazione dei concetti introdotti all&amp;rsquo;inizio dell&amp;rsquo;articolo: invece di creare una nuova interfaccia per lo stesso comportamento, stiamo direttamente usando e riusando l&amp;rsquo;oggetto &lt;code&gt;Signal&lt;/code&gt;. Un esempio più complesso potrebbe essere rappresentato dall&amp;rsquo;aggiunta di un &lt;em&gt;resonator&lt;/em&gt;, cioè di un oggetto che possiede un segnale che risuona con un altro, quindi:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class DoublingResonator
{
  let signal = Signal&amp;lt;Int&amp;gt;()

  func resonateWith(otherSignal: Signal&amp;lt;Int&amp;gt;)
  {
    otherSignal.forwardTo(signal) { $0*2 }
  }
}

let resonator = DoublingResonator()
resonator.resonateWith(sender.signal)

let receiver = Receiver&amp;lt;Int&amp;gt;()

receiver.startObserving(resonator.signal)

sender.signal.send(3)
sender.signal.send(5)
sender.signal.send(10)
sender.signal.send(20)
/// this will print 6, 10, 20, 40 on console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ci sono molte altre opzioni per comporre segnali, ma finché non ne avremo bisogno sarà meglio mantenere la classe &lt;strong&gt;semplice&lt;/strong&gt;: gradualmente nel tempo potremo aggiungere nuove funzionalità, e fintanto che queste saranno sufficientemente generiche e propriamente testate, saremo in grado di usarle in tutti i nostri progetti.&lt;/p&gt;

&lt;p&gt;Per concludere, definire le giuste astrazioni per conseguire riusabilità del codice non è un problema di semplice soluzione: molte pubblicazioni accademiche affrontano il problema (il classico articolo &lt;a href=&#34;http://www.biglever.com/papers/Krueger_AcmReuseSurvey.pdf&#34;&gt;Software Reuse&lt;/a&gt; di Charles W. Krueger fornisce una buona panoramica delle tecniche considerate), e il motivo per il quale la &lt;a href=&#34;https://it.wikipedia.org/wiki/Teoria_delle_categorie&#34;&gt;teoria delle categorie&lt;/a&gt; ha trovato molte applicazioni in programmazione funzionale è perché essa offre un eccellente insieme di astrazioni per affrontare diverse classi di problemi. Tuttavia sono convinto che i vantaggi legati allo scrivere codice riutilizzabile siano molti, e che poter basare un design sulla composizione di oggetti atomici sia &lt;strong&gt;un degno obiettivo&lt;/strong&gt; da perseguire.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>