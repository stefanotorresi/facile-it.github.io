<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>PSR on Facile Engineering</title>
    <link>engineering.facile.it/categories/psr/</link>
    <description>Recent content in PSR on Facile Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 23 Mar 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="engineering.facile.it/categories/psr/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>PHP coding standard: PSR-7  HTTP message interfaces</title>
      <link>/engineering.facile.it/blog/ita/php-fig-standard-psr-7-http-message-interfaces/</link>
      <pubDate>Mon, 23 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>/engineering.facile.it/blog/ita/php-fig-standard-psr-7-http-message-interfaces/</guid>
      <description>

&lt;p&gt;Le specifiche PSR-7 descrivono una &lt;a href=&#34;https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md&#34;&gt;proposta di standardizzazione&lt;/a&gt; delle &lt;strong&gt;interfacce per i messaggi HTTP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Come sappiamo, il protocollo HTTP, attraverso le specifiche redatte dal W3C, definisce una serie di regole di comunicazione che vengono implementate dalle applicazioni client e server che lo adottano.&lt;/p&gt;

&lt;p&gt;A prima vista niente di nuovo sotto il Sole dunque, ma cerchiamo insieme di comprendere l&amp;rsquo;insieme di problematiche che sono al centro di questo nuovo dibattito che riguarda gli standard di codifica del linguaggio PHP.&lt;/p&gt;

&lt;h4 id=&#34;una-questione-di-interoperabilità-tra-framework:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Una questione di interoperabilità tra framework&lt;/h4&gt;

&lt;p&gt;I principali framework PHP, pur fornendo dei layer di astrazione del protocollo HTTP maturi e funzionali, impongono la scrittura di codice da essi dipendente.&lt;/p&gt;

&lt;p&gt;Questo vuol dire che &lt;strong&gt;tutto il codice&lt;/strong&gt; che implementa le logiche applicative, anche se ben definito e isolato, &lt;strong&gt;dovrà essere adattato per ciascun framework&lt;/strong&gt;, a discapito di un&amp;rsquo;evidente similarità operativa, come per esempio:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;il recupero delle informazioni dalle variabili del server per costruire la richiesta&lt;/li&gt;
&lt;li&gt;il parsing degli header e del body della richiesta&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;aggiunta di uno o più header alla risposta&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;impostazione dello status code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Immaginiamo di voler scrivere un applicativo che abbia questi requisiti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aggiunge un header personalizzato alla risposta, &lt;code&gt;X-GREETINGS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;header deve contenere un messaggio personalizzato in base all&amp;rsquo;orario della richiesta&lt;/li&gt;
&lt;li&gt;l&amp;rsquo;header deve essere aggiunto solo in base agli headers inviati ed il verbo HTTP (ad es. solo per le richieste GET)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Decidiamo di scrivere le linee di codice necessarie con &lt;strong&gt;Symfony2&lt;/strong&gt; e &lt;strong&gt;Zend Framework 2&lt;/strong&gt;, per poi muoverci verso &lt;strong&gt;una sola soluzione ipoteticamente riutilizzabile&lt;/strong&gt; in ciascuno dei due contesti.&lt;/p&gt;

&lt;p&gt;Diamo per scontato di avere a disposizione un servizio che dato un orario determini con che formula salutarci:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php

namespace Acme\Utils;

class GreetingSentence
{
  public static function compose(\DateTime $time, $name)
  {  		  
            $msg = &amp;quot;Ciao $name&amp;quot;;  
			$hour = (int)$time-&amp;gt;format(&#39;h&#39;);				

			if ($hour &amp;gt;= 20 &amp;amp;&amp;amp; $hour &amp;lt; 6) {
				return $msg + &#39; buonanotte!&#39;;
			} else if ($hour &amp;gt;= 6 &amp;amp;&amp;amp; $hour &amp;lt; 13) {
				return $msg + &#39; buongiorno!&#39;;
			} else if ($hour &amp;gt;= 13 &amp;amp;&amp;amp; $hour &amp;lt; 18) {
				return $msg + &#39; buon pomeriggio!&#39;;	
			} else if ($hour &amp;gt;= 18 &amp;amp;&amp;amp; $hour &amp;lt; 20) {
				return $msg + &#39; buonasera!&#39;;
			} else {
            	return $msg + &#39; c\&#39;è vita su Marte!&#39;;
            }						
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;symfony-2:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Symfony 2&lt;/h6&gt;

&lt;p&gt;Ecco come implementeremmo la funzionalità richiesta in Symfony2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php 

namespace Acme\HelloYouBundle\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Acme\Utils\GreetingSentence;

class MainController 
{	
	/**
	 * @param string $name
	 * @param Request $request
     */
	public function greetAction(Request $request)
	{
        $response = new Response();

        if ($request-&amp;gt;isMethod(&#39;GET&#39;)) {
            $name = $request
                -&amp;gt;server
                -&amp;gt;get(&#39;HTTP_USER_AGENT&#39;&#39;);

            $requestTimeStamp = $request
                -&amp;gt;server
                -&amp;gt;get(&#39;REQUEST_TIME&#39;);

            $requestTime = new \DateTime();
            $requestTime-&amp;gt;setTimestamp($requestTimeStamp);

            $msg = GreetingSentence::compose($requestTime, $name);		
			$response-&amp;gt;headers-&amp;gt;set(&#39;X-GREETINGS&#39;, $msg);
        }

        return $response;
    }
} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&#34;zend-framework-2:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Zend Framework 2&lt;/h6&gt;

&lt;p&gt;Questa è invece l&amp;rsquo;implementazione in Zend Framework 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

namespace Acme\HelloYouModule\Controller;

use Zend\Mvc\Controller\AbstractActionController;
use Zend\View\Model\ViewModel;
use Acme\Utils\GreetingSentence;

class MainController extends AbstractActionController
{
	$response = $this-&amp;gt;getResponse();

	public function greetAction()
	{
    	if ($this-&amp;gt;getRequest()-&amp;gt;getMethod() == &#39;GET&#39;) {
          $name = $this
              -&amp;gt;getRequest()
              -&amp;gt;getServer(&#39;HTTP_USER_AGENT&#39;);

          $requestTimestamp = $this
              -&amp;gt;getRequest()
              -&amp;gt;getServer(&#39;REQUEST_TIME&#39;);

          $requestTime = new \DateTime();
          $requestTime-&amp;gt;setTimestamp($requestTimeStamp);

          $msg = GreetingSentence::compose($requestTime, $name);			
          $response-&amp;gt;setHeader(&#39;X-GREETINGS&#39;, $msg);
        }
	}
    
    $response-&amp;gt;send();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Risulta evidente come siamo stati a costretti ad implementare due pezzi di codice quasi identici. Vediamo ora &lt;strong&gt;come uno standard come quello proposto dal PSR-7 possa aiutarci&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&#34;middleware-ovvero-componenti-web-riutilizzabili:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Middleware: ovvero componenti web riutilizzabili&lt;/h4&gt;

&lt;p&gt;Potremmo voler implemenare la nostra soluzione come un &lt;strong&gt;middleware&lt;/strong&gt;, ovvero un componente che &lt;strong&gt;esiste durante il ciclo di vita di una comunicazione HTTP&lt;/strong&gt;, cioè dall&amp;rsquo;accettazione della richiesta fino all&amp;rsquo;evasione della risposta.&lt;/p&gt;

&lt;p&gt;Negli esempi precedenti abbiamo aggiunto il codice di gestione all&amp;rsquo;interno dei controller, e questa implementazione carica l&amp;rsquo;Action della responsabilità di esaminare la richiesta e comporre la risposta; questa operazione dovrà essere &lt;strong&gt;ripetuta in ogni controller&lt;/strong&gt; della nostra applicazione.&lt;/p&gt;

&lt;p&gt;Per fortuna i maggiori framework espongono astrazioni molto complete del ciclo di vita di una richiesta HTTP, che permettono di implementare il nostro middleware.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;in Symfony2 l&amp;rsquo;interfaccia &lt;a href=&#34;https://github.com/symfony/HttpKernel/blob/master/HttpKernelInterface.php&#34;&gt;HttpKernelInterface&lt;/a&gt; definisce un componenente capace di calcolare per una data una richiesta (Request) una determinata risposta (Response).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in Zend Framework l&amp;rsquo;interfaccia che definisce un componente capace di associare una richiesta ad una risposta si chiama &lt;a href=&#34;https://github.com/zendframework/zf2/blob/master/library/Zend/Stdlib/DispatchableInterface.php&#34;&gt;DispatchableInterface&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tuttavia se volessimo utilizzare lo stesso codice in Zend Framework 2 e Symfony2, dovremmo wrappare il codice necessario attorno a entrambe le interfacce oppure importare i componenti dell&amp;rsquo;uno nell&amp;rsquo;altro.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo cominciare a capire realmente il significato di questo nuovo processo di standardizzazione proposto dal &lt;a href=&#34;http://www.php-fig.org/&#34;&gt;&lt;strong&gt;FIG&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;scrivere-middleware-usando-le-interfacce-proposte-nello-standard-psr-7:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Scrivere middleware usando le interfacce proposte nello standard PSR-7&lt;/h4&gt;

&lt;p&gt;La proposta dello standard PSR-7 si riassume nella descrizione di una serie di &lt;a href=&#34;https://github.com/php-fig/http-message/tree/master/src&#34;&gt;interfacce&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Attualmente Matthew Weier O&amp;rsquo;Phinney, membro attivo del FIG e main contributor di Zend Framework 2 sta realizzando un&amp;rsquo;&lt;a href=&#34;https://github.com/phly/http/tree/master/src&#34;&gt;implementazione&lt;/a&gt; completa di queste interfacce.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo scrivere il codice di un middleware, aderendo alle specifiche PSR-7, come una semplice classe capace di interpretare una richiesta e costruire una risposta secondo le nostre necessità:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php

use phly\http\ServerRequestFactory;
use phly\http\ServerRequest;
use phly\http\Response;

class AcmeLifeCycle
{
    /**
    * @param ServerRequest|null $request
    * @param Response|null $response
    *
    * @return Response
    */
    public function doSomething(ServerRequest $request = null, Response $response = null)
    {
        if (is_null($request)) {
            /** @var ServerRequest $request */
            $request = ServerRequestFactory::fromGlobals();
        }

        /** @var Response $response */
        if (is_null($request)) {
            /** @var Response $response */
            $response = new Response();
        }

        if ($request-&amp;gt;getMethod() === &#39;GET&#39;) {
            $serverParams = $request-&amp;gt;getServerParams();
            $name = $serverParams[&#39;HTTP_USER_AGENT&#39;];

            $requestTimeStamp = $serverParams[&#39;REQUEST_TIME&#39;];

            $requestTime = new \DateTimeImmutable();
            $requestTime
                -&amp;gt;setTimestamp($requestTimeStamp);

            $msg = GreetingSentence::compose($requestTime, $name);

            //Questo metodo è un costruttore di copia
            $response = $response-&amp;gt;withHeader(&#39;X-GREETINGS&#39;, $msg);
        }

        return $response;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Da notare che sia la classe &lt;code&gt;Response&lt;/code&gt; che &lt;code&gt;ServerRequest&lt;/code&gt; implementano lo stesso trait &lt;code&gt;Message&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;La classe &lt;code&gt;Message&lt;/code&gt; è stata volutamente concepita affinchè sia &lt;strong&gt;immutabile&lt;/strong&gt; ed i vari metodi &lt;code&gt;-&amp;gt;withX()&lt;/code&gt; restituiranno solo copie modificate dell&amp;rsquo;oggetto inizialmente istanziato.&lt;/p&gt;

&lt;p&gt;Ovviamente questo middleware adesso come adesso è tutt&amp;rsquo;altro che utilizzabile all&amp;rsquo;interno di un framework, poichè ciascun vendor usa un modello diverso per richieste e risposte, ma è molto probabile che &lt;strong&gt;in un futuro&lt;/strong&gt; non troppo lontano le varie implementazioni &lt;strong&gt;convergeranno&lt;/strong&gt; su qualcosa di simile a quella appena vista e proposta da O&amp;rsquo;Phinney.&lt;/p&gt;

&lt;h4 id=&#34;conclusioni:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Conclusioni&lt;/h4&gt;

&lt;p&gt;Se pensiamo agli strumenti forniti di base dal linguaggio PHP (e non ai framework) nel contesto di una comunicazione HTTP, ci rendiamo conto che di fatto dovremmo ridurci a lavorare con le sole variabili globali d&amp;rsquo;ambiente contenenti tutti i valori necessari (&lt;code&gt;$_SERVER&lt;/code&gt;, &lt;code&gt;$_GET&lt;/code&gt;, &lt;code&gt;$_POST&lt;/code&gt;, &lt;code&gt;$_FILES&lt;/code&gt;, &amp;hellip;).&lt;/p&gt;

&lt;p&gt;Invece, grazie a PSR-7, potremmo &lt;strong&gt;standardizzare la rappresentazione degli oggetti coinvolti nel ciclo richiesta\riposta&lt;/strong&gt; (cioè i messaggi HTTP), e poter finalmente sviluppare componenti &lt;strong&gt;middleware indipendenti&lt;/strong&gt; dal framework utilizzato, il cui unico presupposto esistenziale è quello di &lt;strong&gt;gestire messaggi HTTP tramite il linguaggio PHP&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Sicuramente tenere &lt;a href=&#34;https://github.com/php-fig/fig-standards&#34;&gt;a portata di github&lt;/a&gt; gli sviluppi di questa proposta vorrà dire tenersi aggiornati sui &lt;strong&gt;futuri sviluppi&lt;/strong&gt; dei più blasonati framework e componenti PHP, tenendo conto, &lt;strong&gt;come già accaduto per le precedenti proposte&lt;/strong&gt; &lt;a href=&#34;https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md&#34;&gt;PSR-0&lt;/a&gt; e &lt;a href=&#34;https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md&#34;&gt;PSR-4&lt;/a&gt; (autoloading) e &lt;a href=&#34;https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md&#34;&gt;PSR-3&lt;/a&gt; (logging), che, quasi sicuramente, i principali vendor le implementeranno nelle loro prossime versioni.&lt;/p&gt;

&lt;h4 id=&#34;altre-risorse-consultabili:b7534f9229b77879ebc400f1bfdf8842&#34;&gt;Altre risorse consultabili&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Blog di Matthew Weier O&amp;rsquo;Phinney: &lt;a href=&#34;https://mwop.net/blog/2015-01-08-on-http-middleware-and-psr-7.html&#34;&gt;https://mwop.net/blog/2015-01-08-on-http-middleware-and-psr-7.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Specifiche PSR-7: &lt;a href=&#34;https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md&#34;&gt;https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Interfacce proposte dalla PSR-7: &lt;a href=&#34;https://github.com/php-fig/http-message&#34;&gt;https://github.com/php-fig/http-message&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Implementazione di Matthew Weier O&amp;rsquo;Phinney: &lt;a href=&#34;https://github.com/phly/http/tree/master/src&#34;&gt;https://github.com/phly/http/tree/master/src&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Michael Dowling spiega la streaming interface: &lt;a href=&#34;http://mtdowling.com/blog/2014/07/03/a-case-for-higher-level-php-streams/&#34;&gt;http://mtdowling.com/blog/2014/07/03/a-case-for-higher-level-php-streams/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>