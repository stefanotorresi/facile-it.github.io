<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software testing on Facile.it Engineering</title>
    <link>http://engineering.facile.it/categories/software-testing/</link>
    <description>Recent content in Software testing on Facile.it Engineering</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Jun 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://engineering.facile.it/categories/software-testing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swift testing avanzato: stubbing e test asincroni</title>
      <link>http://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</link>
      <pubDate>Fri, 05 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/swift-testing-avanzato-stubbing-e-test-asincroni/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://engineering.facile.it/xcode-testing-in-pratica/&#34;&gt;In un precedente articolo&lt;/a&gt; abbiamo visto le impostazioni di base in Xcode per la scrittura dei &lt;strong&gt;test unitari&lt;/strong&gt;: abbiamo evidenziato inoltre &lt;strong&gt;l&amp;rsquo;importanza e l&amp;rsquo;utilità intrinseca dei test&lt;/strong&gt;, attraverso un semplice esempio riguardante un caso d&amp;rsquo;uso tipico. Nel presente articolo vedremo alcune tecniche un po&amp;rsquo; più avanzate:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implementeremo uno &lt;strong&gt;Stub Object&lt;/strong&gt; in Swift;&lt;/li&gt;
&lt;li&gt;analizzeremo un altro caso di test &lt;em&gt;asincrono&lt;/em&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lo-stub-object&#34;&gt;Lo &lt;em&gt;Stub Object&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Uno &lt;em&gt;Stub Object&lt;/em&gt; (per il resto dell&amp;rsquo;articolo, &lt;em&gt;stub&lt;/em&gt;) rappresenta un&amp;rsquo;istanza di una certa classe, la quale &lt;em&gt;mima&lt;/em&gt; una vera classe presente nella nostra &lt;em&gt;code base&lt;/em&gt;:  l&amp;rsquo;istanza si comporta esattamente come una equivalente istanza della classe mimata, tranne alcune differenze, ad esempio &lt;strong&gt;alcuni metodi possono essere sovrascritti&lt;/strong&gt; per poter fornire &lt;strong&gt;un determinato output&lt;/strong&gt; utile per i test. Nell&amp;rsquo;implementare uno &lt;em&gt;stub&lt;/em&gt; non è generalmente consentito modificare dettagli di logica interni relativi alla classe che stiamo mimando, ma &lt;strong&gt;è possibile sovrascrivere metodi pubblici&lt;/strong&gt;, in modo che essi ritornino i valori che vogliamo, oppure che svolgano una particolare procedura necessaria per i test. Tanto per fare un esempio pratico potremmo &lt;em&gt;stubbare&lt;/em&gt; una classe che ci fornisce la data precisa in un certo istante, in modo da ottenere una data diversa da usare nei test, oppure un client che chiede a un server delle informazioni su un utente, in modo da far ritonare al client &lt;em&gt;stub&lt;/em&gt; delle informazioni arbitrarie.&lt;/p&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; fanno parte di una classe di strumenti che sono usati nell&amp;rsquo;ambito dello &lt;em&gt;Unit Testing&lt;/em&gt; per verificare che determinati oggetti rispettino precisi &lt;strong&gt;contratti&lt;/strong&gt; stipulati tra essi: il classico articolo di Martin Fowler &lt;a href=&#34;http://martinfowler.com/articles/mocksArentStubs.html&#34;&gt;Mocks Aren&amp;rsquo;t Stubs&lt;/a&gt; è solitamente considerato un buon punto di riferimento per comprendere i possibili strumenti usati a tal scopo. L&amp;rsquo;idea è che, dal punto di vista dei nostri test unitari, un oggetto risulterà essere &lt;em&gt;correttamente implementato&lt;/em&gt; se avrà rispettato la sua parte del &lt;em&gt;contratto&lt;/em&gt; stipulato con altri oggetti, con la seguente conseguenza:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;se l&amp;rsquo;oggetto A è correttamente implementato e l&amp;rsquo;oggetto B rispetta il contratto stipulato con l&amp;rsquo;oggetto A, allora anche l&amp;rsquo;oggetto B è correttamente implementato&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Gli &lt;em&gt;stub&lt;/em&gt; permettono di &lt;strong&gt;disaccoppiare le logiche di funzionamento degli oggetti&lt;/strong&gt; perché, se abbiamo verificato il corretto funzionamento dell&amp;rsquo;oggetto A (attraverso appropriati test unitari), possiamo usare uno &lt;em&gt;stub&lt;/em&gt; di tale oggetto per verificare il corretto funzionamento dell&amp;rsquo;oggetto B nei suoi confronti, eliminando qualsiasi dipendenza di B nei confronti della logica interna dell&amp;rsquo;oggetto A. L&amp;rsquo;obiettivo è scrivere quindi dei &lt;strong&gt;test veramente unitari&lt;/strong&gt; per l&amp;rsquo;oggetto B, anche se questo dipende dall&amp;rsquo;oggetto A. Il classico talk &lt;a href=&#34;https://vimeo.com/80533536&#34;&gt;Integration Tests are a scam&lt;/a&gt; di J.B. Rainsberger fornisce un punto di vista particolarmente &amp;ldquo;radicale&amp;rdquo; sull&amp;rsquo;argomento.&lt;/p&gt;

&lt;p&gt;Il classico caso in cui uno &lt;em&gt;stub&lt;/em&gt; risulta utile è quello del client che fa una richiesta al server: se la logica di implementazione del server è sotto il nostro controllo possiamo &lt;strong&gt;testare che il server rispetti il contratto con i suoi client&lt;/strong&gt; generando degli &lt;em&gt;stub&lt;/em&gt; di questi per ogni possibile richiesta; d&amp;rsquo;altra parte, per verificare che i client siano in grado di &lt;strong&gt;gestire correttamente ogni possibile risposta del server&lt;/strong&gt;, possiamo generare uno &lt;em&gt;stub&lt;/em&gt; del server che fornisca ogni possibile risposta: in questo modo possiamo testare in maniera disaccoppiata client e server.&lt;/p&gt;

&lt;h2 id=&#34;un-caso-d-uso-location-services&#34;&gt;Un caso d&amp;rsquo;uso: &lt;em&gt;Location Services&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Il caso d&amp;rsquo;uso che tratteremo è relativo ai &lt;strong&gt;servizi di localizzazione&lt;/strong&gt;, uno strumento frequentemente utilizzato dagli sviluppatori iOS e in generale da chi sviluppa su &lt;strong&gt;smartphone&lt;/strong&gt;: per tali sviluppatori, quello dei servizi di localizzazione è un tema molto importante, &lt;strong&gt;fonte di complessità e sfide&lt;/strong&gt; che caratterizzano tipicamente il mondo &lt;em&gt;mobile&lt;/em&gt;. Non è infatti possibile ottenere l&amp;rsquo;attuale posizione GPS in un preciso momento: l&amp;rsquo;ultima posizione GPS disponibile si basa su una regressione, effettuata dal sistema, dei dati ricevuti da diversi sensori - antenne wifi, cellulare e ovviamente GPS, e spesso anche i sensori di movimento - in diversi momenti; &lt;strong&gt;il sistema può inviare notifiche alla nostra app in qualsiasi momento&lt;/strong&gt;, ed essa deve essere in grado di &amp;ldquo;digerire&amp;rdquo; correttamente i dati ricevuti, interpretando anche eventuali errori. Scrivere dei test unitari per verificare che la nostra app geolocalizzata funzioni correttamente può presentare non poche difficoltà: non possiamo infatti affidarci ai &amp;ldquo;veri&amp;rdquo; sensori del dispositivo, perché probabilmente i test verranno eseguiti sul simulatore, oppure magari su un vero iPhone la cui ricezione GPS in un certo istante potrà essere più o meno buona, ma essa rappresenterà un solo caso possibile rispetto a tanti. Vogliamo essere in grado di &lt;strong&gt;testare ogni possibile risposta&lt;/strong&gt; del sistema GPS del dispositivo, dall&amp;rsquo;assenza totale di segnale al cambiamento frequente di posizione, alla &lt;strong&gt;mancata autorizzazione&lt;/strong&gt; da parte dell&amp;rsquo;utente per l&amp;rsquo;accesso ai servizi di localizzazione.&lt;/p&gt;

&lt;p&gt;Supponiamo ad esempio che una certa classe, diciamo un &lt;code&gt;UIViewController&lt;/code&gt;, esegua delle &lt;strong&gt;azioni che dipendono dalla posizione ricevuta&lt;/strong&gt;. L&amp;rsquo;idea è quella di testare che il nostro &lt;code&gt;UIViewController&lt;/code&gt; si comporti &amp;ldquo;bene&amp;rdquo; rispetto alle notifiche del sistema di localizzazione. Il progetto Xcode contenente il codice mostrato in questo articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/AsyncTestingStubbing&#34;&gt;GitHub&lt;/a&gt;: si consiglia di scaricare il progetto e tenerlo a riferimento per il resto dell&amp;rsquo;articolo.&lt;/p&gt;

&lt;p&gt;Invece di usare direttamente &lt;code&gt;CLLocationManager&lt;/code&gt; per ottenere la posizione GPS del dispositivo, implementeremo una semplice classe che fungerà da &lt;em&gt;wrapper&lt;/em&gt;, chiamata &lt;code&gt;LocationCoordinator&lt;/code&gt;: un&amp;rsquo;istanza di tale classe potrà essere configurata con due semplici funzioni &lt;code&gt;onUpdate&lt;/code&gt; e &lt;code&gt;onFailure&lt;/code&gt;, in modo da evitare l&amp;rsquo;implementazione dei vari metodi di callback del &lt;code&gt;protocol&lt;/code&gt; &lt;code&gt;CLLocationManagerDelegate&lt;/code&gt;. L&amp;rsquo;idea è quella di passare un&amp;rsquo;istanza di &lt;code&gt;LocationCoordinator&lt;/code&gt; al nostro &lt;code&gt;UIViewController&lt;/code&gt;: quest&amp;rsquo;ultimo quindi imposterà le due funzioni di callback indicate sopra, in modo da modificare il suo stato e i dati mostrati all&amp;rsquo;utente.&lt;/p&gt;

&lt;p&gt;Di seguito è riportato il codice della classe &lt;code&gt;LocationCoordinator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import CoreLocation

public class LocationCoordinator: NSObject {
    
    public let locationManager: CLLocationManager
    
    public override init() {
        locationManager = CLLocationManager()
        super.init()
        locationManager.delegate = self
        locationManager.requestWhenInUseAuthorization()
    }
    
    private var updated: (CLLocation -&amp;gt; ())?
    public func onUpdate(value: CLLocation -&amp;gt; ()) {
        updated = value
    }
    
    private var failed: (NSError -&amp;gt; ())?
    public func onFailure(value: NSError -&amp;gt; ()) {
        failed = value
    }
}

extension LocationCoordinator: CLLocationManagerDelegate {
    
    public func locationManager(manager: CLLocationManager!, didUpdateLocations locations: [AnyObject]!) {
        let location = locations.last as! CLLocation
        if let updated = self.updated {
            updated(location)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didFailWithError error: NSError!) {
        if let failed = self.failed {
            failed(error)
        }
    }
    
    public func locationManager(manager: CLLocationManager!, didChangeAuthorizationStatus status: CLAuthorizationStatus) {
        switch status {
        case .AuthorizedWhenInUse:
            locationManager.startUpdatingLocation()
        default:
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si può vedere, la classe è configurata per richiedere l&amp;rsquo;autorizzazione a leggere la posizione GPS del dispositivo quando l&amp;rsquo;app è in uso, ma non sarà necessario fornire questa autorizzazione per i test: creeremo infatti uno &lt;em&gt;stub&lt;/em&gt; che genererà posizioni arbitrarie, senza usare i sensori di sistema. Si ricorda inoltre che usando iOS SDK &amp;gt;= 8.0, per usare i servizi di localizzazione sarà necessario inserire nel file Info.plist una chiave che descrive il motivo per il quale l&amp;rsquo;app chiede l&amp;rsquo;autorizzazione ad accedere a tali servizi:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/swift-testing-avanzato-stubbing-e-test-asincroni/locationUsageDescription.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sebbene l&amp;rsquo;aggiunta della chiave &lt;code&gt;NSLocationWhenIsUseUsageDescription&lt;/code&gt; non sia necessaria per eseguire i test, senza questa chiave l&amp;rsquo;app non potrà funzionare in iOS8 nel caso in cui provassimo ad avviarla normalmente.&lt;/p&gt;

&lt;p&gt;La classe di cui vogliamo testare il corretto funzionamento è indicata nel progetto con il nome di &lt;code&gt;LocationViewController&lt;/code&gt;, e il suo scopo è mostrare le attuali coordinate GPS dell&amp;rsquo;utente o mostrare un messaggio in caso di errore: un sua istanza è, in ogni instante, caratterizzata da un &lt;code&gt;LocationState&lt;/code&gt; che rappresenta in quale stato essa si trova rispetto alla ricerca della posizione GPS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public enum LocationState {
    case Searching
    case Found
    case Error(CLError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementiamo-i-test&#34;&gt;Implementiamo i test&lt;/h2&gt;

&lt;p&gt;Per testare la classe verificheremo che, a seconda dei diversi possibili risultati ottenibili dalla ricerca della posizione GPS, un&amp;rsquo;istanza di essa &lt;strong&gt;aggiorni correttamente il suo stato attuale&lt;/strong&gt;. È quindi necessario fare in modo che un&amp;rsquo;istanza del &lt;code&gt;LocationCoordinator&lt;/code&gt; ignori le notifiche ricevute da &lt;code&gt;CLLocationManager&lt;/code&gt;, in modo da forzare posizioni ed errori comodi per i nostri test; per farlo dichiariamo una sottoclasse di &lt;code&gt;LocationCoordinator&lt;/code&gt; chiamata &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt; che modifichi la &lt;em&gt;parent class&lt;/em&gt; nel seguente modo:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ignora le notifiche del &lt;code&gt;locationManager&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;locationManager.stopUpdatingLocation()
locationManager.delegate = nil
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;dichiara 4 funzioni per forzare posizione GPS e/o errori:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;forceLocation
forceError
forceRandomDelayedLocations
forceDelayedErrorLocationUnknown
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ciascuna di queste funzioni genera le stesse notifiche che normalmente genererebbe &lt;code&gt;CLLocationManager&lt;/code&gt;. Le prime due funzioni, &lt;code&gt;forceLocation&lt;/code&gt; e &lt;code&gt;forceError&lt;/code&gt; forzano immediatamente una certa posizione GPS o un certo errore, mentre la funzione &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; genera una serie di posizioni casuali dopo un certo ritardo e a intervalli regolari, e la funzione &lt;code&gt;forceDelayedErrorLocationUnknown&lt;/code&gt; forza un errore del tipo &lt;code&gt;.LocationUnknown&lt;/code&gt; dopo un certo ritardo.&lt;/p&gt;

&lt;p&gt;Prima di procedere con i test osserviamo che nel file &lt;code&gt;AsyncTestingStubbingTests.swift&lt;/code&gt; c&amp;rsquo;è una sezione &lt;em&gt;utility&lt;/em&gt; nella quale sono implementate alcune funzioni comode per &lt;strong&gt;rendere  il codice dei test più espressivo&lt;/strong&gt;. Ad esempio la funzione &lt;code&gt;mainViewController&lt;/code&gt; ritorna l&amp;rsquo;istanza del LocationViewController utilizzata nell&amp;rsquo;interfaccia grafica nell&amp;rsquo;app. Il &lt;em&gt;testing framework&lt;/em&gt; integrato in Xcode è chiamato &lt;code&gt;XCTest&lt;/code&gt;, e per quanto adeguatamente completo nelle sue funzionalità, esso è principalmente basato su funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt; che verificano che una qualche condizione sia vera, e se non lo è stampano in console un messaggio di errore passato alla stessa funzione &lt;code&gt;XCTAssert&lt;/code&gt; nel momento in cui essa è chiamata: questo può portare alla scrittura di &lt;strong&gt;test verbosi e poco espressivi&lt;/strong&gt;. Ci sono diverse librerie facilmente integrabili nei progetti Xcode che semplificano la scrittura dei nostri &lt;em&gt;assert&lt;/em&gt;, come ad esempio &lt;a href=&#34;https://github.com/Quick/Nimble&#34;&gt;Nimble&lt;/a&gt;, ma come si può vedere dalle poche funzioni di utility implementate nel progetto associato a questo articolo, basta poco per migliorare consistentemente la leggibilità dei nostri test.&lt;/p&gt;

&lt;p&gt;A questo punto possiamo procedere all&amp;rsquo;implementazione dei test. Le funzioni &lt;code&gt;testLocation&lt;/code&gt; e &lt;code&gt;testError&lt;/code&gt; testano semplicemente che lo stato del &lt;code&gt;mainViewController&lt;/code&gt; sia corretto prima e dopo la generazione di una posizione GPS e di un errore arbitrari. Tuttavia questi test non permettono di rappresentare correttamente un caso d&amp;rsquo;uso tipico, perché &lt;strong&gt;le notifiche sulla posizione GPS posso arrivare in qualsiasi momento&lt;/strong&gt;, e il &lt;code&gt;LocationViewController&lt;/code&gt; deve essere in grado di &lt;em&gt;reagire&lt;/em&gt; alle notifiche nel momento in cui queste si presentano. Per simulare la cosa useremo due test &lt;em&gt;asincroni&lt;/em&gt;, cioè test il cui risultato non è ottenuto immediatamente, ma dopo un certo tempo: l&amp;rsquo;idea è quella di &amp;ldquo;mettere in pausa&amp;rdquo; i test per un certo numero di secondi, finché non si verifica una certa condizione oppure non scade il tempo: in quest&amp;rsquo;ultimo caso il test verrà considerato &lt;strong&gt;fallito&lt;/strong&gt; da &lt;code&gt;XCTest&lt;/code&gt; perché la condizione attesa non si è verificata entro il tempo richiesto.&lt;/p&gt;

&lt;p&gt;Riportiamo ad esempio il codice della funzione &lt;code&gt;testDelayedLocation&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDelayedLocation() {
        if let vc = mainViewController() {
            let locationExpectation = expectationWithDescription(&amp;quot;locationExpectation&amp;quot;)
            let coordinator = STUB_LocationCoordinator()
            vc.showLocationWithCoordinator(coordinator)
            vc.locationState.assertState(.Searching)
            coordinator.forceRandomDelayedLocations(0.25, times:3)
            after(0.5) {
                vc.locationState.assertState(.Found)
                after(0.25) {
                    vc.locationState.assertState(.Found)
                    locationExpectation.fulfill()
                }
            }
            vc.locationState.assertState(.Searching)
            waitForExpectationsWithTimeout(1, handler: nil)
        }
        else {
            fail(&amp;quot;this will never happen&amp;quot;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La funzione di utility &lt;code&gt;after&lt;/code&gt; semplicemente esegue del codice dopo un certo numero di secondi: in base all&amp;rsquo;implementazione di &lt;code&gt;forceRandomDelayedLocations&lt;/code&gt; presente in &lt;code&gt;STUB_LocationCoordinator&lt;/code&gt;, il &lt;code&gt;LocationViewController&lt;/code&gt; dovrebbe  ricevere alcune posizioni GPS a intervalli regolari dopo un certo ritardo, e per verificarlo inseriamo due &lt;em&gt;assert&lt;/em&gt;, dopo mezzo secondo e poi ancora un quarto di secondo. Per realizzare il test asincrono  definiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt;, quindi una &amp;ldquo;aspettativa&amp;rdquo;, chiamata &lt;code&gt;locationExpectation&lt;/code&gt;: in coda al codice di test chiamiamo la funzione &lt;code&gt;waitForExpectationsWithTimeout&lt;/code&gt; che fa continuare la funzione di test - senza che essa &lt;em&gt;ritorni&lt;/em&gt; - fino alla &amp;ldquo;realizzazione&amp;rdquo; delle aspettative, tenendo conto di un certo tempo di timeout. Quindi, per &amp;ldquo;realizzare&amp;rdquo; un&amp;rsquo;aspettativa, chiamiamo la funzione &lt;code&gt;fulfill&lt;/code&gt; su &lt;code&gt;locationExpectation&lt;/code&gt;, ma solo dopo aver verificato che lo stato del &lt;code&gt;LocationViewController&lt;/code&gt; sia quello corretto.&lt;/p&gt;

&lt;p&gt;Possiamo estendere ulteriormente la &lt;em&gt;test suite&lt;/em&gt; implementando altri test che simulano ogni tipo di errore possibile, oppure che simulano una situazione in cui posizioni GPS e errori si alternano: una volta compresa la struttura di base per realizzare &lt;em&gt;stub&lt;/em&gt; e test asincroni sarà facile migliorare la &lt;a href=&#34;http://engineering.facile.it/software-testing-coverage-vs-efficacia/&#34;&gt;coverage&lt;/a&gt; dei nostri test.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Xcode Testing in pratica</title>
      <link>http://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</link>
      <pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/xcode-testing-in-pratica/</guid>
      <description>

&lt;p&gt;Tra i molti strumenti utili presenti in Xcode, il testing framework &lt;strong&gt;XCTest&lt;/strong&gt; è certamente uno dei più rilevanti, non solo per l&amp;rsquo;importanza intrinseca dello Unit Testing in generale, ma soprattutto per la facilità con la quale è possibile scrivere ed eseguire test direttamente dall&amp;rsquo;IDE &lt;em&gt;out-of-the-box&lt;/em&gt;, &lt;strong&gt;senza la necessità di installare componenti di terze parti&lt;/strong&gt; o impostare una particolare configurazione per i progetti.&lt;/p&gt;

&lt;p&gt;In effetti Xcode, al momento della creazione di un nuovo progetto, oltre a creare un target per il binario principale crea automaticamente anche un &lt;strong&gt;target di test&lt;/strong&gt;, cioè un bundle aggiuntivo che può essere caricato nel bundle principale per poter fisicamente eseguire i test una volta avviata l&amp;rsquo;app. Nell&amp;rsquo;immagine seguente è possibile vedere come, in un progetto appena creato, sia già presente il test bundle, in questo caso chiamato &lt;em&gt;AwesomeAppTests.xctest&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Come mostrato nell&amp;rsquo;immagine, Xcode ha anche creato automaticamente il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, all&amp;rsquo;interno del quale potremo iniziare a scrivere i nostri test.&lt;/p&gt;

&lt;h2 id=&#34;setup-dell-ambiente-di-test&#34;&gt;Setup dell&amp;rsquo;ambiente di test&lt;/h2&gt;

&lt;p&gt;Al di là del meccanismo con il quale il testing avviene, è importante capire che il codice con il quale i test sono stati scritti è compilato in un bundle diverso, e per far sì che i test &amp;ldquo;vedano&amp;rdquo; il resto dell&amp;rsquo;app, è necessario seguire le &lt;a href=&#34;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html&#34;&gt;regole di access control tra i moduli in Swift&lt;/a&gt;; quindi classi, struct, funzioni, costanti e così via che abbiamo dichiarato e implementato nella nostra app, o libreria che sia, &lt;strong&gt;dovranno essere marcati con la keyword *public&lt;/strong&gt;*:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func sumOfInts (x: Int, y: Int) -&amp;gt; Int {
    return x + y
}
    
public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In questo modo, qualsiasi modulo esterno che importerà il modulo costituito dalla nostra app potrà vedere la firma della funzione &lt;code&gt;sumOfInts&lt;/code&gt; e della classe &lt;code&gt;AwesomeItem&lt;/code&gt;. Per importare nei file di testing nel modulo dell&amp;rsquo;app sarà sufficiente scrivere &lt;code&gt;import AwesomeApp&lt;/code&gt; all&amp;rsquo;inizio del file. Aggiungiamo al progetto un file .swift, inserendo il codice appena visto: useremo questo file per scrivere tutto il codice da testare.&lt;/p&gt;

&lt;p&gt;Apriamo quindi il file &lt;em&gt;AwesomeAppTests.swift&lt;/em&gt;, importiamo il modulo &lt;code&gt;AwesomeApp&lt;/code&gt;, eliminiamo le due funzioni di test di esempio, che hanno il solo scopo di presentare la sintassi di base dei test all&amp;rsquo;utente, e scriviamo un test banale per la funzione &lt;code&gt;sumOfInts&lt;/code&gt;; avremo quindi qualcosa del genere:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
    override func setUp() {
        super.setUp()
        // Put setup code here. This method is called before the invocation of each test method in the class.
    }
    
    override func tearDown() {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
        super.tearDown()
    }
    
    func testSumOfInts() {
        /// test the sumOfIntsFunction
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Xcode ha identificato la funzione &lt;code&gt;testSumOfInts&lt;/code&gt; come &lt;strong&gt;una funzione di test&lt;/strong&gt; perché il suo nome inizia con &amp;ldquo;test&amp;rdquo;, e ha posizionato un pulsante di avvio test proprio di fianco alla sua dichiarazione:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_2.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per far eseguire a Xcode questo test, e solo questo, sarà sufficiente cliccare su quel pulsante. In alternativa sarà possibile selezione &amp;ldquo;Test&amp;rdquo; dal menu &amp;ldquo;Product&amp;rdquo; per far eseguire a Xcode tutti i test che l&amp;rsquo;IDE ha riconosciuto. Xcode offre anche un &lt;strong&gt;Test Navigator&lt;/strong&gt;, che mostra il nome di tutti i test implementati, raggruppati per &lt;em&gt;Test Case&lt;/em&gt;: spostando il puntatore del mouse su un test apparirà un pulsante a forma di freccia che permetterà di avviare singolarmente i test, oppure tutti i test relativi a un particolare &lt;em&gt;Test Case&lt;/em&gt;, o anche tutti i test scritti.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_3.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Per poter eseguire i test, Xcode deve effettivamente avviare l&amp;rsquo;app: selezioniamo uno dei simulatori disponibili in modo che a ogni avvio di test Xcode apra automaticamente il simulatore scelto.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/xcode-testing-in-pratica/image_4.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;xctestcase-e-xctassert&#34;&gt;XCTestCase e XCTAssert&lt;/h2&gt;

&lt;p&gt;Nel framework &lt;strong&gt;XCTest&lt;/strong&gt; un &lt;em&gt;Test Case&lt;/em&gt; è rappresentato da una sottoclasse della classe &lt;code&gt;XCTestCase&lt;/code&gt;: al momento dell&amp;rsquo;avvio dei test viene automaticamente generata un&amp;rsquo;istanza di ciascun Test Case che abbiamo implementato, e vengono eseguiti uno a uno tutti i test dichiarati, avviando le funzioni &lt;code&gt;testSomething()&lt;/code&gt; che li implementano. Anche i metodi &lt;code&gt;setUp()&lt;/code&gt; e &lt;code&gt;tearDown()&lt;/code&gt; sono chiamati automaticamente nel corso dei test: come indicano i commenti inseriti da Xcode, il metodo &lt;code&gt;setUp()&lt;/code&gt; è chiamato immediatamente prima di ogni test, e permette di inizializzare eventuali attributi d&amp;rsquo;istanza, o variabili globali; come è intuibile, il metodo &lt;code&gt;tearDown()&lt;/code&gt; permette di ripristinare eventualmente lo stato iniziale dopo ciascun test. L&amp;rsquo;implementazione di questi due metodi è comunque del tutto opzionale: essi rappresentano semplicemente degli strumenti in più.&lt;/p&gt;

&lt;p&gt;Poiché &lt;strong&gt;i nostri Test Case sono effettivamente delle classi&lt;/strong&gt;, possiamo implementare anche altri metodi e attributi per ciascuna classe, che possono facilmente essere richiamati nei singoli test, come nel seguente esempio:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class AwesomeAppTests: XCTestCase {
    
		var firstInt = 0
		var secondInt = 0
		var expectedSum = 0

    override func setUp() {
        super.setUp()
        
				self.firstInt = 1
				self.secondInt = 2
				self.expectedSum = 3
    }
    
    override func tearDown() {
        self.firstInt = 0
				self.secondInt = 0
				self.expectedSum = 0
        super.tearDown()
    }
   	
    func testSumOfInts() {
				let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Come si vede dall&amp;rsquo;esempio, per testare la funzione &lt;code&gt;sumOfInts&lt;/code&gt; si è impiegata la funzione &lt;code&gt;XCTAssert&lt;/code&gt;: tale funzione rappresenta il blocco costruttivo di base per poter scrivere i nostri unit test, e prende in ingresso da 1 a 4 parametri: il primo parametro, l&amp;rsquo;unico obbligatorio, deve essere un&amp;rsquo;espressione la cui valutazione restituisce un valore Booleano true/false, mentre gli altri parametri, del tutto opzionali poiché caratterizzati da valori di default, rappresentano rispettivamente:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;un messaggio testuale che verrà mostrato in console nel caso in cui il test fallisca;&lt;/li&gt;
&lt;li&gt;il file all&amp;rsquo;interno del quale è presente il test fallito;&lt;/li&gt;
&lt;li&gt;la linea di codice in corrispondenza della quale è presente la funzione XCTAssert relativa al test fallito;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La libreria &lt;code&gt;XCTest&lt;/code&gt; dichiara molte diverse funzioni del tipo &lt;code&gt;XCTAssert&lt;/code&gt;, &lt;strong&gt;i cui casi di utilizzo sono chiaramente dedotti dal nome delle funzioni&lt;/strong&gt;: ad esempio la funzione &lt;code&gt;XCTAssertNil&lt;/code&gt; verifica che l&amp;rsquo;argomento, cioè il primo parametro, sia &lt;code&gt;nil&lt;/code&gt;; la funzione &lt;code&gt;XCTAssertGreaterThan&lt;/code&gt; prende due espressioni invece di una, la cui valutazione deve restituire un valore di tipo &lt;code&gt;Comparable&lt;/code&gt; - cioè che può essere confrontato con altri valori tramite gli operatori maggiore/minore e derivati - e verifica che il risultato della prima espressione sia maggiore del risultato della seconda.&lt;/p&gt;

&lt;p&gt;Sfruttando le altre funzioni &lt;code&gt;XCTAssert&lt;/code&gt;, possiamo estendere &lt;code&gt;testSumOfInts&lt;/code&gt; per includere altre verifiche su &lt;code&gt;sumOfInts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testSumOfInts() {
        
        XCTAssertEqual(sumOfInts(self.firstInt, self.secondInt), sumOfInts(self.secondInt, self.firstInt))

        let sum = sumOfInts(self.firstInt, self.secondInt)
        XCTAssert(sum == self.expectedSum)
        if self.firstInt &amp;lt; 0 &amp;amp;&amp;amp; self.secondInt &amp;lt; 0 {
            XCTAssertLessThan(sum, 0)
        }
        else {
            if self.firstInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.secondInt)
            }
            if self.secondInt &amp;lt; 0 {
                XCTAssertLessThan(sum, self.firstInt)
            }
            if self.firstInt &amp;gt;= 0 &amp;amp;&amp;amp; self.secondInt &amp;gt;= 0 {
                XCTAssertGreaterThanOrEqual(sum, 0)
                XCTAssertGreaterThanOrEqual(sum, self.firstInt)
                XCTAssertGreaterThanOrEqual(sum, self.secondInt)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;test-asincroni&#34;&gt;Test asincroni&lt;/h2&gt;

&lt;p&gt;La libreria XCTest include alcuni strumenti per eseguire &lt;strong&gt;test su computazioni asincrone&lt;/strong&gt;, cioè eseguite da funzioni che non ritornano immediatamente un valore ma che potrebbero chiamare una funzione di callback a un certo punto nel futuro. Per testare una funzione asincrona è necessario:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;creare un&amp;rsquo;istanza di &lt;code&gt;XCTestExpectation&lt;/code&gt;, un oggetto che rappresenta l&amp;rsquo;&lt;strong&gt;aspettativa&lt;/strong&gt; che ad un certo punto nel futuro accada qualcosa;&lt;/li&gt;
&lt;li&gt;informare l&amp;rsquo;istanza del &lt;code&gt;XCTestCase&lt;/code&gt;, generata automaticamente all&amp;rsquo;avvio dei test, che nel corso di un certo test è necessario che le &lt;em&gt;aspettative&lt;/em&gt; vengano &lt;em&gt;soddisfatte&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Per fare un esempio, aggiungiamo una semplice funzione pubblica a &lt;em&gt;AwesomeItem.swift&lt;/em&gt; che permette di scaricare un&amp;rsquo;immagine presente a un certo URL, e chiama una funzione callback restituendo appunto una &lt;code&gt;UIImage&lt;/code&gt; che rappresenti l&amp;rsquo;immagine scaricata: per semplicità non gestiremo gli errori, e nel caso in cui qualcosa vada storto otterremo semplicemente &lt;code&gt;nil&lt;/code&gt; al posto dell&amp;rsquo;immagine (quindi l&amp;rsquo;oggetto effettivamente ottenuto sarà di tipo &lt;code&gt;UIImage?&lt;/code&gt;, cioè un oggetto opzionale). Per poter manipolare &lt;code&gt;UIImage&lt;/code&gt; dobbiamo importare &lt;code&gt;UIKit&lt;/code&gt; in &lt;em&gt;AwesomeItem.swift&lt;/em&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation
import UIKit

public func sumOfInts (a: Int, b: Int) -&amp;gt; Int {
    return a + b
}

public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
}

public class AwesomeItem {
    var name: String? = nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Che si riesca a meno a scaricare l&amp;rsquo;immagine, la funzione di callback deve comunque essere chiamata in un tempo ragionevole, e l&amp;rsquo;obbiettivo del test asincrono sarà proprio quello di verificare che la tale funzione venga chiamata, ignorando  l&amp;rsquo;oggetto ottenuto per l&amp;rsquo;immagine. Segue una possibile implementazione per questo test, nella quale creiamo una &lt;code&gt;XCTestExpectation&lt;/code&gt; e impostiamo un&amp;rsquo;attesa di 5 secondi: è ovviamente possibile sincronizzare il tempo di attesa con il tempo di timeout della sessione di download creata, ma per semplicità imposteremo un tempo forfettario.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func testDownloadImageCallback() {
        
        let downloadImageCallbackExpectation = self.expectationWithDescription(&amp;quot;downloadImageCallbackExpectation&amp;quot;)
        
        let imageUrl = NSURL(string: &amp;quot;http://goo.gl/XYwppm&amp;quot;)!
        
        downloadImage(imageUrl) { image in
            downloadImageCallbackExpectation!.fulfill();
        }
        
        self.waitForExpectationsWithTimeout(5.0, handler: nil)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Se proviamo ad avviare il test cliccando sull&amp;rsquo;icona di avvio apparsa in Xcode proprio a sinistra della riga di dichiarazione della funzione, analogamente a quando mostrato prima, vedremo che Xcode rimarrà bloccato per 5 secondi prima di mostrare il messaggio &lt;code&gt;Asynchronous wait failed: Exceeded timeout of 5 seconds, with unfulfilled expectations: &amp;quot;downloadImageCallbackExpectation&amp;quot;.&lt;/code&gt;: come mai? Il fallimento del test ci informa subito del fatto che la funzione di download dell&amp;rsquo;immagine che abbiamo scritto ha qualche problema: è facile vedere che esso è dovuto al fatto che non abbiamo chiamato &lt;code&gt;resume()&lt;/code&gt; sulla task di download creata. Correggiamo quindi la nostra funzione &lt;code&gt;downloadImage&lt;/code&gt; nel seguente modo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public func downloadImage (imageURL: NSURL, callback: (UIImage?) -&amp;gt; ()) {
    let task = NSURLSession.sharedSession().downloadTaskWithRequest(NSURLRequest(URL: imageURL), completionHandler: { (tempLocalURL: NSURL!, response: NSURLResponse!, error: NSError!) -&amp;gt; Void in
        if let path = tempLocalURL?.path {
            let image = UIImage(contentsOfFile: path)
            NSFileManager.defaultManager().removeItemAtPath(path, error: nil)
            callback(image)
        }
        else {
            callback(nil)
        }
    })
    task.resume()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Il test ci ha immediatamente informati dell&amp;rsquo;errore&lt;/strong&gt;, e ci ha permesso di evitare una possibile sorgente di bug nel nostro codice, e diversi mal di testa. Grazie al modo &lt;em&gt;seamless&lt;/em&gt; nel quale il framework XCTest è integrato in Xcode, risulta facile e veloce scrivere test che permettano di verificare immediatamente se il nostro codice funziona come dovrebbe, ed &lt;strong&gt;è Xcode stesso a incoraggiare la scrittura di test&lt;/strong&gt; nel corso della realizzazione di un&amp;rsquo;app o di una libreria generando automaticamente un target di test ogni volta in cui si crea un nuovo progetto: non ci sono più scuse quindi per non iniziare a scrivere test completi ed efficienti che permettano di &lt;strong&gt;realizzare software migliore&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Il progetto Xcode contenente tutto il codice mostrato nell&amp;rsquo;articolo è disponibile su &lt;a href=&#34;https://github.com/broomburgo/xcode-testing-in-pratica&#34;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Software testing: Coverage vs Efficacia</title>
      <link>http://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</link>
      <pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://engineering.facile.it/blog/ita/software-testing-coverage-vs-efficacia/</guid>
      <description>

&lt;p&gt;Controllare il tasso di coverage dei test è un&amp;rsquo;attività frequente tra gli sviluppatori.&lt;/p&gt;

&lt;p&gt;Numerosi sono i fattori che hanno reso il code coverage popolare:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;è una metrica facile da comprendere;&lt;/li&gt;
&lt;li&gt;si misura senza difficoltà;&lt;/li&gt;
&lt;li&gt;è oggettiva e imparziale;&lt;/li&gt;
&lt;li&gt;è universale (applicabile a tutti i paradigmi di programmazione).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ma al di là di questi vantaggi, &lt;strong&gt;&lt;em&gt;possiamo affermare che una test suite con un&amp;rsquo;alta percentuale di coverage sia realmente efficace?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;quando-un-test-è-efficace&#34;&gt;Quando un test è efficace?&lt;/h3&gt;

&lt;p&gt;Una test suite è considerata efficace se consente di rilevare una grande quantità di failure; d&amp;rsquo;altronde, ciò è proprio la finalità ultima del software testing.
La massima efficacia è realizzabile solo applicando testing esaustivo ma, siccome ciò è spesso impraticabile, ci si accontenta di test più semplici con un&amp;rsquo;efficacia inferiore.
È importante notare che, a differenza del coverage, il livello d&amp;rsquo;efficacia viene stabilito soggettivamente dallo sviluppatore.&lt;/p&gt;

&lt;h3 id=&#34;quanti-tipi-di-coverage&#34;&gt;Quanti tipi di coverage?&lt;/h3&gt;

&lt;p&gt;La copertura può essere misurata in molti modi differenti. Essa è sempre un rapporto tipicamente espresso in forma percentuale.&lt;/p&gt;

&lt;p&gt;La formula per il calcolo del coverage è la seguente:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Notare il termine generico &lt;em&gt;obiettivo&lt;/em&gt;: diverse tipologie di coverage hanno obiettivi differenti.
Qui di seguito è presente un elenco esemplificativo e non esaustivo delle diverse tipologie di coverage:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Statement coverage&lt;/li&gt;
&lt;li&gt;Branch coverage (o decision coverage)&lt;/li&gt;
&lt;li&gt;Condition coverage&lt;/li&gt;
&lt;li&gt;Function/Method coverage&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nel corso di quest&amp;rsquo;articolo si fa riferimento sempre allo Statement coverage, talvolta chiamato semplicemente &amp;ldquo;coverage&amp;rdquo;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;un-esempio-pratico&#34;&gt;Un esempio pratico&lt;/h3&gt;

&lt;h4 id=&#34;funzione-under-test&#34;&gt;Funzione under-test&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def weightedAverage(array):
	sum = weightSum = 0     # Bug, dovrebbe essere: sum = weightSum = 0.0
	for (value, weight) in array:
		sum += value        # Bug, dovrebbe essere: sum += value * weight
		weightSum += weight
	return sum / weightSum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le specifiche della funzione &lt;em&gt;weightedAverage&lt;/em&gt; sono le seguenti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Calcolare la media ponderata di un array contenente coppie di valori.&lt;br /&gt;
Ad esempio: &lt;code&gt;[(10, 2), (11, 4), (5, 1)]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Restituire sempre un risultato di tipo float.&lt;/li&gt;
&lt;li&gt;Non effettuare divisione tra interi per non ridurre la precisione del risultato.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I commenti già presenti nel codice evidenziano due errori importanti:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;La media non è calcolata correttamente: l&amp;rsquo;istruzione &lt;code&gt;sum += value&lt;/code&gt; dovrebbe essere &lt;code&gt;sum += value * weight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;L&amp;rsquo;output della funzione non è di tipo float se i dati di input sono interi.&lt;br /&gt;
L&amp;rsquo;errore è risolvibile modificando &lt;code&gt;sum = weightSum = 0&lt;/code&gt; in &lt;code&gt;sum = weightSum = 0.0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;test-suite-1&#34;&gt;Test suite #1&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverage():
	expected = 25.0
	inputArray = [(24, 1), (26, 1)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #1 ha statement coverage 100%, tuttavia non consente di rilevare i due errori menzionati in precedenza. Sebbene la coverage sia alta, l&amp;rsquo;efficacia è molto bassa.&lt;/p&gt;

&lt;h4 id=&#34;test-suite-2&#34;&gt;Test suite #2&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverageDifferentWeight():
	expected = 26.0
	inputArray = [(24, 1), (27, 2)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #2 ha statement coverage 100%, ma non consente di verificare correttamente che l&amp;rsquo;output della funzione sia di tipo float.
Il primo errore viene rilevato, il secondo no.
È importante notare che questo problema viene risolto aggiungendo l&amp;rsquo;asserzione &lt;code&gt;type(actual) is float&lt;/code&gt;.&lt;br /&gt;
Le asserzioni sono parte fondamentale del testing; date loro la giusta importanza! Ogni buona asserzione in più consente di migliorare sensibilmente l&amp;rsquo;efficacia dei vostri test case.&lt;/p&gt;

&lt;h4 id=&#34;test-suite-3&#34;&gt;Test suite #3&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def testWeightedAverageFloatResult():
	expected = 27.2
	inputArray = [(24, 1), (28, 4)]
	actual = weightedAverage(inputArray)
	if expected == actual:
		print &#39;Okay&#39;
	else:
		print &#39;Failure!&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La test suite #3 ha statement coverage 100% ed è efficace perché ci consente di rilevare tutti gli errori.&lt;/p&gt;

&lt;h3 id=&#34;conclusioni&#34;&gt;Conclusioni&lt;/h3&gt;

&lt;p&gt;Abbiamo visto che percentuali di coverage alte non sempre implicano test efficaci.
Tuttavia test suite efficaci hanno necessariamente bisogno di coverage rate alti.
In temini logici possiamo quindi affermare che:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn--1-.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Coverage rate bassi sono un campanello d&amp;rsquo;allarme che ci consente di stabilire la scarca efficacia dei test.
Possiamo infatti affermare che:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://engineering.facile.it/images/software-testing-coverage-vs-efficacia/CodeCogsEqn--2-.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>